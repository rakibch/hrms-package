import { defineComponent as Q, computed as te, watch as ge, reactive as Y, isVue2 as re, isVue3 as Oe } from "vue-demi";
import * as h from "helper-js";
import { walkTreeData as ut } from "helper-js";
import Ne from "@virtual-list/vue";
import { openBlock as L, createElementBlock as E, normalizeClass as J, normalizeStyle as A, Fragment as ie, renderList as we, createCommentVNode as ye, createElementVNode as z, renderSlot as _, resolveComponent as ve, createBlock as Se, withCtx as X, createVNode as ke, createTextVNode as xe, toDisplayString as Le } from "vue";
import { makeTreeProcessor as $e, CHILDREN as me } from "@he-tree/tree-utils";
import { extendedDND as Be, context as R } from "@he-tree/dnd-utils";
/*!
 * @he-tree/vue v2.9.3
 * Author: phphe <phphe@outlook.com> (https://github.com/phphe)
 * Homepage: https://hetree.phphe.com/
 * Released under the MIT License.
 */
let Z = !1;
const Ee = () => {
  Z = !0, setTimeout(() => {
    Z = !1;
  }, 100);
}, Ve = Q({
  // components: {},
  props: ["stat", "rtl", "btt", "indent", "table", "treeLine", "treeLineOffset", "processor"],
  emits: ["open", "close", "check"],
  setup(e, { emit: t }) {
    const n = te(() => ({
      [e.rtl ? "paddingRight" : "paddingLeft"]: e.indent * (e.stat.level - 1) + "px"
    }));
    ge(
      () => e.stat.checked,
      (y) => {
        Z || e.processor.afterOneCheckChanged(e.stat) && t("check", e.stat);
      }
    ), ge(
      () => e.stat.open,
      (y) => {
        Z || (t(y ? "open" : "close", e.stat), Ee());
      }
    );
    const l = te(() => {
      const y = [], C = (o) => {
        var c;
        if (o.parent) {
          let d = (c = o.parent) == null ? void 0 : c.children.indexOf(o);
          do {
            d++;
            let g = o.parent.children[d];
            if (g) {
              if (!g.hidden)
                return !0;
            } else
              break;
          } while (!0);
        }
        return !1;
      }, b = e.rtl ? "right" : "left", D = e.btt ? "top" : "bottom";
      let i = e.stat;
      for (; i; ) {
        let o = (i.level - 2) * e.indent + e.treeLineOffset;
        const c = C(i), d = () => {
          y.push({
            style: {
              [b]: o + "px",
              [D]: c ? 0 : "50%"
            }
          });
        };
        i === e.stat ? i.level > 1 && d() : c && d(), i = i.parent;
      }
      return y;
    }), s = te(() => {
      let y = (e.stat.level - 2) * e.indent + e.treeLineOffset;
      return {
        [e.rtl ? "right" : "left"]: y + "px"
      };
    });
    return { indentStyle: n, vLines: l, hLineStyle: s };
  }
  // data() {
  //   return {}
  // },
  // computed: {},
  // watch: {},
  // methods: {},
  // created() {},
  // mounted() {}
}), se = (e, t) => {
  const n = e.__vccOpts || e;
  for (const [l, s] of t)
    n[l] = s;
  return n;
}, Pe = { class: "tree-node-inner" }, Fe = {
  key: 1,
  class: "tree-node",
  ref: "el"
};
function Ie(e, t, n, l, s, y) {
  return e.table ? (L(), E("tr", Fe, [
    _(e.$slots, "default", { indentStyle: e.indentStyle })
  ], 512)) : (L(), E("div", {
    key: 0,
    class: J(["tree-node", { "tree-node--with-tree-line": e.treeLine }]),
    style: A(e.indentStyle),
    ref: "el"
  }, [
    e.treeLine ? (L(), E(ie, { key: 0 }, [
      (L(!0), E(ie, null, we(e.vLines, (C) => (L(), E("div", {
        class: "tree-line tree-vline",
        style: A(C.style)
      }, null, 4))), 256)),
      e.stat.level > 1 ? (L(), E("div", {
        key: 0,
        class: "tree-line tree-hline",
        style: A(e.hLineStyle)
      }, null, 4)) : ye("", !0)
    ], 64)) : ye("", !0),
    z("div", Pe, [
      _(e.$slots, "default", { indentStyle: e.indentStyle })
    ])
  ], 6));
}
const Re = /* @__PURE__ */ se(Ve, [["render", Ie]]);
function Ue(e, t = {}) {
  const n = {
    ...t,
    statHandler(l) {
      return this._statHandler2 && (l = this._statHandler2(l)), ne(t.statHandler, Y(l));
    },
    statsHandler(l) {
      return ne(t.statsHandler, Y(l));
    },
    statsFlatHandler(l) {
      return ne(t.statsFlatHandler, Y(l));
    }
  };
  return $e(e, n);
}
function ne(e, t) {
  return e ? e(t) : t;
}
const _e = Q({
  components: { VirtualList: Ne, TreeNode: Re },
  props: {
    // for vue2
    value: { required: re, type: Array },
    // for vue3
    modelValue: { required: Oe, type: Array },
    updateBehavior: {
      type: String,
      default: "modify"
    },
    processor: {
      type: Object,
      default: () => Ue([], {
        noInitialization: !0
      })
    },
    childrenKey: { type: String, default: "children" },
    /**
     * for default slot. 用于默认插槽
     */
    textKey: { type: String, default: "text" },
    /**
     * node indent. 节点缩进
     */
    indent: { type: Number, default: 20 },
    /**
     * Enable virtual list. 启用虚拟列表
     */
    virtualization: { type: Boolean, default: !1 },
    /**
     * Render count for virtual list at start. 虚拟列表初始渲染数量.
     */
    virtualizationPrerenderCount: { type: Number, default: 20 },
    /**
     * Open all nodes by default. 默认打开所有节点.
     */
    defaultOpen: { type: Boolean, default: !0 },
    statHandler: { type: Function },
    /**
     * From right to left. 由右向左显示.
     */
    rtl: { type: Boolean, default: !1 },
    /**
     * From bottom to top. 由下向上显示
     */
    btt: { type: Boolean, default: !1 },
    /**
     * Display as table
     */
    table: { type: Boolean, default: !1 },
    watermark: { type: Boolean, default: !1 },
    nodeKey: {
      type: [String, Function],
      default: "index"
    },
    treeLine: { type: Boolean, default: !1 },
    treeLineOffset: { type: Number, default: 8 }
  },
  emits: [
    "update:modelValue",
    "click:node",
    "open:node",
    "close:node",
    "check:node",
    "beforeDragStart",
    "before-drag-start",
    "after-drop",
    "change",
    "enter",
    "leave"
  ],
  data() {
    return {
      stats: [],
      statsFlat: [],
      dragNode: null,
      dragOvering: !1,
      placeholderData: {},
      placeholderColspan: 1,
      batchUpdateWaiting: !1,
      self: this,
      _ignoreValueChangeOnce: !1
    };
  },
  computed: {
    valueComputed() {
      return (re ? this.value : this.modelValue) || [];
    },
    visibleStats() {
      const { statsFlat: e, isVisible: t } = this;
      let n = e;
      return this.btt && (n = n.slice(), n.reverse()), n.filter((l) => t(l));
    },
    rootChildren() {
      return this.stats;
    }
  },
  methods: {
    _emitValue(e) {
      this.$emit(re ? "input" : "update:modelValue", e);
    },
    /**
     * private method
     * @param value
     */
    _updateValue(e) {
      return this.updateBehavior === "disabled" ? !1 : (e !== this.valueComputed && (this._ignoreValueChangeOnce = !0), this._emitValue(e), !0);
    },
    getStat: ae(
      S("getStat")
    ),
    has: ae(S("has")),
    updateCheck: S(
      "updateCheck"
    ),
    getChecked: S(
      "getChecked"
    ),
    getUnchecked: S(
      "getUnchecked"
    ),
    openAll: S("openAll"),
    closeAll: S("closeAll"),
    openNodeAndParents: S(
      "openNodeAndParents"
    ),
    isVisible: S("isVisible"),
    move: be("move"),
    add: ae(
      be("add")
    ),
    addMulti(e, t, n) {
      this.batchUpdate(() => {
        let l = n;
        for (const s of e)
          this.add(s, t, l), l != null && l++;
      });
    },
    remove: S("remove"),
    removeMulti(e) {
      let t = [...e];
      this.batchUpdate(() => {
        for (const n of t)
          this.remove(n);
      });
    },
    iterateParent: S(
      "iterateParent"
    ),
    getSiblings: S(
      "getSiblings"
    ),
    getData: S("getData"),
    getRootEl() {
      return this.$refs.vtlist.listElRef;
    },
    batchUpdate(e) {
      const t = this.ignoreUpdate(e);
      return this.batchUpdateWaiting || this._updateValue(
        this.updateBehavior === "new" ? this.getData() : this.valueComputed
      ), t;
    },
    ignoreUpdate(e) {
      const t = this.batchUpdateWaiting;
      this.batchUpdateWaiting = !0;
      const n = e();
      return this.batchUpdateWaiting = t, n;
    }
  },
  watch: {
    processor: {
      immediate: !0,
      handler(e) {
        if (e) {
          const t = (n) => {
            if (n) {
              const { childrenKey: l } = this;
              return n[l] || (n[l] = []), n[l];
            } else
              return this.valueComputed;
          };
          e._statHandler2 = this.statHandler ? (n) => n.data === this.placeholderData ? n : this.statHandler(n) : null, e.afterSetStat = (n, l, s) => {
            const { childrenKey: y, updateBehavior: C } = this;
            let b = this.valueComputed;
            if (C === "new") {
              if (this.batchUpdateWaiting)
                return;
              b = this.getData();
            } else if (C === "modify") {
              const D = t(l == null ? void 0 : l.data);
              D.includes(n.data) || D.splice(s, 0, n.data);
            }
            this.batchUpdateWaiting || this._updateValue(b);
          }, e.afterRemoveStat = (n) => {
            var C;
            const { childrenKey: l, updateBehavior: s } = this;
            let y = this.valueComputed;
            if (s === "new") {
              if (this.batchUpdateWaiting)
                return;
              y = this.getData();
            } else if (s === "modify") {
              const b = t((C = n.parent) == null ? void 0 : C.data);
              h.arrayRemove(b, n.data);
            }
            this.batchUpdateWaiting || this._updateValue(y);
          };
        }
        e.initialized || (e.data = this.valueComputed, Object.assign(
          e,
          h.objectOnly(this, ["childrenKey", "defaultOpen"])
        ), e.init(), e.updateCheck()), this.stats = e.stats, this.statsFlat = e.statsFlat, e.data !== this.valueComputed && this._updateValue(e.data);
      }
    },
    valueComputed: {
      handler(e) {
        if (this.dragOvering || this.dragNode || this._ignoreValueChangeOnce)
          this._ignoreValueChangeOnce = !1;
        else {
          const { processor: n } = this;
          n.data = e, n.init(), this.stats = n.stats, this.statsFlat = n.statsFlat;
        }
      }
    }
  },
  created() {
  },
  mounted() {
    typeof window < "u" && (this.watermark === !1 && (window._heTreeWatermarkDisabled = !0), this.watermark && !window._heTreeWatermarkDisabled && (window._heTreeWatermark || (window._heTreeWatermark = !0, console.log(
      "%c[he-tree] Vue tree component:  https://hetree.phphe.com",
      "color:#0075ff; font-size:14px;"
    ))));
  }
});
function S(e) {
  return function(...t) {
    return this.processor[e](...t);
  };
}
function be(e) {
  return function(...t) {
    return this.batchUpdate(() => this.processor[e](...t));
  };
}
function ae(e) {
  return function(t, ...n) {
    return t && (t = Y(t)), e.call(this, t, ...n);
  };
}
const Me = {
  key: 0,
  class: "drag-placeholder he-tree-drag-placeholder"
}, Te = ["colspan"], He = { class: "drag-placeholder he-tree-drag-placeholder" };
function We(e, t, n, l, s, y) {
  const C = ve("TreeNode"), b = ve("VirtualList");
  return L(), Se(b, {
    class: J(["he-tree", {
      "he-tree--rtl rtl": e.rtl,
      "he-tree--drag-overing drag-overing": e.dragOvering
    }]),
    ref: "vtlist",
    items: e.visibleStats,
    disabled: !e.virtualization,
    table: e.table,
    itemKey: e.nodeKey
  }, {
    prepend: X(() => [
      _(e.$slots, "prepend", { tree: e.self })
    ]),
    default: X(({ item: D, index: i }) => [
      ke(C, {
        "vt-index": i,
        class: J([
          D.class,
          {
            "drag-placeholder-wrapper": D.data === e.placeholderData,
            "dragging-node": D === e.dragNode
          }
        ]),
        style: A(D.style),
        stat: D,
        rtl: e.rtl,
        btt: e.btt,
        indent: e.indent,
        table: e.table,
        treeLine: e.treeLine,
        treeLineOffset: e.treeLineOffset,
        processor: e.processor,
        onClick: (o) => e.$emit("click:node", D),
        onOpen: t[0] || (t[0] = (o) => e.$emit("open:node", o)),
        onClose: t[1] || (t[1] = (o) => e.$emit("close:node", o)),
        onCheck: t[2] || (t[2] = (o) => e.$emit("check:node", o))
      }, {
        default: X(({ indentStyle: o }) => [
          D.data === e.placeholderData ? (L(), E(ie, { key: 0 }, [
            e.table ? (L(), E("td", {
              key: 1,
              style: A(o),
              colspan: e.placeholderColspan
            }, [
              z("div", He, [
                _(e.$slots, "placeholder", { tree: e.self })
              ])
            ], 12, Te)) : (L(), E("div", Me, [
              _(e.$slots, "placeholder", { tree: e.self })
            ]))
          ], 64)) : _(e.$slots, "default", {
            key: 1,
            node: D.data,
            stat: D,
            indentStyle: o,
            tree: e.self
          }, () => [
            xe(Le(D.data[e.textKey]), 1)
          ])
        ]),
        _: 2
      }, 1032, ["vt-index", "class", "style", "stat", "rtl", "btt", "indent", "table", "treeLine", "treeLineOffset", "processor", "onClick"])
    ]),
    append: X(() => [
      _(e.$slots, "append", { tree: e.self })
    ]),
    _: 3
  }, 8, ["class", "items", "disabled", "table", "itemKey"]);
}
const Ke = /* @__PURE__ */ se(_e, [["render", We]]);
let a = null, r = null, G, K, U, q, le, N, oe;
const lt = {
  get startInfo() {
    return G;
  },
  get targetInfo() {
    return K;
  },
  get dragNode() {
    return N;
  },
  get startTree() {
    return a;
  },
  get targetTree() {
    return r;
  },
  get closestNode() {
    return oe;
  }
}, Ae = Q({
  extends: Ke,
  props: {
    triggerClass: { type: [String, Array] },
    disableDrag: Boolean,
    disableDrop: Boolean,
    eachDraggable: {
      type: Function
    },
    eachDroppable: {
      type: Function
    },
    rootDroppable: {
      type: [Boolean, Function],
      default: !0
    },
    /**
     * open closed node when drag over
     */
    dragOpen: { type: Boolean, default: !0 },
    dragOpenDelay: { type: Number, default: 0 },
    /**
     * e.g.: you can load children by ajax in the hook
     */
    beforeDragOpen: { type: Function },
    resolveStartMovePoint: {
      type: [String, Function]
    },
    /**
     * if remove placeholder when drag leave a tree
     */
    keepPlaceholder: { type: Boolean },
    /**
     * prevent drop if greater than maxLevel
     */
    maxLevel: { type: Number },
    /**
     * copy when drag
     */
    dragCopy: { type: Boolean },
    /**
     * return new data when drag copy
     */
    dragCopyDataHandler: {
      type: Function
    },
    onExternalDragOver: {
      type: Function
    },
    externalDataHandler: {
      type: Function
    },
    // hook of event HTML5 Drag and Drop API's dragstart event
    ondragstart: {
      type: Function
    }
  },
  data() {
    return {
      treeDraggableInstance: null
    };
  },
  computed: {},
  methods: {
    getNodeByElement(e) {
      const t = e.getAttribute("vt-index");
      return t == null ? null : this.visibleStats[t];
    },
    isDraggable(e) {
      if (this.disableDrag)
        return !1;
      if (e.draggable != null)
        return e.draggable;
      if (this.eachDraggable) {
        const n = this.eachDraggable(e);
        if (n != null)
          return n;
      }
      const { parent: t } = e;
      return t ? this.isDraggable(t) : !0;
    },
    isDroppable(e) {
      if (this.disableDrop)
        return !1;
      if (!e)
        return h.resolveValueOrGettter(this.rootDroppable, [this, a]);
      if (e.droppable != null)
        return e.droppable;
      if (this.eachDroppable) {
        const n = this.eachDroppable(e);
        if (n != null)
          return n;
      }
      const { parent: t } = e;
      return t ? this.isDroppable(t) : !0;
    },
    _eachDroppable() {
      var e;
      return h.resolveValueOrGettter((e = this._isDragCopy) == null ? void 0 : e.call(this), [this]);
    }
  },
  mounted() {
    const e = (i, o) => {
      let c = !0;
      return a && a !== this && (c = c && this._isMoved), this.table && !this._isDragCopy && (c = c && this._isDragCopy), c && (i.x !== o.x || i.y !== o.y);
    }, t = (i, o) => {
      r.ignoreUpdate(() => {
        if (!r.has(r.placeholderData)) {
          if (r.table) {
            let d = 0;
            const g = r.getRootEl().querySelector("tr");
            if (g)
              for (const {
                value: v
              } of h.iterateAll(g.children))
                h.css(v, "display") !== "none" && (d += v.colSpan || 1);
            d < 1 && (d = 1), r.placeholderColspan = d;
          }
          r.add(r.placeholderData);
        }
        const c = r.getStat(r.placeholderData);
        r.move(c, i, o);
      });
    }, n = () => {
      const i = this;
      if (i.has(i.placeholderData))
        return i.remove(i.getStat(i.placeholderData)), !0;
    }, l = (i) => {
      i ? R.dropEffect = a != null && a.dragCopy ? "copy" : "move" : R.dropEffect = "none";
    }, s = (i) => {
      const o = this;
      i ? l(!0) : o.keepPlaceholder ? o.has(o.placeholderData) || l(!1) : (n(), l(!1));
    };
    let y = { x: 0, y: 0 };
    const C = this.getRootEl();
    let b = null;
    const D = () => {
      r != null && r.has(r.placeholderData) && r.ignoreUpdate(() => {
        r.remove(r.getStat(r.placeholderData)), a && (a.dragNode.hidden = !1, a.dragOvering = !1);
      });
    };
    this.treeDraggableInstance = Be(C, {
      beforeDragStart: (i) => {
        if (!R.triggerElement)
          return;
        let o = this.triggerClass;
        (!o || o.length === 0) && (o = "tree-node");
        let c = h.toArrayIfNot(o), d = h.findParent(
          R.triggerElement,
          (g) => {
            if (h.hasClassIn(g, c))
              return !0;
            if (h.hasClass(g, "tree-node"))
              return "break";
          },
          { withSelf: !0, until: C }
        );
        if (b = h.findParent(
          d,
          (g) => {
            if (h.hasClass(g, "tree-node"))
              return !0;
          },
          { withSelf: !0, until: C }
        ), !!b) {
          if (N = this.getNodeByElement(b), !N)
            throw "Can't find drag node";
          if (this.isDraggable(N))
            return this.$emit("before-drag-start", N), this.$emit("beforeDragStart", N), C;
        }
      },
      onDragStart: (i) => {
        var g, v, u;
        if (!b || !N)
          return;
        {
          const { x: p, y: k } = b.getBoundingClientRect(), { clientX: m, clientY: V } = i;
          (g = i.dataTransfer) == null || g.setDragImage(
            b,
            m - p,
            V - k
          );
        }
        le = { x: i.clientX, y: i.clientY }, a = this, a.dragNode = N, q = (() => {
          if (this.resolveStartMovePoint === "mouse")
            return { x: i.clientX, y: i.clientY };
          if (typeof this.resolveStartMovePoint == "function")
            return this.resolveStartMovePoint(b);
          {
            let p, k = 0;
            if (this.table) {
              let m = b.getBoundingClientRect();
              p = { x: m.x, y: m.y }, this.rtl && (p.x = m.right), k = m.height;
            } else if (!this.rtl)
              p = b.children[0].getBoundingClientRect().toJSON(), k = p.height;
            else {
              const m = b.children[0].getBoundingClientRect();
              p = {
                x: m.right,
                y: m.y
              }, k = m.height;
            }
            return this.btt && (p.y += k), p;
          }
        })(), this.dragOvering = !0;
        const c = a.getSiblings(a.dragNode), d = c.indexOf(N);
        G = {
          tree: a,
          dragNode: N,
          parent: N.parent,
          siblings: c,
          indexBeforeDrop: d
        }, r = this, (v = i.dataTransfer) == null || v.setData(
          "text",
          `he-tree drag start at ${(/* @__PURE__ */ new Date()).toISOString()}`
        ), a._eachDroppable() || setTimeout(() => {
          N.hidden = !0, t(N.parent, d + 1);
        }, 0), (u = this.ondragstart) == null || u.call(this, i);
      },
      // onDragEnter, onDragLeave, onDragOver, onDrop execute on target tree
      onEnter: (i) => {
        this.$emit("enter", i);
      },
      onLeave: (i) => {
        U = null, this.dragOvering = !1, R.preventDefault = !1, n(), this.$emit("leave", i);
      },
      onDragOver: h.applyFinally(
        (i) => {
          if (!a) {
            if (!this.onExternalDragOver || this.onExternalDragOver(i) === !1)
              return;
            R.preventDefault = !0;
          }
          const o = { x: i.clientX, y: i.clientY }, c = e(o, y);
          if (y = o, !c)
            return;
          this.dragOvering = !0, r = this;
          const d = q ? {
            x: q.x + (o.x - le.x),
            y: q.y + (o.y - le.y)
          } : { ...o }, { btt: g, rtl: v } = r;
          if (r.disableDrop) {
            R.dropEffect = "none";
            return;
          }
          let u, p;
          const k = r.getRootEl().querySelectorAll(".tree-node"), m = [];
          k.forEach((f) => {
            !h.hasClassIn(f, [
              "drag-placeholder-wrapper",
              "dragging-node"
            ]) && h.css(f, "display") !== "none" && m.push(f);
          });
          const V = h.binarySearch(
            m,
            (f) => h.getBoundingClientRect(f)[g ? "bottom" : "top"] - d.y,
            { returnNearestIfNoHit: !0 }
          );
          let O = null, F, ee;
          V.hit || (V.greater ? g || (O = V.index - 1, m[O] || O++) : g && (O = V.index + 1, m[O] || O--)), O == null && (O = V.index), F = m[O], ee = g ? m[O - 1] : m[O + 1], u = F && r.getNodeByElement(F), p = ee && r.getNodeByElement(ee);
          const { indent: j } = r, $ = h.cacheFunction(() => {
            if (r.table) {
              let f = h.getBoundingClientRect(F).toJSON();
              const x = j * (u.level - 1);
              return v ? (f.width -= x, f.right -= x) : f.x += x, f;
            } else
              return h.getBoundingClientRect(F.firstElementChild);
          }).action, de = h.cacheFunction(() => g ? d.y > $().y + $().height / 2 : d.y < $().y + $().height / 2).action, De = h.cacheFunction(() => g ? !F || O === m.length - 1 && de() : !F || O === 0 && de()).action, ue = h.cacheFunction(
            () => v ? d.x - ($().x + $().width) : $().x - d.x
          ).action, Ce = h.cacheFunction(
            () => v ? d.x < $().x + $().width - j : d.x > $().x + j
          ).action;
          let P;
          if (De())
            P = 1, u = null;
          else if (u)
            ue() > 0 ? P = u.level - Math.ceil(ue() / j) : Ce() ? P = u.level + 1 : P = u.level;
          else return;
          p && P < p.level && (P = p.level), (async () => {
            let f, x, I = !1, M = null;
            const H = async (w) => {
              if (w.open)
                return !0;
              if (r.dragOpen)
                if (r.dragOpenDelay)
                  if (M = w, U === w)
                    I = !0;
                  else {
                    let B = h.promisePin();
                    U = w;
                    const T = w;
                    return setTimeout(async () => {
                      T !== U ? (I = !0, B.resolve(!0)) : (r.beforeDragOpen && await r.beforeDragOpen(w), T !== U ? (I = !0, B.resolve(!0)) : (w.open = !0, M = null, B.resolve(!0)));
                    }, r.dragOpenDelay), await B.promise;
                  }
                else
                  return r.beforeDragOpen && await r.beforeDragOpen(w), w.open = !0, !0;
              else
                return !1;
            }, W = async () => {
              if (r.isDroppable(u) && await H(u)) {
                if (I)
                  return;
                f = u, x = null;
              } else
                return !1;
            }, he = (w = P) => {
              let B = u, T = [];
              for (; B && B.level >= w; )
                B = B.parent || null, T.unshift(B);
              let ce = 0;
              for (const pe of T) {
                if (r.isDroppable(pe))
                  return f = pe, x = T[ce + 1] || u, !0;
                ce++;
              }
              return !1;
            };
            oe = u || null, u ? P > u.level ? await W() === !1 && he(u.level) : he() === !1 && await W() : r.isDroppable(null) && (f = null), U = M;
            const fe = !!(!I && (f || f === null));
            return {
              cancelled: I,
              success: fe,
              parent: f,
              index: fe ? x ? (f ? f.children : r.stats).filter((w) => w.data !== r.placeholderData).indexOf(x) + 1 : 0 : -1
            };
          })().then((f) => {
            if (!f.cancelled) {
              if (!f.success) {
                s(!1);
                return;
              }
              if (r.maxLevel != null && r.maxLevel > 0) {
                let x = 1;
                if (a) {
                  const M = a.dragNode;
                  let H = 0;
                  h.walkTreeData(
                    M,
                    (W) => {
                      W.level > H && (H = W.level);
                    },
                    {
                      childrenKey: me
                    }
                  ), x = H - M.level + 1;
                }
                if (x + (f.parent ? f.parent.level : 0) > r.maxLevel) {
                  s(!1);
                  return;
                }
              }
              s(!0), t(f.parent, f.index);
            }
          });
        },
        () => {
        }
      ),
      onDrop: (i) => {
        r = this;
        const o = !a;
        if (!r)
          return;
        const c = a == null ? void 0 : a.dragNode;
        let d, g = (() => {
          var u;
          let v = !0;
          if (!r.has(r.placeholderData))
            v = !1;
          else if (o)
            d = (u = this.externalDataHandler) == null ? void 0 : u.call(this, i), v = d != null;
          else if (!a.dragCopy) {
            const p = r.getStat(
              r.placeholderData
            );
            a === r && p.parent === c.parent && (h.findTreeData(c, (k) => k === p), me);
          }
          return v;
        })();
        if (g) {
          const v = r.getStat(r.placeholderData), u = r.getSiblings(v);
          K = {
            tree: r,
            dragNode: c,
            parent: v.parent,
            siblings: u,
            indexBeforeDrop: u.indexOf(v)
          };
        }
        (() => {
          if (D(), g) {
            let v = K.indexBeforeDrop;
            a && !a.dragCopy && a === r && G.parent == K.parent && G.indexBeforeDrop < v && v--, a && a !== r && !a._eachDroppable() && a.batchUpdate(() => {
              a.remove(c), a.updateCheck();
            }), r.batchUpdate(() => {
              let u = a == null ? void 0 : a.dragNode, p;
              d ? p = d : a._eachDroppable() && (p = h.cloneTreeData(a.dragNode.data, {
                childrenKey: a.childrenKey
              }), a.dragCopyDataHandler && (p = a.dragCopyDataHandler(p))), p && (r.add(p), u = r.getStat(p)), r.move(u, K.parent, v), r.updateCheck();
            });
          }
          r.$emit("after-drop"), g && (a && (a.dragCopy || a.$emit("change")), r !== a && r.$emit("change"));
        })();
      },
      onDragEnd: (i) => {
        D(), a && (a.dragNode && (a.dragNode.hidden = !1), a.dragNode = null, a.dragOvering = !1, a = null), r = null, U = null, N = null, oe = null;
      }
    });
  },
  unmounted() {
    var e;
    (e = this.treeDraggableInstance) == null || e.destroy();
  }
}), ze = Q({
  props: {
    open: { type: Boolean }
  }
}), je = /* @__PURE__ */ z("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, [
  /* @__PURE__ */ z("title", null, "chevron-right"),
  /* @__PURE__ */ z("path", { d: "M8.59,16.58L13.17,12L8.59,7.41L10,6L16,12L10,18L8.59,16.58Z" })
], -1), Xe = [
  je
];
function qe(e, t, n, l, s, y) {
  return L(), E("a", {
    class: J(["he-tree__open-icon", { open: e.open }])
  }, Xe, 2);
}
const it = /* @__PURE__ */ se(ze, [["render", qe]]);
function ot(e, t) {
  try {
    return {
      mixins: [Ae],
      created: new Function(Ye(e, t))()
    };
  } catch {
    throw new Error("he-tree-pro: wrong secret key");
  }
}
function Ye(e, t) {
  e = encodeURIComponent(e), e.length % 2 === 1 && (e += "h"), e = e.split("").reverse().join(""), t = atob(t);
  for (let n = 0; n < e.length; n += 2) {
    const l = e[n], s = e[n + 1];
    t = Ge(t, l, s);
  }
  return Je(
    "arb=inowc=ocmet;etrnfucton){are=1,=tistr{evod !=b}ath(){e&(c_htreWtemak=)=e,._sMve=(=>._eteeatrmrkd.israCoy=)=d.abe,._acDrppbl=(=>.dagop)}",
    t
  );
}
function Ge(e, t, n) {
  let l = "";
  for (let s = 0; s < e.length; s++) {
    const y = e[s];
    y === t ? l += n : y === n ? l += t : l += y;
  }
  return l;
}
function Je(e, t) {
  let n = 0, l = "";
  for (; ; ) {
    let s;
    if (s = n, s >= t.length || (l += t[s], s = n * 2, s >= e.length) || (l += e[s], s += 1, s >= e.length))
      break;
    l += e[s], n++;
  }
  return l;
}
export {
  Ke as BaseTree,
  Ae as Draggable,
  it as OpenIcon,
  Re as TreeNode,
  lt as context,
  lt as dragContext,
  ot as pro,
  ut as walkTreeData
};
