{"version":3,"file":"index.iife.js","sources":["../../../../node_modules/.pnpm/@babel+runtime@7.17.2/node_modules/@babel/runtime/helpers/esm/defineProperty.js","../../../../node_modules/.pnpm/helper-js@3.1.2/node_modules/helper-js/dist/index.esm.js","../../../../node_modules/.pnpm/@virtual-list+vue@1.2.1_@vue+composition-api@1.4.9_vue@3.2.31__vue@3.2.31/node_modules/@virtual-list/vue/dist/v3/index.mjs","../../src/components/TreeNode.vue","../../src/components/TreeNode.vue","../../../tree-utils/dist/index.esm.js","../../src/components/TreeProcessorVue.ts","../../src/components/BaseTree.vue","../../src/components/BaseTree.vue","../../../../node_modules/.pnpm/drag-event-service@2.0.0/node_modules/drag-event-service/dist/index.esm.js","../../../dnd-utils/dist/index.esm.js","../../src/components/DraggableTree.ts","../../src/components/OpenIcon.vue","../../src/components/OpenIcon.vue","../../src/index.ts"],"sourcesContent":["export default function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}","/*!\n * helper-js v3.1.2\n * Author: phphe <phphe@outlook.com> (https://github.com/phphe)\n * Homepage: null\n * Released under the MIT License.\n */\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\n\n// ## base functions\n// ## 基础方法\n\n/**\r\n * get global, such as window in browser.\r\n * 返回顶级全局变量. 例如浏览器的`window`\r\n * @returns\r\n */\nfunction glb() {\n  try {\n    // `this` !== global or window because of build tool. So you can't use `this` to get `global`\n    return window;\n  } catch (error) {\n    return global;\n  }\n}\n/**\r\n * detect if global variable `document` existing.\r\n * 判断全局变量`document`是否存在\r\n * @returns\r\n */\n\nfunction isDocumentExisted() {\n  try {\n    let t = document;\n  } catch (e) {\n    return false;\n  }\n\n  return true;\n}\nfunction isArray(v) {\n  return Object.prototype.toString.call(v) === \"[object Array]\";\n}\nfunction isBool(v) {\n  return Object.prototype.toString.call(v) === \"[object Boolean]\";\n}\nfunction isNumber(v) {\n  return Object.prototype.toString.call(v) === \"[object Number]\";\n}\nfunction isNumeric(v) {\n  try {\n    // @ts-ignore\n    return isFinite(v) && !isNaN(parseFloat(v));\n  } catch (error) {\n    return false;\n  }\n}\nfunction isString(v) {\n  return Object.prototype.toString.call(v) === \"[object String]\";\n}\nfunction isObject(v) {\n  return Object.prototype.toString.call(v) === \"[object Object]\";\n}\nfunction isFunction(v) {\n  return typeof v === \"function\";\n}\nfunction isPromise(v) {\n  return Object.prototype.toString.call(v) === \"[object Promise]\";\n}\n/**\r\n * detect if argumrnt is null, undefined, empty array, empty string, false, NaN, empty object\r\n * 检查是否是null, undefined, 空数组, 空字符串, false, NaN, 空对象\r\n * @param v\r\n * @returns\r\n */\n\nfunction empty(v) {\n  if (v == null) {\n    return true;\n  } else if (v[\"length\"] != null) {\n    return v[\"length\"] === 0;\n  } else if (isBool(v)) {\n    return false;\n  } else if (isNumber(v)) {\n    return isNaN(v);\n  } else if (isObject(v)) {\n    return Object.keys(v).length === 0;\n  }\n}\n/**\r\n * rand int in range, including min and max\r\n * 返回指定范围随机整数, 包括范围起始值和终止值\r\n * @param min\r\n * @param max\r\n * @returns\r\n */\n\nfunction randInt(min, max) {\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n/**\r\n * rand item in array\r\n * 返回数组随机一项\r\n * @param arr\r\n * @returns\r\n */\n\nfunction randChoice(arr) {\n  return arr[randInt(0, arr.length - 1)];\n}\n/**\r\n * Pad a string to a certain length with another string\r\n * 左边补充指定字符, 使其达到指定长度\r\n * @param str\r\n * @param n\r\n * @param padString\r\n * @returns\r\n */\n\nfunction strPad(str, n) {\n  let padString = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"0\";\n  let r = str.toString();\n  let len = str.toString().length;\n\n  while (len < n) {\n    r = padString + r;\n    len++;\n  }\n\n  if (r.length > n) {\n    r = r.substring(r.length - n);\n  }\n\n  return str;\n}\n/**\r\n * If n less than `min`, return `min`, else n.\r\n * 如果n小于min, 返回min, 否则n.\r\n * @param n\r\n * @param min\r\n * @returns\r\n */\n\nfunction notLessThan(n, min) {\n  return n < min ? min : n;\n}\n/**\r\n * If n greater than `max`, return `max`, else n.\r\n * 如果n大于max, 返回max, 否则n.\r\n * @param n\r\n * @param max\r\n * @returns\r\n */\n\nfunction notGreaterThan(n, max) {\n  return n < max ? n : max;\n}\n/**\r\n * limit min and max of value.\r\n * 限制值的最小和最大值.\r\n * @param n\r\n * @param min\r\n * @param max\r\n * @returns\r\n */\n\nfunction between(n, min, max) {\n  return notGreaterThan(notLessThan(n, min), max);\n} // ## string\n// ## 字符串\n\n/**\r\n * 'abc abc' to 'Abc abc'\r\n * @param str\r\n * @returns\r\n */\n\nfunction studlyCase(str) {\n  return str && str[0].toUpperCase() + str.substring(1);\n}\n/**\r\n * To lower case and use `-` as delimiter. example: '-ABC abc_def camelCase-- helloMyFriend' to 'a-b-c-abc-def-camel-case-hello-my-friend'\r\n * @param str\r\n * @returns\r\n */\n\nfunction kebabCase(str) {\n  return str.replace(/ /g, \"-\").replace(/_/g, \"-\").replace(/(?<=[a-z])([A-Z])/g, \"-$1\").replace(/--+/g, \"-\").replace(/^-|-$|/g, \"\").toLowerCase();\n}\n/**\r\n * To lower case and use `_` as delimiter.\r\n * @param str\r\n * @returns\r\n */\n\nfunction snakeCase(str) {\n  return kebabCase(str).replace(/-/g, \"_\");\n}\n/**\r\n * 'abc-abc-abc_abc' to 'AbcAbcAbcAbc'\r\n * @param str\r\n * @returns\r\n */\n\nfunction camelCase(str) {\n  const temp = kebabCase(str).split(\"-\");\n\n  for (let i = 1; i < temp.length; i++) {\n    temp[i] = studlyCase(temp[i]);\n  }\n\n  return temp.join(\"\");\n}\n/**\r\n * 'AbcAbcAbcAbc' to ['Abc', 'Abc', 'Abc', 'Abc']\r\n * @param str\r\n * @returns\r\n */\n\nfunction camelToWords(str) {\n  return str.split(/(?<=[a-z])(?=[A-Z])/g);\n}\n/**\r\n * 'abcAbc' to 'Abc Abc'\r\n * @param str\r\n * @returns\r\n */\n\nfunction titleCase(str) {\n  return camelToWords(studlyCase(camelCase(str))).join(\" \");\n}\n/**\r\n * generate random string\r\n * 随机字符串\r\n * @param len default 8\r\n * @param seeds\r\n * @returns\r\n */\n\nfunction randString() {\n  let len = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;\n  let seeds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n  let r = \"\";\n\n  for (let i = 0; i < len; i++) {\n    r += randChoice(seeds);\n  }\n\n  return r;\n}\n/**\r\n * reverse a string\r\n * @param str\r\n * @returns\r\n */\n\nfunction reverseString(str) {\n  return str.split(\"\").reverse().join(\"\");\n} // ## Array\n// ## 数组\n\n/**\r\n * remove item from array. return removed count\r\n * 从数组删除项. 返回删除计数\r\n * @param arr\r\n * @param v\r\n * @returns\r\n */\n\nfunction arrayRemove(arr, v) {\n  let index;\n  let count = 0;\n\n  while ((index = arr.indexOf(v)) > -1) {\n    arr.splice(index, 1);\n    count++;\n  }\n\n  return count;\n}\n/**\r\n * remove items from array by sorted indexes. indexes example: [0, 2, 6, 8, 9]\r\n * 通过有序的索引集删除数组项. 索引集例子: [0, 2, 6, 8, 9]\r\n * @param arr\r\n * @param sortedIndexes\r\n */\n\nfunction arrayRemoveBySortedIndexes(arr, sortedIndexes) {\n  for (let i = sortedIndexes.length - 1; i >= 0; i--) {\n    const index = sortedIndexes[i];\n    arr.splice(index, 1);\n  }\n}\n/**\r\n * get item from array by index. index can be negative number\r\n * 通过索引获取数组一项. 支持负值索引.\r\n * @param arr\r\n * @param n\r\n * @returns\r\n */\n\nfunction arrayAt(arr, n) {\n  return arr[n >= 0 ? n : arr.length + n];\n}\n/**\r\n * get first or array\r\n * 返回数组首项\r\n * @param arr\r\n * @returns\r\n */\n\nfunction arrayFirst(arr) {\n  return arr[0];\n}\n/**\r\n * get last of array\r\n * 返回数组末项\r\n * @param arr\r\n * @returns\r\n */\n\nfunction arrayLast(arr) {\n  return arr[arr.length - 1];\n}\n/**\r\n *\r\n * @param arr1\r\n * @param arr2\r\n * @returns [diff1, diff2] diff1: in arr1 not in arr2. diff2: in arr2 not in arr1\r\n */\n\nfunction arrayDiff(arr1, arr2) {\n  const m1 = new Map();\n  const m2 = new Map();\n\n  for (const item of arr1) {\n    const count = m1.has(item) ? m1.get(item) : 0;\n    m1.set(item, count + 1);\n  }\n\n  for (const item of arr2) {\n    const count = m2.has(item) ? m2.get(item) : 0;\n    m2.set(item, count + 1);\n  }\n\n  const r1 = [];\n  const r2 = [];\n  m1.forEach((count, item) => {\n    const diff = count - (m2.has(item) ? m2.get(item) : 0);\n\n    if (diff > 0) {\n      diff === 1 ? r1.push(item) : r1.push(...new Array(diff).fill(item));\n    }\n  });\n  m2.forEach((count, item) => {\n    const diff = count - (m1.has(item) ? m1.get(item) : 0);\n\n    if (diff > 0) {\n      diff === 2 ? r2.push(item) : r2.push(...new Array(diff).fill(item));\n    }\n  });\n  return [r1, r2];\n}\n/**\r\n * like indexOf, get all indexes\r\n * @param strOrArr\r\n * @param item\r\n * @returns\r\n */\n\nfunction indexesOf(strOrArr, item) {\n  let i = 0;\n  const indexes = [];\n\n  while (i < strOrArr.length) {\n    const index = strOrArr.indexOf(item, i);\n\n    if (index === -1) {\n      break;\n    } else {\n      indexes.push(index);\n\n      if (typeof strOrArr === \"string\") {\n        i = index + (item + \"\").length;\n      } else {\n        i = index + 1;\n      }\n    }\n  }\n\n  return indexes;\n}\n/**\r\n * get array item siblings. Example: getArrayItemSiblings(arr, item, [-1, 1]), get previous and next sibling\r\n * 获得数组项的多个同级. 例: getArrayItemSiblings(arr, item, [-1, 1]), 获得前一个和后一个\r\n * @param arr\r\n * @param item\r\n * @param offsets\r\n * @returns\r\n */\n\nfunction getArrayItemSiblingsByOffsets(arr, item, offsets) {\n  const index = arr.indexOf(item);\n\n  if (index === -1) {\n    throw \"item is not in array\";\n  }\n\n  return offsets.map(v => arr[index + v]);\n}\nfunction toArrayIfNot(arrOrNot) {\n  return isArray(arrOrNot) ? arrOrNot : [arrOrNot];\n}\n/**\r\n * Split array every n. n can be getter, which argument is the times.\r\n * 每n个拆分数组. n可以是方法, 参数是第几次分块\r\n * @param arr\r\n * @param n\r\n * @returns\r\n */\n\nfunction splitArray(arr, n) {\n  const r = [];\n\n  if (isFunction(n)) {\n    const getChunkLength = n;\n    let times = 1;\n    let i = 0;\n\n    while (i < arr.length) {\n      const n = getChunkLength(times);\n      const end = i + n;\n      r.push(arr.slice(i, end));\n      i = end;\n      times++;\n    }\n  } else {\n    let i = 0;\n\n    while (i < arr.length) {\n      const end = i + n;\n      r.push(arr.slice(i, end));\n      i = end;\n    }\n  }\n\n  return r;\n}\n/**\r\n * group array by mark\r\n * 计算每项的标识, 通过标识将数组项分组.\r\n * @param arr\r\n * @param getMark\r\n * @returns\r\n */\n\nfunction groupArray(arr, getMark) {\n  const groups = new Map();\n  arr.forEach(v => {\n    const mark = getMark(v);\n\n    if (!groups.has(mark)) {\n      groups.set(mark, []);\n    }\n\n    groups.get(mark).push(v);\n  });\n  return groups;\n}\n/**\r\n * Each item in the new array is unique.\r\n * 新数组每项唯一.\r\n * @param arr\r\n * @param getMark\r\n * @returns\r\n */\n\nfunction arrayDistinct(arr, getMark) {\n  const t = new Set();\n  return arr.filter((v, i) => {\n    const mark = getMark ? getMark(v, i) : v;\n\n    if (!t.has(mark)) {\n      t.add(mark);\n      return true;\n    }\n  });\n}\n/**\r\n * get items from array between 2 indeies. index can be negative\r\n * 从数组获得一个范围内的项. 范围可以为负.\r\n * @param arr\r\n * @param index\r\n * @param endIndex\r\n * @returns\r\n */\n\nfunction arrayBetween(arr, index, endIndex) {\n  if (index < 0) {\n    index += arr.length;\n  }\n\n  if (endIndex < 0) {\n    endIndex += arr.length;\n  }\n\n  return arr.slice(index, endIndex - index + 1);\n}\n/**\r\n * return new array excluding n items from end\r\n * 返回新数组排除末尾n项\r\n * @param arr\r\n * @param n\r\n * @returns\r\n */\n\nfunction arrayWithoutEnd(arr) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  return arr.slice(0, arr.length - n);\n}\n/**\r\n * get one-dimensional array from multidimensional array\r\n * 从多维数组获取一维数组\r\n * @param arr\r\n * @param depth\r\n * @returns\r\n */\n\nfunction arrayFlat(arr) {\n  let depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n  const r = [];\n\n  const rec = (arr, curentDepth) => {\n    for (const item of arr) {\n      if (isArray(item) && curentDepth < depth) {\n        rec(item, curentDepth + 1);\n      } else {\n        r.push(item);\n      }\n    }\n  };\n\n  rec(arr, 0);\n  return r;\n}\n/**\r\n * simplified array.filter()\r\n * e.g.: arrayFilter(arr, [null, undefined]) equal to arr.filter(v => v!== null && v!== undefined)\r\n * @param arr\r\n * @param without\r\n * @returns\r\n */\n\nfunction arrayFilter(arr, without) {\n  // @ts-ignore\n  return arr.filter(v => without.indexOf(v) > -1);\n}\n/**\r\n * alias of arrayFilter\r\n */\n\nconst arrayWithout = arrayFilter; // ## Object\n// ## 对象\n\n/**\r\n * return JSON.parse(JSON.stringify(obj))\r\n * @param obj\r\n * @returns\r\n */\n\nfunction cloneObject(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n/**\r\n * like Array.map\r\n * @param obj\r\n * @param handler\r\n * @returns\r\n */\n\nfunction objectMap(obj, handler) {\n  const r = {};\n  let i = 0;\n\n  for (const key in obj) {\n    r[key] = handler(obj[key], key, i);\n    i++;\n  }\n\n  return r;\n}\nfunction objectOnly(obj, keys) {\n  let keysSet = new Set(keys);\n  const r = {};\n  keysSet.forEach(key => {\n    r[key] = obj[key];\n  });\n  return r;\n}\nfunction objectExcept(obj, keys) {\n  let keysSet = new Set(keys);\n  const r = {};\n\n  for (const key in obj) {\n    if (!keysSet.has(key)) {\n      r[key] = obj[key];\n    }\n  }\n\n  return r;\n}\nfunction* iterateAll(val) {\n  let opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  // opt: {reverse, exclude}\n  if (!opt.reverse) {\n    // @ts-ignore\n    if (val.length != null) {\n      // @ts-ignore\n      for (let i = 0; i < val.length; i++) {\n        const info = {\n          value: val[i],\n          index: i\n        };\n\n        if (!opt.exclude || !opt.exclude(info)) {\n          yield info;\n        }\n      }\n    } else if (isObject(val)) {\n      for (const key of Object.keys(val)) {\n        const info = {\n          value: val[key],\n          key\n        };\n\n        if (!opt.exclude || !opt.exclude(info)) {\n          yield info;\n        }\n      }\n    } else {\n      throw \"Unsupported type\";\n    }\n  } else {\n    // @ts-ignore\n    if (val.length != null) {\n      // @ts-ignore\n      for (let i = val.length - 1; i >= 0; i--) {\n        const info = {\n          value: val[i],\n          index: i\n        };\n\n        if (!opt.exclude || !opt.exclude(info)) {\n          yield info;\n        }\n      }\n    } else if (isObject(val)) {\n      const keys = Object.keys(val);\n      keys.reverse();\n\n      for (const key of keys) {\n        const info = {\n          value: val[key],\n          key\n        };\n\n        if (!opt.exclude || !opt.exclude(info)) {\n          yield info;\n        }\n      }\n    } else {\n      throw \"Unsupported type\";\n    }\n  }\n}\n/**\r\n * like Array.find\r\n * @param list\r\n * @param callback\r\n * @param options\r\n * @returns\r\n */\n\nfunction findAll(list, callback, options) {\n  for (const {\n    value,\n    index\n  } of iterateAll(list, options)) {\n    if (callback(value, index)) {\n      return value;\n    }\n  }\n} // example: objectGet(window, 'document.body.children.0') . source: http://stackoverflow.com/questions/8817394/javascript-get-deep-value-from-object-by-passing-path-to-it-as-string\n// 例: objectGet(window, 'document.body.children.0') . 参考: http://stackoverflow.com/questions/8817394/javascript-get-deep-value-from-object-by-passing-path-to-it-as-string\n\n/**\r\n * example: dotGet(window, 'document.body.children.0')\r\n * @param obj\r\n * @param path\r\n * @param throwError\r\n * @returns\r\n */\n\nfunction dotGet(obj, path, throwError) {\n  const paths = isArray(path) ? path : path.split(\".\");\n  let current = obj;\n\n  try {\n    for (const key of paths) {\n      current = current[key];\n    }\n  } catch (e) {\n    if (throwError) {\n      throw \"Path does not exist\";\n    }\n  }\n\n  return current;\n}\n/**\r\n * example: dotSet(window, 'document.body.children.0', vaue)\r\n */\n\nfunction dotSet(obj, path, value) {\n  const paths = isArray(path) ? path : path.split(\".\");\n  const lastKey = arrayLast(paths);\n  const parent = dotGet(obj, paths.slice(0, paths.length - 1));\n\n  if (!parent) {\n    throw \"Path does not exist\";\n  }\n\n  parent[lastKey] = value;\n}\n/**\r\n * try to delete obj[prop]\r\n * @param obj\r\n * @param prop\r\n * @returns\r\n */\n\nfunction unset(obj, prop) {\n  try {\n    delete obj[prop];\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction assignIfNoKey(obj, key, val) {\n  if (!obj.hasOwnProperty(key)) {\n    obj[key] = val;\n  }\n}\nfunction assignIfKeyNull(obj, key, val) {\n  if (obj[key] == null) {\n    obj[key] = val;\n  }\n}\n/**\r\n * Assign if value different. For assign sensitive, such as Vue.watch.\r\n * @param obj\r\n * @param key\r\n * @param val\r\n */\n\nfunction assignIfDiff(obj, key, val) {\n  if (obj[key] !== val) {\n    obj[key] = val;\n  }\n}\nfunction objectAssignIfNoKey(obj1, obj2) {\n  Object.keys(obj2).forEach(key => {\n    assignIfNoKey(obj1, key, obj2[key]);\n  });\n  return obj1;\n}\nfunction objectAssignIfKeyNull(obj1, obj2) {\n  Object.keys(obj2).forEach(key => {\n    assignIfKeyNull(obj1, key, obj2[key]);\n  });\n  return obj1;\n}\nfunction objectAssignIfDiff(obj1, obj2) {\n  Object.keys(obj2).forEach(key => {\n    assignIfDiff(obj1, key, obj2[key]);\n  });\n  return obj1;\n}\nfunction withoutUndefined(obj) {\n  // @ts-ignore\n  const r = {};\n  Object.keys(obj).forEach(key => {\n    if (obj[key] !== undefined) {\n      r[key] = obj[key];\n    }\n  });\n  return r;\n}\n/**\r\n * proxy a property to another key of this or another object\r\n * @param targetObj\r\n * @param targetKey\r\n * @param sourceObj\r\n * @param sourceKey\r\n */\n\nfunction objectDefineProxyProperty(targetObj, targetKey, sourceObj, sourceKey) {\n  const info = Object.getOwnPropertyDescriptor(sourceObj, sourceKey);\n  Object.defineProperty(targetObj, targetKey, {\n    get() {\n      return sourceObj[sourceKey];\n    },\n\n    set(value) {\n      sourceObj[sourceKey] = value;\n    },\n\n    configurable: true,\n    enumerable: info.enumerable\n  });\n}\n/**\r\n * walk object and change key, value, delete key. return cloned new object.\r\n * 深度遍历对象, 可以改变key, value, 删除key. 返回克隆的新对象.\r\n * @param obj\r\n * @param handler\r\n * return null: don't change anything\r\n * return {delete: true}: delete\r\n * return {key: newKey}: change key\r\n * return {value: newValue}: change value\r\n * return {skip: true}: skip children\r\n * return {stop: true}: stop\r\n * @param limit to prevent circular reference.\r\n * @returns\r\n */\n\nfunction mapObjectTree(obj, handler) {\n  let limit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10000;\n  let r;\n  let count = 0;\n  const stack = [{\n    value: obj\n  }];\n\n  while (stack.length > 0) {\n    if (count >= limit) {\n      throw \"mapObjectTree: limit(\".concat(limit, \") reached, object may has circular reference\");\n    }\n\n    count++; // @ts-ignore\n\n    const {\n      value,\n      key,\n      parent,\n      newParent\n    } = stack.shift();\n    const t = handler(value, key, parent, newParent);\n\n    const assign = (value, key, canPush) => {\n      if (isArray(value)) {\n        value = [];\n      } else if (isObject(value)) {\n        value = {};\n      }\n\n      if (parent) {\n        if (isArray(newParent) && canPush) {\n          newParent.push(value);\n        } else {\n          newParent[key] = value;\n        }\n      } else {\n        r = value;\n      } // value may changed\n\n\n      return value;\n    };\n\n    let newVal, val, toDelete, stop, skip;\n\n    if (!t) {\n      // no change\n      val = value; // @ts-ignore\n\n      newVal = assign(value, key);\n    } else {\n      const {\n        key: key2,\n        value\n      } = t;\n      val = value; // @ts-ignore\n\n      if (t.delete || key2 === false) {\n        // del\n        toDelete = true;\n      } else if (key2 == null) {\n        // don't change key\n        newVal = assign(value, key, true);\n      } else if (t.hasOwnProperty(\"value\")) {\n        // @ts-ignore\n        newVal = assign(value, key2);\n      }\n\n      ({\n        stop,\n        skip\n      } = t);\n    }\n\n    if (toDelete) {\n      continue;\n    }\n\n    if (skip) {\n      continue;\n    }\n\n    if (stop) {\n      break;\n    }\n\n    if (isArray(val)) {\n      const len = val.length;\n\n      for (let i = 0; i < len; i++) {\n        // @ts-ignore\n        stack.push({\n          value: val[i],\n          key: i,\n          parent: val,\n          newParent: newVal\n        });\n      }\n    } else if (isObject(val)) {\n      Object.keys(val).forEach(key => {\n        // @ts-ignore\n        stack.push({\n          value: val[key],\n          key,\n          parent: val,\n          newParent: newVal\n        });\n      });\n    }\n  }\n\n  return r;\n}\n/**\r\n * [{id: 1}, {id: 2}] to {'1':{id: 1}, '2': {id: 2}}\r\n * @param arr\r\n * @param idKey\r\n * @returns\r\n */\n\nfunction mapObjects(arr, idKey) {\n  const r = {};\n  const len = arr.length;\n\n  for (let i = 0; i < len; i++) {\n    const item = arr[i]; // @ts-ignore\n\n    const id = isFunction(idKey) ? idKey(item, i) : item[idKey];\n    r[id] = item;\n  }\n\n  return r;\n}\n/**\r\n * example: pairRows(users, userProfiles, 'id', 'user_id')\r\n * @param rows1\r\n * @param rows2\r\n * @param key1\r\n * @param key2\r\n * @returns [{row1|null, row2|null},...]\r\n */\n\nfunction joinRows(rows1, rows2, key1, key2, ignoreUnmatched) {\n  if (key2 == null) {\n    // @ts-ignore\n    key2 = key1;\n  }\n\n  const m1 = new Map();\n  const m2 = new Map();\n  const r = [];\n  rows2.forEach((row, index) => {\n    // @ts-ignore\n    const key = typeof key2 === \"function\" ? key2(row, index) : row[key2];\n    m2.set(key, row);\n  });\n  const usedRows2 = new Set();\n  rows1.forEach((row, index) => {\n    // @ts-ignore\n    const key = typeof key1 === \"function\" ? key1(row, index) : row[key1];\n    m1.set(key, row);\n    let row2 = m2.has(key) ? m2.get(key) : null;\n\n    if (m2.has(key) || !ignoreUnmatched) {\n      r.push([row, row2]);\n      usedRows2.add(row2);\n    }\n  });\n\n  if (!ignoreUnmatched) {\n    rows2.forEach((row, index) => {\n      // @ts-ignore\n      typeof key2 === \"function\" ? key2(row, index) : row[key2];\n\n      if (!usedRows2.has(row)) {\n        r.push([null, row]);\n      }\n    });\n  }\n\n  return r;\n}\n/**\r\n * walk tree data by with depth first search. tree data example: `[{children: [{}, {}]}]`\r\n * 深度优先遍历树形数据. 树形数据示例: `[{children: [{}, {}]}]`\r\n * @param obj\r\n * @param handler\r\n * @param opt\r\n */\n\nfunction walkTreeData(obj, handler) {\n  let opt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  opt = objectAssignIfNoKey({ ...opt\n  }, {\n    childrenKey: \"children\"\n  });\n  const {\n    childrenKey\n  } = opt;\n  const rootChildren = isArray(obj) ? obj : [obj]; //\n\n  class StopException {}\n\n  const func = (children, parent, parentPath) => {\n    if (opt.reverse) {\n      children = children.slice();\n      children.reverse();\n    }\n\n    const len = children.length;\n\n    for (let i = 0; i < len; i++) {\n      const item = children[i];\n      const index = opt.reverse ? len - i - 1 : i;\n      const path = parentPath ? [...parentPath, index] : [];\n\n      if (opt.childFirst) {\n        if (item[childrenKey] != null) {\n          func(item[childrenKey], item, path);\n        }\n      }\n\n      const r = handler(item, index, parent, path);\n\n      if (r === false) {\n        // stop\n        throw new StopException();\n      } else if (r === \"skip children\") {\n        continue;\n      } else if (r === \"skip siblings\") {\n        break;\n      }\n\n      if (!opt.childFirst) {\n        if (item[childrenKey] != null) {\n          func(item[childrenKey], item, path);\n        }\n      }\n    }\n  };\n\n  try {\n    func(rootChildren, null, isArray(obj) ? [] : null);\n  } catch (e) {\n    if (e instanceof StopException) ; else {\n      throw e;\n    }\n  }\n}\n/**\r\n * like Array.find\r\n * @param obj\r\n * @param handler return true when found.\r\n * @param opt\r\n * @returns\r\n */\n\nfunction findInfoInTreeData(obj, handler) {\n  let opt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let r;\n  walkTreeData(obj, function () {\n    if (handler(...arguments)) {\n      r = {\n        node: arguments.length <= 0 ? undefined : arguments[0],\n        index: arguments.length <= 1 ? undefined : arguments[1],\n        parent: arguments.length <= 2 ? undefined : arguments[2],\n        path: arguments.length <= 3 ? undefined : arguments[3]\n      };\n      return false;\n    }\n  }, opt);\n  return r;\n}\n/**\r\n * like Array.find\r\n * @param obj\r\n * @param handler return true when found.\r\n * @param opt\r\n * @returns\r\n */\n\nfunction findTreeData(obj, handler) {\n  let opt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const r = findInfoInTreeData(obj, handler, opt);\n  return r === null || r === void 0 ? void 0 : r.node;\n}\nfunction cloneTreeData(root, options) {\n  const opt = {\n    childrenKey: \"children\"\n  };\n\n  if (options) {\n    Object.assign(opt, options);\n  }\n\n  const {\n    childrenKey,\n    nodeHandler\n  } = opt;\n  const td = new TreeData();\n  td.childrenKey = childrenKey;\n  walkTreeData(root, (node, index, parent, path) => {\n    let newNode = Object.assign({}, node);\n\n    if (newNode[childrenKey]) {\n      newNode[childrenKey] = [];\n    }\n\n    if (nodeHandler) {\n      newNode = nodeHandler(newNode, {\n        oldNode: node,\n        index,\n        parent,\n        path\n      });\n    }\n\n    td.set(path, newNode);\n  }, {\n    childrenKey\n  });\n  return td.data;\n} // tree data helpers\n\nclass TreeData {\n  // data = null;\n  constructor() {\n    let data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n    _defineProperty(this, \"data\", void 0);\n\n    _defineProperty(this, \"childrenKey\", \"children\");\n\n    this.data = data;\n  }\n\n  get rootChildren() {\n    const {\n      childrenKey\n    } = this;\n    const {\n      data\n    } = this;\n    return isArray(data) ? data : data[childrenKey];\n  }\n\n  *iteratePath(path) {\n    let opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      childrenKey,\n      rootChildren\n    } = this;\n\n    if (!opt.reverse) {\n      let prevPath = [];\n      let prevChildren = rootChildren;\n\n      for (const index of path) {\n        const currentPath = [...prevPath, index];\n        const currentNode = prevChildren[index];\n        yield {\n          path: currentPath,\n          node: currentNode\n        };\n        prevPath = currentPath;\n        prevChildren = currentNode[childrenKey];\n      }\n    } else {\n      const list = [...this.iteratePath(path, { ...opt,\n        reverse: false\n      })];\n      list.reverse();\n\n      for (const {\n        path: path0,\n        node\n      } of list) {\n        const path = path0;\n        yield {\n          path,\n          node\n        };\n      }\n    }\n  }\n\n  getFamily(path) {\n    const all = [];\n\n    for (const {\n      node\n    } of this.iteratePath(path)) {\n      all.push(node);\n    }\n\n    return all;\n  }\n\n  get(path) {\n    return arrayLast(this.getFamily(path));\n  }\n\n  getParentAndIndex(path) {\n    const parentPath = path.slice();\n    const index = parentPath.pop();\n    return {\n      parent: this.get(parentPath),\n      index,\n      parentPath\n    };\n  }\n\n  getParent(path) {\n    return this.getParentAndIndex(path).parent;\n  }\n\n  set(path, node) {\n    if (path == null || path.length === 0) {\n      this.data = node;\n    } else {\n      const {\n        childrenKey\n      } = this;\n      let {\n        rootChildren\n      } = this;\n      const {\n        parent,\n        index\n      } = this.getParentAndIndex(path);\n      let parentChildren;\n\n      if (path.length === 1) {\n        // fix data\n        if (!rootChildren) {\n          if (this.data) {\n            this.data[childrenKey] = [];\n          } else {\n            this.data = [];\n          }\n        }\n\n        parentChildren = rootChildren;\n      } else {\n        if (!parent[childrenKey]) {\n          parent[childrenKey] = [];\n        }\n\n        parentChildren = parent[childrenKey];\n      }\n\n      parentChildren[index] = node;\n    }\n  }\n\n  delete(path) {\n    const {\n      childrenKey,\n      rootChildren\n    } = this;\n    const {\n      parent,\n      index\n    } = this.getParentAndIndex(path);\n    const parentChildren = path.length === 1 ? rootChildren : parent[childrenKey];\n    const node = parentChildren[index];\n    parentChildren.splice(index, 1);\n    return node;\n  }\n\n  walk(handler, opt) {\n    const {\n      childrenKey,\n      data\n    } = this; // @ts-ignore\n\n    return walkTreeData(data, handler, childrenKey, opt);\n  }\n\n  clone() {\n    let opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return cloneTreeData(this.data), withoutUndefined({\n      childrenKey: this.childrenKey,\n      nodeHandler: opt.nodeHandler || undefined\n    });\n  }\n\n} // ## function\n// ## 函数\n\n/**\r\n * if it is function, return result, else return it directly.\r\n * @param valueOrGetter\r\n * @param args\r\n * @returns\r\n */\n\nfunction resolveValueOrGettter(valueOrGetter) {\n  let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n  if (isFunction(valueOrGetter)) {\n    return valueOrGetter(...args);\n  } else {\n    return valueOrGetter;\n  }\n}\n/**\r\n * add executed count as first argument of func\r\n * 增加执行次数作为方法的第一个参数\r\n * @param func\r\n * @returns\r\n */\n\nfunction executeWithCount(func) {\n  let count = 0;\n\n  function wrapper() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    // @ts-ignore\n    return func.call(this, count++, ...args);\n  }\n\n  return wrapper;\n}\n/**\r\n * (getVal, handler) => update . when execute update, call getVal and check if changed.\r\n * (getVal, handler) => update . 执行update时, 调用getVal并检查结果是否改变.\r\n * @param getVal\r\n * @param handler\r\n * @returns\r\n */\n\nfunction watchChange(getVal, handler) {\n  let oldVal;\n\n  const update = function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    // @ts-ignore\n    const newVal = getVal(...args);\n\n    if (oldVal !== newVal) {\n      // @ts-ignore\n      handler(newVal, ...args);\n    }\n\n    oldVal = newVal;\n  };\n\n  return update;\n}\nfunction debounceTrailing(action) {\n  let wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let t;\n  let lastArgs; // when trailing, use last args\n\n  let resolves = [];\n  let rejects = [];\n\n  const wrappedAction = function () {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    return new Promise((resolve, reject) => {\n      resolves.push(resolve);\n      rejects.push(reject); //\n\n      lastArgs = args;\n\n      if (t) {\n        clearTimeout(t);\n      }\n\n      t = setTimeout(() => {\n        // @ts-ignore\n        const result = action.call(this, ...lastArgs);\n        t = null;\n        resolves.forEach(resolve => resolve(result));\n        resolves = [];\n        rejects = [];\n      }, wait);\n    });\n  };\n\n  const stop = () => {\n    if (t) {\n      clearTimeout(t);\n      t = null;\n    }\n\n    resolves = [];\n    rejects.forEach(reject => reject());\n    rejects = [];\n  }; // @ts-ignore\n\n\n  return {\n    action: wrappedAction,\n    stop\n  };\n}\nfunction debounceImmediate(action) {\n  let wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let t;\n  let delaying;\n  let result;\n\n  const wrappedAction = function () {\n    return new Promise((resolve, reject) => {\n      if (delaying) {\n        resolve(result);\n      } else {\n        delaying = true; // @ts-ignore\n\n        result = action.call(this, ...lastArgs);\n        resolve(result);\n        t = setTimeout(() => {\n          t = null;\n          delaying = false;\n          result = null;\n        }, wait);\n      }\n    });\n  };\n\n  const stop = () => {\n    if (t) {\n      clearTimeout(t);\n      t = null;\n    }\n\n    delaying = false;\n  }; // @ts-ignore\n\n\n  return {\n    action: wrappedAction,\n    stop\n  };\n}\n/**\r\n * the returned function only accept one argument\r\n * @param funcs\r\n * @returns\r\n */\n\nfunction joinFunctionsByResult(funcs) {\n  let wrappedFunc = funcs[0];\n\n  for (let i = 1; i < funcs.length; i++) {\n    wrappedFunc = join2func(wrappedFunc, funcs[i]);\n  }\n\n  return wrappedFunc;\n\n  function join2func(func1, func2) {\n    return function (arg) {\n      const result1 = func1(arg);\n      return func2(result1);\n    };\n  }\n}\n/**\r\n * apply finally function to a function, execute it after target return, event it error\r\n * 在目标方法结束或出错后执行另一方法\r\n * @param func\r\n * @param finallyFunc\r\n * @returns\r\n */\n\nfunction applyFinally(func, finallyFunc) {\n  const wrapped = function () {\n    let r, e;\n\n    try {\n      r = func(...arguments);\n    } catch (error) {\n      e = error;\n    } finally {\n      finallyFunc();\n    }\n\n    if (!e) {\n      return r;\n    } else {\n      throw e;\n    }\n  }; // @ts-ignore\n\n\n  return wrapped;\n}\n/**\r\n * must pass arguments to `next` manually\r\n * @param funcs\r\n * @returns\r\n */\n\nfunction joinFunctionsByNext(funcs) {\n  let next = () => {};\n\n  for (const {\n    value: func\n  } of iterateAll(funcs, {\n    reverse: true\n  })) {\n    const currentNext = next;\n    next = wrapFuncWithNext(func, currentNext);\n  }\n\n  return next;\n\n  function wrapFuncWithNext(func, next) {\n    return function () {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n\n      return func(next, ...args);\n    };\n  }\n}\n/**\r\n * wrap function, bind context(this).\r\n * @param action\r\n * @param context\r\n * @returns\r\n */\n\nfunction bindContext(action, context) {\n  const wrapped = function () {\n    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      args[_key5] = arguments[_key5];\n    }\n\n    return action.apply(context, args);\n  }; // @ts-ignore\n\n\n  return wrapped;\n}\n/**\r\n * Cache function return by arguments\r\n * @param func\r\n * @returns\r\n */\n\nfunction cacheFunction(func) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const cachedArgsArr = [];\n  let map;\n  const defaultValue = {};\n  let noArgsCache = defaultValue;\n\n  const wrapped = function () {\n    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      args[_key6] = arguments[_key6];\n    }\n\n    if (args.length === 0) {\n      if (noArgsCache === defaultValue) {\n        noArgsCache = func();\n      }\n\n      return noArgsCache;\n    }\n\n    if (!map) {\n      map = new ArrayKeyMap();\n    }\n\n    if (!map.has(args)) {\n      map.set(args, func(...args));\n\n      if (options.capacity != null) {\n        cachedArgsArr.push(args);\n        const removed = cachedArgsArr.splice(0, cachedArgsArr.length - options.capacity);\n\n        for (const args of removed) {\n          map.delete(args);\n        }\n      }\n    }\n\n    return map.get(args);\n  };\n\n  const clearCache = () => {\n    map = null;\n    cachedArgsArr.splice(0, cachedArgsArr.length);\n  };\n\n  return {\n    // @ts-ignore\n    action: wrapped,\n    clearCache\n  };\n} // ## promise\n\n/**\r\n * execute promise in sequence\r\n * @param getters\r\n * @param concurrent\r\n * @returns\r\n */\n\nfunction executePromiseGetters(getters) {\n  let concurrent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  let stopped;\n  const promise = new Promise(async function (resolve, reject) {\n    const chunks = splitArray(getters, concurrent);\n    const promises = [];\n\n    for (const chunk of chunks) {\n      const chunkPromises = chunk.map(v => v());\n      promises.push(...chunkPromises);\n      await Promise.all(chunkPromises);\n\n      if (stopped) {\n        break;\n      }\n    }\n\n    Promise.all(promises).then(function () {\n      resolve(...arguments);\n    });\n  });\n  return {\n    promise,\n\n    stop() {\n      stopped = true;\n    }\n\n  };\n}\nfunction promiseTimeout(promise, timeout) {\n  return new Promise((resolve, reject) => {\n    let t, rejected;\n    promise.then(function () {\n      clearTimeout(t);\n      resolve(...arguments);\n    }, function () {\n      if (!rejected) {\n        clearTimeout(t);\n        reject(...arguments);\n      }\n    });\n    t = setTimeout(() => {\n      rejected = true;\n      const e = new Error(\"Promise timeout!\");\n      e.name = \"timeout\";\n      reject(e);\n    }, timeout);\n  });\n}\nfunction promisePin() {\n  let resolve, reject;\n  const promise = new Promise((resolve2, reject2) => {\n    resolve = resolve2;\n    reject = reject2;\n  });\n  return {\n    promise,\n    resolve,\n    reject\n  };\n}\n/**\r\n * warp continuous Promise method, such as mousemove handler\r\n * @param method\r\n * @param opt. strategy 'last': the wrapped method return empty if skipped\r\n */\n\nfunction continuous(method, opt) {\n  // default options\n  if (!opt) {\n    // @ts-ignore\n    opt = {};\n  }\n\n  objectAssignIfNoKey(opt, {\n    strategy: \"every\"\n  });\n  const queue = [];\n  let working = false;\n  const currentCount = {\n    value: 0\n  };\n  return async function () {\n    currentCount.value++;\n    const count = currentCount.value;\n    const done = promisePin();\n\n    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      args[_key7] = arguments[_key7];\n    }\n\n    queue.push({\n      count,\n      args,\n      done\n    });\n\n    if (!working) {\n      working = true;\n      task();\n    }\n\n    return done.promise;\n  };\n\n  async function task() {\n    if (opt.strategy === \"every\") {\n      while (queue.length > 0) {\n        const {\n          count,\n          args,\n          done\n        } = queue.shift();\n        let r = method({\n          count,\n          currentCount\n        }, ...args);\n\n        try {\n          await r;\n        } catch (error) {} finally {\n          done.resolve(r);\n        }\n      }\n    } else if (opt.strategy === \"last\") {\n      let currentIndex = -1;\n\n      while (queue.length > 0 && (currentIndex === -1 || queue.length - 1 > currentIndex)) {\n        currentIndex = queue.length - 1;\n        const item = queue[currentIndex];\n        const {\n          count,\n          args,\n          done\n        } = item;\n        let r = method({\n          count,\n          currentCount\n        }, ...args);\n\n        try {\n          await r;\n        } catch (error) {} finally {\n          done.resolve(r);\n          item.skipped = false;\n        }\n      }\n\n      for (let index = currentIndex - 1; index >= 0; index--) {\n        const item = queue[index]; // skip before last\n\n        if (!item || item.skipped != null) {\n          continue;\n        } else {\n          item.skipped = true; // @ts-ignore\n\n          item.done.resolve();\n        }\n      }\n\n      queue.splice(0, queue.length);\n    }\n\n    if (opt.resetCount) {\n      currentCount.value = 0;\n    }\n\n    working = false;\n  }\n}\nconst promiseContinuous = continuous; // ## url\n\nfunction getUrlParam(par) {\n  // 获取当前URL\n  var local_url = document.location.href; // 获取要取得的get参数位置\n\n  var get = local_url.indexOf(par + \"=\");\n\n  if (get == -1) {\n    return false;\n  } // 截取字符串\n\n\n  var get_par = local_url.slice(par.length + get + 1); // 判断截取后的字符串是否还有其他get参数\n\n  var nextPar = get_par.indexOf(\"&\");\n\n  if (nextPar != -1) {\n    get_par = get_par.slice(0, nextPar);\n  }\n\n  return get_par;\n}\nfunction pathJoin(p1, p2) {\n  if (!p2) {\n    return p1;\n  }\n\n  if (!p1 || p2.match(/^\\w+:/)) {\n    return p2;\n  }\n\n  if (p1 && !p1.endsWith(\"/\")) {\n    p1 = p1 + \"/\";\n  }\n\n  if (p1 && p2.startsWith(\"/\")) {\n    p2 = p2.substring(1);\n  }\n\n  return p1 + p2;\n} // ## dom\n\n/**\r\n * return NodeList if there are multiple top-level nodes\r\n * @param htmlString\r\n * @returns\r\n */\n\nfunction createElementFromHTML(htmlString) {\n  var div = document.createElement(\"div\");\n  div.innerHTML = htmlString.trim();\n\n  if (div.childNodes.length > 1) {\n    return div.childNodes;\n  } else {\n    return div.childNodes[0];\n  }\n}\n/**\r\n * NOT RECOMMEND. Use Node.contains instead.\r\n */\n\nfunction isDescendantOf(el, parent) {\n  while (true) {\n    if (el.parentNode == null) {\n      return false;\n    } else if (el.parentNode === parent) {\n      return true;\n    } else {\n      el = el.parentNode;\n    }\n  }\n}\nfunction pointIn(x, y, element) {\n  const rect = getBoundingClientRect(element);\n  return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;\n}\nfunction removeEl(el) {\n  if (el.parentNode !== null) {\n    return el.parentNode.removeChild(el);\n  }\n}\n/**\r\n * get page root scroll(body or documentElement). refer: https://stackoverflow.com/questions/871399/cross-browser-method-for-detecting-the-scrolltop-of-the-browser-window\r\n * @returns\r\n */\n\nfunction getScroll() {\n  if (typeof pageYOffset != \"undefined\") {\n    //most browsers except IE before #9\n    return {\n      top: pageYOffset,\n      left: pageXOffset\n    };\n  } else {\n    var B = document.body; //IE 'quirks'\n\n    var D = document.documentElement; //IE with doctype\n\n    D = D.clientHeight ? D : B;\n    return {\n      top: D.scrollTop,\n      left: D.scrollLeft\n    };\n  }\n}\n/**\r\n * relative to page root element(document.documentElement). refer: https://gist.github.com/aderaaij/89547e34617b95ac29d1\r\n * 相对于页面根元素.(document.documentElement)\r\n * @param el\r\n * @returns\r\n */\n\nfunction getOffset(el) {\n  const rect = getBoundingClientRect(el);\n  const t = getBoundingClientRect(document.documentElement);\n  return {\n    x: rect.left - t.left,\n    y: rect.top - t.top\n  };\n}\n/**\r\n * there is some trap in el.offsetParent, so use this func to fix\r\n * @param el\r\n * @returns\r\n */\n\nfunction getOffsetParent(el) {\n  let offsetParent = el.offsetParent;\n\n  if (!offsetParent || offsetParent === document.body && getComputedStyle(document.body).position === \"static\") {\n    offsetParent = document.body.parentElement;\n  }\n\n  return offsetParent;\n}\n/**\r\n * get el current position. like jQuery.position. The position is relative to offsetParent viewport left top. it is for set absolute position, absolute position is relative to offsetParent viewport left top.\r\n * 相对于offsetParent可视区域左上角(el.offsetLeft或top包含父元素的滚动距离, 所以要减去). position一般用于设置绝对定位的情况, 而绝对定位就是以可视区域左上角为原点.\r\n * @param el\r\n * @returns\r\n */\n\nfunction getPosition(el) {\n  const offsetParent = getOffsetParent(el);\n  const ps = {\n    x: el.offsetLeft,\n    y: el.offsetTop\n  };\n  let parent = el;\n\n  while (true) {\n    parent = parent.parentElement;\n\n    if (parent === offsetParent || !parent) {\n      break;\n    }\n\n    ps.x -= parent.scrollLeft;\n    ps.y -= parent.scrollTop;\n  }\n\n  return ps;\n}\n/**\r\n * like jQuery.offset(x, y), but it just return cmputed position, don't update style\r\n * 类似 jQuery.offset的设置功能, 但是它只返回计算的position, 不改变元素样式.\r\n * @param el\r\n * @param of\r\n * @returns\r\n */\n\nfunction getPositionFromOffset(el, of) {\n  const offsetParent = getOffsetParent(el);\n  const parentOf = getOffset(offsetParent);\n  return {\n    x: of.x - parentOf.x,\n    y: of.y - parentOf.y\n  };\n}\n/**\r\n * relative to viewport. like position fixed. alias getViewportPosition\r\n * 相对于视口. 类似 position fixed. 别名 getViewportPosition\r\n * @param el\r\n * @returns\r\n */\n\nfunction getBoundingClientRect(el) {\n  // refer: http://www.51xuediannao.com/javascript/getBoundingClientRect.html\n  let xy = el.getBoundingClientRect();\n\n  if (document.documentElement.clientTop > 0) {\n    const top = xy.top - document.documentElement.clientTop,\n          //document.documentElement.clientTop 在IE67中始终为2，其他高级点的浏览器为0\n    bottom = xy.bottom,\n          left = xy.left - document.documentElement.clientLeft,\n          //document.documentElement.clientLeft 在IE67中始终为2，其他高级点的浏览器为0\n    right = xy.right,\n          width = xy.width || right - left,\n          //IE67不存在width 使用right - left获得\n    height = xy.height || bottom - top;\n    const x = left;\n    const y = top;\n    const json = {\n      top,\n      right,\n      bottom,\n      left,\n      width,\n      height,\n      x,\n      y\n    };\n    xy = { ...json,\n      toJSON: () => json\n    };\n  }\n\n  return xy;\n} // refer [getBoundingClientRect](#getBoundingClientRect)\n\nconst getViewportPosition = getBoundingClientRect;\n/**\r\n * position fixed is not always related to viewport.\r\n * position fixed不总是相对于视口.\r\n * 参考/Check: https://developer.mozilla.org/en-US/docs/Web/CSS/position\r\n * @param el\r\n * @param viewportPosition\r\n */\n\nfunction viewportPositionToFixed(el, viewportPosition) {\n  const div = document.createElement(\"div\");\n  Object.assign(div.style, {\n    position: \"fixed\",\n    visibility: \"hidden\",\n    top: \"0px\",\n    left: \"0px\"\n  });\n  insertAfter(div, el);\n  const divVP = getViewportPosition(div);\n  const offset = {\n    x: 0 - divVP.x,\n    y: 0 - divVP.y\n  };\n  return {\n    x: viewportPosition.x + offset.x,\n    y: viewportPosition.x + offset.y\n  };\n}\nfunction findParent(el, callback) {\n  let opt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let cur = opt && opt.withSelf ? el : el.parentElement;\n\n  while (cur) {\n    const shouldBreak = opt.until && cur === opt.until;\n\n    if (shouldBreak && !opt.withUntil) {\n      return;\n    }\n\n    const r = callback(cur);\n\n    if (r === \"break\") {\n      return;\n    } else if (r) {\n      return cur;\n    } else if (shouldBreak) {\n      return;\n    } else {\n      cur = cur.parentElement;\n    }\n  }\n}\nfunction backupAttr(el, name) {\n  const key = \"original_\".concat(name);\n  el[key] = el.getAttribute(name);\n}\nfunction restoreAttr(el, name) {\n  const key = \"original_\".concat(name);\n  const value = el[key];\n\n  if (value == null) {\n    el.removeAttribute(name);\n  } else {\n    el.setAttribute(name, value);\n  }\n} // source: http://youmightnotneedjquery.com/\n\nfunction hasClass(el, className) {\n  if (el.classList) {\n    return el.classList.contains(className);\n  } else {\n    return new RegExp(\"(^| )\" + className + \"( |$)\", \"gi\").test(el.className);\n  }\n}\n/**\r\n * has all classNames\r\n * @param el\r\n * @param classNames\r\n */\n\nfunction hasClasses(el, classNames) {\n  for (const className of classNames) {\n    if (!hasClass(el, className)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\r\n * has any class in classNames\r\n * @param el\r\n * @param classNames\r\n * @returns\r\n */\n\nfunction hasClassIn(el, classNames) {\n  for (const className of classNames) {\n    if (hasClass(el, className)) {\n      return true;\n    }\n  }\n\n  return false;\n} // source: http://youmightnotneedjquery.com/\n\nfunction addClass(el, className) {\n  const t = toArrayIfNot(className);\n\n  for (const className of t) {\n    if (!hasClass(el, className)) {\n      if (el.classList) {\n        el.classList.add(className);\n      } else {\n        el.className += \" \" + className;\n      }\n    }\n  }\n} // source: http://youmightnotneedjquery.com/\n\nfunction removeClass(el, className) {\n  const t = toArrayIfNot(className);\n\n  for (const className of t) {\n    if (el.classList) {\n      el.classList.remove(className);\n    } else {\n      el.className = el.className.replace(new RegExp(\"(^|\\\\b)\" + className.split(\" \").join(\"|\") + \"(\\\\b|$)\", \"gi\"), \" \");\n    }\n  }\n}\nfunction getElSizeEvenInvisible(el) {\n  backupAttr(el, \"style\");\n  el.style.display = \"block\";\n  const t = getBoundingClientRect(el);\n  const size = {\n    width: t.width,\n    height: t.height\n  };\n  restoreAttr(el, \"style\");\n  return size;\n}\n/**\r\n * [isOffsetInEl]\r\n * @param {Number} x\r\n * @param {Number} y\r\n * @param {Object} el HTML Element\r\n */\n\nfunction isOffsetInEl(x, y, el) {\n  const offset = getOffset(el);\n  return offset.x <= x && offset.x + el.offsetWidth >= x && offset.y <= y && offset.y + el.offsetHeight >= y;\n}\nfunction setElChildByIndex(el, child, index) {\n  // @ts-ignore\n  child.childComponentIndex = index;\n  const len = el.childNodes.length;\n\n  if (len === 0) {\n    el.appendChild(child);\n  } else if (index === 0) {\n    el.insertBefore(child, el.childNodes[0]);\n  } else {\n    const {\n      index: nearestIndex,\n      value: nearest,\n      greater\n    } = binarySearch( // @ts-ignore\n    el.childNodes, el => {\n      return el[\"childComponentIndex\"] - index;\n    }, {\n      start: 0,\n      end: notGreaterThan(index, len - 1),\n      returnNearestIfNoHit: true\n    });\n\n    if (greater) {\n      // @ts-ignore\n      el.insertBefore(child, nearest);\n    } else {\n      const next = el.childNodes[nearestIndex + 1];\n\n      if (next) {\n        el.insertBefore(child, next);\n      } else {\n        el.appendChild(child);\n      }\n    }\n  }\n}\n/**\r\n * listen event on element\r\n * @param el\r\n * @param name\r\n * @param handler\r\n * @param options\r\n */\n\nfunction on(el, name, handler, options) {\n  if (el.addEventListener) {\n    // 所有主流浏览器，除了 IE 8 及更早 IE版本\n    el.addEventListener(name, handler, options); // @ts-ignore\n  } else if (el.attachEvent) {\n    // IE 8 及更早 IE 版本\n    // @ts-ignore\n    el.attachEvent(\"on\".concat(name), handler, options);\n  }\n}\n/**\r\n * cancel event lisitener on element\r\n * @param el\r\n * @param name\r\n * @param handler\r\n * @param options\r\n */\n\nfunction off(el, name, handler, options) {\n  if (el.removeEventListener) {\n    // 所有主流浏览器，除了 IE 8 及更早 IE版本\n    el.removeEventListener(name, handler, options); // @ts-ignore\n  } else if (el.detachEvent) {\n    // IE 8 及更早 IE 版本\n    // @ts-ignore\n    el.detachEvent(\"on\".concat(name), handler, options);\n  }\n}\n/**\r\n * listen event on element once. return destroy function\r\n * @param el\r\n * @param name\r\n * @param handler\r\n * @param options\r\n * @returns destroy\r\n */\n\nfunction once(el, name, handler, options) {\n  const onceHandler = function () {\n    for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n      args[_key8] = arguments[_key8];\n    }\n\n    // @ts-ignore\n    let r = handler.call(this, ...args); // prettier-ignore\n\n    destroy();\n    return r;\n  };\n\n  on(el, name, onceHandler, options);\n  let destroied = false;\n\n  const destroy = () => {\n    if (!destroied) {\n      off(el, name, onceHandler, options);\n    }\n\n    destroied = true;\n  };\n\n  return destroy;\n}\n/**\r\n * lisiten multi events, and can stop and resume them\r\n * @param info\r\n * @returns\r\n */\n\nfunction extendedListen(info) {\n  let destroyFuncs = [];\n\n  const listenAll = () => {\n    if (r.listening) {\n      return;\n    }\n\n    for (const item of info) {\n      on.apply(this, item);\n\n      const destroy = () => off.apply(this, item);\n\n      destroyFuncs.push(destroy);\n    }\n\n    r.listening = true;\n  };\n\n  const destroyAll = () => {\n    if (!r.listening) {\n      return;\n    }\n\n    for (const destroy of destroyFuncs) {\n      destroy();\n    }\n\n    destroyFuncs = [];\n    r.listening = false;\n  };\n\n  const r = {\n    listening: false,\n    stop: destroyAll,\n    resume: listenAll\n  };\n  return r;\n}\nfunction getImageSizeByUrl(url) {\n  const image = document.createElement(\"img\");\n  return new Promise(function (resolve, reject) {\n    on(image, \"load\", () => {\n      resolve({\n        width: image.width,\n        height: image.height\n      });\n    });\n    on(image, \"error\", e => {\n      reject(e);\n    });\n    image.src = url;\n  });\n}\nfunction elementsFromPoint(x, y) {\n  const args = [x, y];\n  const func = document.elementsFromPoint || // @ts-ignore\n  document.msElementsFromPoint || elementsFromPoint;\n  return func.apply(document, args);\n\n  function elementsFromPoint(x, y) {\n    const parents = [];\n    let parent = void 0;\n\n    do {\n      if (parent !== document.elementFromPoint(x, y)) {\n        parent = document.elementFromPoint(x, y);\n        parents.push(parent);\n        parent.style.pointerEvents = \"none\";\n        parent[\"_pointerEvents_backup\"] = parent.style.pointerEvents;\n      } else {\n        parent = false;\n      }\n    } while (parent);\n\n    parents.forEach(function (parent) {\n      return parent.style.pointerEvents = parent[\"_pointerEvents_backup\"];\n    });\n    return parents;\n  }\n}\nfunction getOuterAttachedHeight(el) {\n  let opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  opt = {\n    margin: true,\n    border: true,\n    ...opt\n  };\n  const stl = getComputedStyle(el);\n  let r = 0;\n  const arr = [];\n\n  if (opt.margin) {\n    arr.push(\"margin-top\", \"margin-bottom\");\n  }\n\n  if (opt.border) {\n    arr.push(\"border-top-width\", \"border-bottom-width\");\n  }\n\n  arr.forEach(key => {\n    r += parseFloat(stl[key]);\n  });\n  return r;\n}\nfunction getOuterAttachedWidth(el) {\n  let opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  opt = {\n    margin: true,\n    border: true,\n    ...opt\n  };\n  const stl = getComputedStyle(el);\n  let r = 0;\n  const arr = [];\n\n  if (opt.margin) {\n    arr.push(\"margin-left\", \"margin-right\");\n  }\n\n  if (opt.border) {\n    arr.push(\"border-left-width\", \"border-right-width\");\n  }\n\n  arr.forEach(key => {\n    r += parseFloat(stl[key]);\n  });\n  return r;\n}\n/**\r\n * like jquery $(el).css(), but only can read\r\n * @param el\r\n * @param name\r\n * @returns\r\n */\n\nfunction css(el, name) {\n  const stl = getComputedStyle(el);\n  return stl[name];\n}\nfunction cssNumber(el, name) {\n  return parseFloat(css(el, name));\n}\nfunction isScrollable(el, direction) {\n  const key = \"overflow\" + direction.toUpperCase();\n  const values = [\"auto\", \"scroll\", \"overlay\"];\n\n  if (el === document.scrollingElement) {\n    values.push(\"visible\");\n  }\n\n  return values.includes(css(el, key));\n}\n/**\r\n * scrollLeft, scrollRight, scrollTop, scrollBottom.\r\n * IMPORTANT! The min value of  scrollRight and scrollBottom may be a float less than 1, not zero.\r\n * 重要! scrollRight和scrollBottom的最小值可能是小于1的小数, 而不是0.\r\n * @param el\r\n * @param direction\r\n * @returns\r\n */\n\nfunction getScrollSpace(el, direction) {\n  let space;\n\n  if (direction === \"left\") {\n    space = el.scrollLeft;\n  } else if (direction === \"top\") {\n    space = el.scrollTop;\n  } else {\n    if (direction === \"right\") {\n      space = el.scrollWidth - el.clientWidth - el.scrollLeft;\n    } else {\n      // bottom\n      space = el.scrollHeight - el.clientHeight - el.scrollTop;\n    }\n  }\n\n  return space;\n}\n/* scroll to a positon with duration\r\nfrom https://gist.github.com/andjosh/6764939\r\ninterface options{\r\n  x: number // nullable. don't scroll horizontally when null\r\n  y: number // nullable. don't scroll vertically when null\r\n  duration: number // default 0\r\n  element: Node // default is the top scrollable element.\r\n  beforeEveryFrame: (count: number) => boolean|void // call before requestAnimationFrame execution. return false to stop\r\n}\r\nreturn stop\r\n*/\n\nfunction scrollTo(options) {\n  if (!options.element) {\n    options.element = document.scrollingElement || document.documentElement;\n  }\n\n  if (options.duration == null) {\n    options.duration = 0;\n  }\n\n  const {\n    x,\n    y,\n    duration,\n    element\n  } = options;\n  let requestAnimationFrameId;\n  let count = 0;\n\n  const startY = element.scrollTop,\n        changeY = y - startY,\n        startX = element.scrollLeft,\n        changeX = x - startX,\n        startDate = +new Date(),\n        animateScroll = function () {\n    if (options.beforeEveryFrame && options.beforeEveryFrame(count) === false) {\n      return;\n    }\n\n    const currentDate = new Date().getTime();\n    const changedTime = currentDate - startDate;\n\n    if (y != null) {\n      element.scrollTop = parseInt(calc(startY, changeY, changedTime, duration));\n    }\n\n    if (x != null) {\n      element.scrollLeft = parseInt(calc(startX, changeX, changedTime, duration));\n    }\n\n    if (changedTime < duration) {\n      requestAnimationFrameId = requestAnimationFrame(animateScroll);\n    } else {\n      if (y != null) {\n        element.scrollTop = y;\n      }\n\n      if (x != null) {\n        element.scrollLeft = x;\n      }\n    }\n\n    count++;\n  };\n\n  const stop = () => {\n    cancelAnimationFrame(requestAnimationFrameId);\n  };\n\n  animateScroll(); // return stop\n\n  return stop;\n\n  function calc(startValue, changeInValue, changedTime, duration) {\n    return startValue + changeInValue * (changedTime / duration);\n  }\n} // ### DOM structure\n\nfunction insertBefore(el, target) {\n  target.parentElement.insertBefore(el, target);\n}\nfunction insertAfter(el, target) {\n  target.parentElement.insertBefore(el, target.nextSibling);\n}\nfunction prependTo(el, target) {\n  target.insertBefore(el, target.firstChild);\n}\nfunction appendTo(el, target) {\n  target.appendChild(el);\n} // ## Date\n\nfunction cloneDate(dateObj) {\n  return new Date(dateObj.getTime());\n} // day and date is same\n\nfunction addDate(dateObj, n, type) {\n  if (![\"year\", \"month\", \"day\", \"date\"].includes(type)) {\n    type += \"s\";\n  }\n\n  let type2 = studlyCase(type);\n\n  if (type2 === \"Day\") {\n    type2 = \"Date\";\n  }\n\n  var setFuncName = \"set\" + type2;\n  var getFuncName = \"get\" + type2;\n  dateObj[setFuncName](dateObj[getFuncName]() + n);\n  return dateObj;\n}\nfunction getMonthStart(dateObj) {\n  const clonedObj = cloneDate(dateObj);\n  clonedObj.setDate(1);\n  return clonedObj;\n}\nfunction getMonthEnd(dateObj) {\n  const r = cloneDate(dateObj);\n  addDate(r, 1, \"month\");\n  r.setDate(0);\n  return r;\n}\n/**\r\n * startWeekDay: 0 is Sunday\r\n * @param year\r\n * @param month\r\n * @param startWeekDay\r\n * @returns [GetCalendarDay x 7][]\r\n */\n\nfunction getCalendar(year, month) {\n  let startWeekDay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  const results = [];\n  const date = new Date(year, month - 1);\n  year = date.getFullYear();\n  month = date.getMonth() + 1;\n  const monthStart = getMonthStart(date);\n  const monthStartDay = monthStart.getDay();\n  const calendarStart = addDate(cloneDate(monthStart), -(monthStartDay + startWeekDay), \"day\");\n\n  if (monthStartDay > startWeekDay) {\n    const startDate = calendarStart.getDate();\n    const year = calendarStart.getFullYear();\n    const month = calendarStart.getMonth() + 1;\n\n    for (let i = startWeekDay; i < monthStartDay; i++) {\n      const date = startDate + i;\n      results.push({\n        year,\n        month,\n        date: date,\n        text: date,\n        prevMonth: true\n      });\n    }\n  } //\n\n\n  const monthEnd = getMonthEnd(date);\n  const monthEndtDate = monthEnd.getDate();\n\n  for (let i = 1; i <= monthEndtDate; i++) {\n    const date = i;\n    results.push({\n      year: year,\n      month: month,\n      date,\n      text: date,\n      currentMonth: true\n    });\n  } //\n\n\n  const monthEndDay = monthEnd.getDay();\n  const endWeekDay = 6 - startWeekDay;\n\n  if (monthEndDay < endWeekDay) {\n    const nextMonth = addDate(cloneDate(date), 1, \"month\");\n    const year = nextMonth.getFullYear();\n    const month = nextMonth.getMonth() + 1;\n\n    for (let i = monthEndDay + 1, date = 1; i <= endWeekDay; i++, date++) {\n      results.push({\n        year: year,\n        month: month,\n        date: date,\n        text: date,\n        nextMonth: true\n      });\n    }\n  } //\n\n\n  return splitArray(results, 7);\n}\n/**\r\n * timezone must be UTC. eg: 2018-09-07T03:38:37.888Z\r\n * @param str\r\n * @returns\r\n */\n\nfunction isIsoFormat(str) {\n  return Boolean(str.length > 15 && str.length < 30 && str.match(/^\\d{4}-\\d{2}-\\d{2}T.*Z$/));\n}\n/**\r\n *\r\n * @param timestamp eg: 2018-09-07T03:38:37.888Z\r\n * @returns\r\n */\n\nfunction parseISO(timestamp) {\n  const [datePart, timePart] = timestamp.split(\"T\");\n  let y,\n      m,\n      d,\n      h = 0,\n      min = 0,\n      s = 0;\n  [y, m, d] = datePart.split(\"-\").map(v => parseInt(v));\n  m = m - 1;\n\n  if (timePart) {\n    const t = timePart.split(\":\").map(v => parseFloat(v));\n    h = t[0];\n\n    if (t[1] != null) {\n      min = t[1];\n    }\n\n    if (t[2] != null) {\n      s = t[2];\n    }\n  }\n\n  const dt = new Date();\n  dt.setUTCFullYear(y);\n  dt.setUTCMonth(m);\n  dt.setUTCDate(d);\n  dt.setUTCHours(h);\n  dt.setUTCMinutes(min);\n  dt.setUTCSeconds(s);\n  return dt;\n}\n/**\r\n * binarySearch, 二分查找\r\n * @param arr\r\n * @param callback return `mid - your_value` for ascending array\r\n * @param opt\r\n * @returns\r\n */\n\nfunction binarySearch(arr, callback) {\n  let opt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  opt = {\n    start: 0,\n    end: arr.length - 1,\n    maxTimes: 1000,\n    ...opt\n  };\n  let {\n    start,\n    end\n  } = opt;\n  const {\n    returnNearestIfNoHit,\n    maxTimes\n  } = opt;\n  let midNum;\n  let mid;\n\n  if (start == null) {\n    start = 0;\n    end = arr.length - 1;\n  }\n\n  let i = 0;\n  let r;\n\n  while (start >= 0 && start <= end) {\n    if (i >= maxTimes) {\n      throw Error(\"binarySearch: loop times is over \".concat(maxTimes, \", you can increase the limit.\"));\n    }\n\n    midNum = Math.floor((end - start) / 2 + start);\n    mid = arr[midNum];\n    const count = i + 1;\n    r = callback(mid, midNum, count);\n\n    if (r > 0) {\n      end = midNum - 1;\n    } else if (r < 0) {\n      start = midNum + 1;\n    } else {\n      return {\n        index: midNum,\n        value: mid,\n        count,\n        hit: true\n      };\n    }\n\n    i++;\n  }\n\n  return returnNearestIfNoHit ? {\n    index: midNum,\n    value: mid,\n    count: i + 1,\n    hit: false,\n    greater: r > 0\n  } : null;\n} //\n\nfunction windowLoaded() {\n  return new Promise(function (resolve, reject) {\n    if (document && document.readyState === \"complete\") {\n      resolve();\n    } else {\n      window.addEventListener(\"load\", function once() {\n        resolve();\n        window.removeEventListener(\"load\", once);\n      });\n    }\n  });\n}\nfunction waitTime(milliseconds, callback) {\n  return new Promise(function (resolve, reject) {\n    setTimeout(function () {\n      callback && callback();\n      resolve();\n    }, milliseconds);\n  });\n}\nfunction waitFor(condition) {\n  let time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n  let maxTimes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1000;\n  let interval;\n  const promise = new Promise(function (resolve, reject) {\n    let count = 0;\n\n    function judge() {\n      if (count <= maxTimes) {\n        if (condition()) {\n          stop();\n          resolve();\n        }\n      } else {\n        stop();\n        reject(new Error(\"waitFor: Limit is reached\"));\n      }\n\n      count++;\n    }\n\n    interval = setInterval(function () {\n      judge();\n    }, time);\n    judge();\n  });\n  return {\n    promise,\n    stop\n  };\n\n  function stop() {\n    clearInterval(interval);\n  }\n}\nasync function retry(action) {\n  let limitTimes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;\n\n  for (let index = 1; index <= limitTimes; index++) {\n    try {\n      // @ts-ignore\n      return await action();\n    } catch (error) {\n      if (index === limitTimes) {\n        throw error;\n      }\n    }\n  }\n}\n/**\r\n * Copy to text to clipboard. Async not supported. Recommend clipboard-polyfill.\r\n * 复制文字到剪贴板. 仅限于简单使用, 不支持异步. 复杂环境推荐clipboard-polyfill\r\n * @param text\r\n * @returns\r\n */\n\nfunction copyTextToClipboard(text) {\n  try {\n    // use latest api\n    navigator.clipboard.writeText(text);\n    return;\n  } catch (e) {}\n\n  var textArea = document.createElement(\"textarea\"); //\n  // *** This styling is an extra step which is likely not required. ***\n  //\n  // Why is it here? To ensure:\n  // 1. the element is able to have focus and selection.\n  // 2. if element was to flash render it has minimal visual impact.\n  // 3. less flakyness with selection and copying which **might** occur if\n  //    the textarea element is not visible.\n  //\n  // The likelihood is the element won't even render, not even a flash,\n  // so some of these are just precautions. However in IE the element\n  // is visible whilst the popup box asking the user for permission for\n  // the web page to copy to the clipboard.\n  //\n  // Place in top-left corner of screen regardless of scroll position.\n\n  textArea.style.position = \"fixed\";\n  textArea.style.top = \"0\";\n  textArea.style.left = \"0\"; // Ensure it has a small width and height. Setting to 1px / 1em\n  // doesn't work as this gives a negative w/h on some browsers.\n\n  textArea.style.width = \"2em\";\n  textArea.style.height = \"2em\"; // We don't need padding, reducing the size if it does flash render.\n\n  textArea.style.padding = \"0\"; // Clean up any borders.\n\n  textArea.style.border = \"none\";\n  textArea.style.outline = \"none\";\n  textArea.style.boxShadow = \"none\"; // Avoid flash of white box if rendered for any reason.\n\n  textArea.style.background = \"transparent\";\n  textArea.value = text;\n  document.body.appendChild(textArea);\n  textArea.select();\n\n  try {\n    var successful = document.execCommand(\"copy\");\n    var msg = successful ? \"successful\" : \"unsuccessful\";\n    console.log(\"Copying text command was \" + msg);\n  } catch (err) {\n    console.log(\"Oops, unable to copy\");\n  }\n\n  document.body.removeChild(textArea);\n}\nfunction isWindowDefined() {\n  try {\n    return window && true;\n  } catch (error) {\n    return false;\n  }\n}\nfunction isNode() {\n  // @ts-ignore\n  return Boolean(typeof glb().module !== \"undefined\" && glb().module.exports);\n}\nfunction isIE() {\n  // @ts-ignore\n  return Boolean(window.ActiveXObject || \"ActiveXObject\" in window);\n}\n/*\r\nhttps://developer.mozilla.org/docs/Web/API/Window/open\r\nhttp://www.w3school.com.cn/htmldom/met_win_open.asp#windowfeatures\r\n*/\n\nfunction openWindow(url, name) {\n  let opt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  window.open(url, name, Object.keys(opt).map(k => \"\".concat(k, \"=\").concat(opt[k])).join(\",\"));\n}\nfunction openCenterWindow(url, name, width, height) {\n  let opt = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  const t = {\n    width,\n    height,\n    top: (window.screen.availHeight - 30 - height) / 2,\n    left: (window.screen.availWidth - 30 - width) / 2\n  };\n  Object.assign(t, opt);\n  openWindow(url, name, t);\n}\nfunction openPreviewWindow(previewUrl) {\n  let name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"preview\";\n  let width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1000;\n  let height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 800;\n  return openCenterWindow(previewUrl, name, width, height, {\n    directories: \"no\",\n    titlebar: \"no\",\n    toolbar: \"no\",\n    location: \"no\",\n    status: \"no\",\n    menubar: \"no\"\n  });\n}\nclass URLHelper {\n  // protocol, hostname, port, pastname\n  constructor(baseUrl) {\n    _defineProperty(this, \"baseUrl\", \"\");\n\n    _defineProperty(this, \"search\", {});\n\n    let t = decodeURI(baseUrl).split(\"?\");\n    this.baseUrl = t[0];\n\n    if (t[1]) {\n      t[1].split(\"&\").forEach(v => {\n        let t2 = v.split(\"=\");\n        this.search[t2[0]] = t2[1] == null ? \"\" : decodeURIComponent(t2[1]);\n      });\n    }\n  }\n\n  getHref() {\n    const t = [this.baseUrl];\n    let searchStr = Object.keys(this.search).map(k => \"\".concat(k, \"=\").concat(encodeURIComponent(this.search[k]))).join(\"&\");\n\n    if (searchStr) {\n      t.push(searchStr);\n    }\n\n    return t.join(\"?\");\n  }\n\n}\n/* resolve arguments to help overload. 解析函数参数, 帮助重载\r\n```js\r\ntypes eg: ['Object', (i) => i > 3, ['Number', default], null ]\r\nnull represent all types of argument\r\nresolveArgsByType([1,'str'], ['Number', 'Boolean' ,'String']) -> [1, null, 'str']\r\nresolveArgsByType([1,'str'], ['Number', ['Boolean', true] ,'String']) -> [1, true, 'str']\r\n```\r\n*/\n\nfunction resolveArgsByType(args, types) {\n  let argIndex = 0;\n  return types.map(v => {\n    // make rule\n    let rule, dft;\n\n    if (isArray(v)) {\n      rule = v[0];\n      dft = v[1];\n    } else {\n      rule = v;\n      dft = undefined;\n    }\n\n    if (!isFunction(rule)) {\n      if (rule == null) {\n        rule = () => true;\n      } else {\n        const t = rule;\n\n        rule = x => Object.prototype.toString.call(x) === \"[object \".concat(t, \"]\");\n      }\n    }\n\n    const arg = args[argIndex];\n\n    if (rule(arg)) {\n      argIndex++;\n      return arg;\n    } else {\n      return dft;\n    }\n  });\n}\nfunction makeStorageHelper(storage) {\n  return {\n    storage: storage,\n\n    set(name, value, minutes) {\n      // set null can remove a item\n      if (value == null) {\n        this.storage.removeItem(name);\n      } else {\n        this.storage.setItem(name, JSON.stringify({\n          value,\n          expired_at: minutes ? new Date().getTime() + minutes * 60 * 1000 : null\n        }));\n      }\n    },\n\n    get(name) {\n      let t = this.storage.getItem(name);\n\n      if (t) {\n        t = JSON.parse(t);\n\n        if (!t.expired_at || t.expired_at > new Date().getTime()) {\n          return t.value;\n        } else {\n          this.storage.removeItem(name);\n        }\n      }\n\n      return null;\n    },\n\n    clear() {\n      this.storage.clear();\n    }\n\n  };\n}\nconst extendedLocalStorage = cacheFunction(function () {\n  return makeStorageHelper(localStorage);\n});\nconst extendedSessionStorage = cacheFunction(function () {\n  return makeStorageHelper(sessionStorage);\n});\n/**\r\n * Base event process. like event bus\r\n * 事件处理. 类似event bus\r\n */\n\nclass EventProcessor {\n  constructor() {\n    _defineProperty(this, \"eventStore\", []);\n  }\n\n  on(name, handler) {\n    this.eventStore.push({\n      name,\n      handler\n    });\n  }\n\n  once(name, handler) {\n    const off = () => {\n      this.off(name, wrappedHandler);\n    };\n\n    const wrappedHandler = function () {\n      handler(...arguments);\n      off();\n    };\n\n    this.on(name, wrappedHandler);\n    return off;\n  }\n\n  onceTimeout(name, handler, timeout) {\n    let off;\n    const promise = new Promise((resolve, reject) => {\n      const wrappedHandler = function () {\n        handler(...arguments);\n        resolve();\n      };\n\n      off = this.once(name, wrappedHandler);\n      waitTime(timeout).then(() => {\n        off();\n        reject();\n      });\n    });\n\n    const off2 = () => {\n      off && off();\n    };\n\n    return {\n      off: off2,\n      promise\n    };\n  }\n\n  off(name, handler) {\n    const indexes = []; // to remove indexes; reverse; 倒序的\n\n    const len = this.eventStore.length;\n\n    for (let i = 0; i < len; i++) {\n      const item = this.eventStore[i];\n\n      if (item.name === name && item.handler === handler) {\n        indexes.unshift(i);\n      }\n    }\n\n    for (const index of indexes) {\n      this.eventStore.splice(index, 1);\n    }\n  }\n\n  emit(name) {\n    // 重要: 先找到要执行的项放在新数组里, 因为执行项会改变事件项存储数组\n    const items = [];\n\n    for (const item of this.eventStore) {\n      if (item.name === name) {\n        items.push(item);\n      }\n    }\n\n    for (var _len9 = arguments.length, args = new Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) {\n      args[_key9 - 1] = arguments[_key9];\n    }\n\n    for (const item of items) {\n      item.handler(...args);\n    }\n  }\n\n}\n/**\r\n * Pass event cross window\r\n */\n\nclass CrossWindowEventProcessor extends EventProcessor {\n  // id\n  constructor(opt) {\n    super();\n\n    _defineProperty(this, \"storageName\", \"_crossWindow\");\n\n    _defineProperty(this, \"windows\", []);\n\n    _defineProperty(this, \"timeout\", 200);\n\n    _defineProperty(this, \"id\", void 0);\n\n    _defineProperty(this, \"ready\", void 0);\n\n    _defineProperty(this, \"BROADCAST\", \"__BROADCAST__\");\n\n    if (opt) {\n      Object.assign(this, opt);\n    }\n\n    on(window, \"storage\", ev => {\n      if (ev.key === this.storageName) {\n        const event = JSON.parse(ev.newValue);\n\n        if (!event.targets || event.targets.includes(this.id)) {\n          this.emitLocal(event.name, ...event.args);\n        }\n      }\n    }); // social parts 集体部分\n    // join\n\n    this.id = randString();\n    this.windows = [this.id];\n    this.ready = new Promise((resolve, reject) => {\n      this.onceTimeout(\"_windows_updated\", _ref => {\n        let {\n          windows\n        } = _ref;\n        this.windows = windows;\n      }, this.timeout).promise.then(() => {\n        resolve(); // responsed 被响应\n      }, () => {\n        // no response 无响应\n        resolve();\n      });\n      this.broadcast(\"_join\", this.id);\n    });\n    this.ready.then(() => {\n      // on join\n      this.on(\"_join\", id => {\n        this.windows.push(id);\n\n        if (this.isMain()) {\n          this.broadcast(\"_windows_updated\", {\n            windows: this.windows,\n            type: \"join\",\n            id\n          });\n        }\n      }); // on _windows_updated\n\n      this.on(\"_windows_updated\", _ref2 => {\n        let {\n          windows\n        } = _ref2;\n        this.windows = windows;\n      }); // on exit\n\n      this.on(\"_exit\", id => {\n        const oldMain = this.windows[0];\n        arrayRemove(this.windows, id);\n\n        if (this.isMain()) {\n          this.emit(\"_windows_updated\", {\n            windows: this.windows,\n            type: \"exit\",\n            id\n          });\n\n          if (oldMain != this.id) {\n            this.emit(\"_main_updated\", {\n              windows: this.windows,\n              old: oldMain,\n              new: this.id\n            });\n          }\n        }\n      });\n      on(window, \"beforeunload\", () => {\n        this.exitGroup();\n      });\n    });\n  }\n\n  isMain() {\n    return this.id === this.windows[0];\n  }\n\n  emitTo(name, targets) {\n    for (var _len10 = arguments.length, args = new Array(_len10 > 2 ? _len10 - 2 : 0), _key10 = 2; _key10 < _len10; _key10++) {\n      args[_key10 - 2] = arguments[_key10];\n    }\n\n    if (targets === this.BROADCAST) {\n      targets = null;\n    } else {\n      if (targets && !isArray(targets)) {\n        targets = [targets];\n      }\n\n      if (targets.includes(this.id)) {\n        super.emit(name, ...args); // emit to current window\n      }\n    }\n\n    glb().localStorage.setItem(this.storageName, JSON.stringify({\n      name,\n      targets,\n      args,\n      // use random make storage event triggered every time\n      // 加入随机保证触发storage事件\n      random: Math.random()\n    }));\n  }\n\n  emitLocal(name) {\n    for (var _len11 = arguments.length, args = new Array(_len11 > 1 ? _len11 - 1 : 0), _key11 = 1; _key11 < _len11; _key11++) {\n      args[_key11 - 1] = arguments[_key11];\n    }\n\n    this.emitTo(name, this.id, ...args);\n  }\n\n  broadcast(name) {\n    for (var _len12 = arguments.length, args = new Array(_len12 > 1 ? _len12 - 1 : 0), _key12 = 1; _key12 < _len12; _key12++) {\n      args[_key12 - 1] = arguments[_key12];\n    }\n\n    this.emitTo(name, this.BROADCAST, ...args);\n  }\n\n  emit(name) {\n    for (var _len13 = arguments.length, args = new Array(_len13 > 1 ? _len13 - 1 : 0), _key13 = 1; _key13 < _len13; _key13++) {\n      args[_key13 - 1] = arguments[_key13];\n    }\n\n    this.emitTo(name, this.windows, ...args);\n  }\n\n  exitGroup() {\n    this.broadcast(\"_exit\", this.id);\n  }\n\n}\n/**\r\n * on continuous input. return destroy\r\n * 监听连续输入事件. 返回取消监听函数. 例如监听用户输入aa\r\n * @param handler\r\n * @param opt\r\n * @returns\r\n */\n\nfunction onContinuousInput(handler) {\n  let opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  opt = {\n    timeout: 1000,\n    ...opt\n  };\n  let input = \"\";\n  let timeoutId;\n\n  const keydownHandler = e => {\n    if (e.key && e.key.length === 1) {\n      input = \"\".concat(input).concat(e.key);\n      handler(input);\n\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n        timeoutId = null;\n      }\n\n      timeoutId = setTimeout(() => {\n        input = \"\";\n      }, opt.timeout);\n    }\n  };\n\n  on(document, \"keydown\", keydownHandler);\n  return () => {\n    off(document, \"keydown\", keydownHandler);\n  };\n} // refer [onContinuousInput](#onContinuousInput)\n\nconst onQuickKeydown = onContinuousInput;\nfunction getUserLanguage() {\n  return navigator.language || navigator[\"userLanguage\"];\n}\nclass Cache {\n  constructor() {\n    _defineProperty(this, \"store\", {});\n  }\n\n  has(name) {\n    return this.store.hasOwnProperty(name);\n  }\n\n  remember(name, getter) {\n    if (!this.has(name)) {\n      this.store[name] = {\n        value: getter()\n      };\n    }\n\n    return this.store[name].value;\n  }\n\n  forget(name) {\n    if (name) {\n      if (this.has(name)) {\n        delete this.store[name];\n      }\n    } else {\n      this.store = {};\n    }\n  }\n\n} // attach cached getters to an object; can attach to self\n\nfunction attachCache(obj, toCache) {\n  let cache = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Cache();\n\n  for (const key in toCache) {\n    const getter = toCache[key];\n    Object.defineProperty(obj, key, {\n      get() {\n        return cache.remember(key, () => getter.call(this));\n      }\n\n    });\n  }\n} // for animation\n\nfunction easeInOutQuad(startValue, changeInValue, changedTime, duration) {\n  let t = changedTime,\n      d = duration,\n      b = startValue,\n      c = changeInValue;\n  t /= d / 2;\n  if (t < 1) return c / 2 * t * t + b;\n  t--;\n  return -c / 2 * (t * (t - 2) - 1) + b;\n} // others\n\nfunction isMobile() {\n  var isMobile = false; //initiate as false\n  // device detection\n\n  if (/(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|ipad|iris|kindle|Android|Silk|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(navigator.userAgent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i.test(navigator.userAgent.substring(0, 4))) {\n    isMobile = true;\n  }\n\n  return isMobile;\n}\nclass Accumulate {\n  constructor(arr) {\n    _defineProperty(this, \"arr\", []);\n\n    _defineProperty(this, \"cache\", []);\n\n    this.arr = arr;\n  }\n\n  getValue(item) {\n    // @ts-ignore\n    return item;\n  }\n\n  sum(index) {\n    if (this.cache[index] == null) {\n      let prev = index > 0 ? this.sum(index - 1) : 0;\n      this.cache[index] = this.getValue(this.arr[index]) + prev;\n    }\n\n    return this.cache[index];\n  }\n\n}\n/**\r\n * from https://www.zhangxinxu.com/wordpress/2018/08/css-svg-background-image-base64-encode/\r\n * @param svgCode\r\n * @returns\r\n */\n\nfunction svgToDataURL(svgCode) {\n  return \"data:image/svg+xml,\" + svgCode.replace(/\"/g, \"'\").replace(/%/g, \"%25\").replace(/#/g, \"%23\").replace(/{/g, \"%7B\").replace(/}/g, \"%7D\").replace(/</g, \"%3C\").replace(/>/g, \"%3E\");\n}\nfunction genRandomLightColor() {\n  var letters = \"BCDEF\".split(\"\");\n  var color = \"#\";\n\n  for (var i = 0; i < 6; i++) {\n    color += letters[Math.floor(Math.random() * letters.length)];\n  }\n\n  return color;\n}\n/**\r\n * Like Map, support array as key. array order is used.\r\n */\n\nclass ArrayKeyMap {\n  constructor() {\n    _defineProperty(this, \"_map\", new Map());\n\n    _defineProperty(this, \"_values\", {});\n\n    _defineProperty(this, \"_objCount\", 0);\n  }\n\n  _keysToString(keys) {\n    const {\n      _map\n    } = this;\n    let t = [];\n\n    for (const key of keys) {\n      if (!_map.has(key)) {\n        return null;\n      }\n\n      t.push(_map.get(key)[0]);\n    }\n\n    return t.toString();\n  }\n\n  has(keys) {\n    if (this._keysToString(keys) == null) {\n      return false;\n    }\n\n    return true;\n  }\n  /**\r\n   * throw error if not found\r\n   * @param keys\r\n   * @returns\r\n   */\n\n\n  get(keys) {\n    const {\n      _values\n    } = this;\n\n    const key2 = this._keysToString(keys);\n\n    if (key2 == null) {\n      throw \"Value not found by specified keys\";\n    }\n\n    return _values[key2][1];\n  }\n\n  set(keys, value) {\n    const {\n      _map,\n      _values\n    } = this;\n    let t = [];\n\n    for (const key of keys) {\n      let str;\n      let count = 1;\n\n      if (_map.has(key)) {\n        [str, count] = _map.get(key);\n        count++;\n      } else {\n        this._objCount++;\n        str = this._objCount.toString();\n      }\n\n      _map.set(key, [str, count]);\n\n      t.push(str);\n    }\n\n    _values[t.toString()] = [keys.slice(), value];\n  }\n\n  delete(keys) {\n    const {\n      _values,\n      _map\n    } = this;\n\n    const key2 = this._keysToString(keys);\n\n    if (key2 == null) {\n      throw \"Value not found by specified keys\";\n    }\n\n    delete _values[key2];\n\n    for (const key of keys) {\n      let [str, count] = _map.get(key);\n\n      count--;\n\n      if (count === 0) {\n        _map.delete(key);\n      } else {\n        _map.set(key, [str, count]);\n      }\n    }\n  }\n\n  clear() {\n    this._map.clear();\n\n    this._values = {};\n  }\n\n  *entries() {\n    const {\n      _values\n    } = this;\n\n    for (const key in _values) {\n      const [keys, value] = _values[key];\n      yield [keys, value];\n    }\n  }\n\n  count() {\n    return [...this.entries()].length;\n  }\n\n}\n\nexport { Accumulate, ArrayKeyMap, Cache, CrossWindowEventProcessor, EventProcessor, TreeData, URLHelper, addClass, addDate, appendTo, applyFinally, arrayAt, arrayBetween, arrayDiff, arrayDistinct, arrayFilter, arrayFirst, arrayFlat, arrayLast, arrayRemove, arrayRemoveBySortedIndexes, arrayWithout, arrayWithoutEnd, assignIfDiff, assignIfKeyNull, assignIfNoKey, attachCache, backupAttr, between, binarySearch, bindContext, cacheFunction, camelCase, camelToWords, cloneDate, cloneObject, cloneTreeData, continuous, copyTextToClipboard, createElementFromHTML, css, cssNumber, debounceImmediate, debounceTrailing, dotGet, dotSet, easeInOutQuad, elementsFromPoint, empty, executePromiseGetters, executeWithCount, extendedListen, extendedLocalStorage, extendedSessionStorage, findAll, findInfoInTreeData, findParent, findTreeData, genRandomLightColor, getArrayItemSiblingsByOffsets, getBoundingClientRect, getCalendar, getElSizeEvenInvisible, getImageSizeByUrl, getMonthEnd, getMonthStart, getOffset, getOffsetParent, getOuterAttachedHeight, getOuterAttachedWidth, getPosition, getPositionFromOffset, getScroll, getScrollSpace, getUrlParam, getUserLanguage, getViewportPosition, glb, groupArray, hasClass, hasClassIn, hasClasses, indexesOf, insertAfter, insertBefore, isArray, isBool, isDescendantOf, isDocumentExisted, isFunction, isIE, isIsoFormat, isMobile, isNode, isNumber, isNumeric, isObject, isOffsetInEl, isPromise, isScrollable, isString, isWindowDefined, iterateAll, joinFunctionsByNext, joinFunctionsByResult, joinRows, kebabCase, makeStorageHelper, mapObjectTree, mapObjects, notGreaterThan, notLessThan, objectAssignIfDiff, objectAssignIfKeyNull, objectAssignIfNoKey, objectDefineProxyProperty, objectExcept, objectMap, objectOnly, off, on, onContinuousInput, onQuickKeydown, once, openCenterWindow, openPreviewWindow, openWindow, parseISO, pathJoin, pointIn, prependTo, promiseContinuous, promisePin, promiseTimeout, randChoice, randInt, randString, removeClass, removeEl, resolveArgsByType, resolveValueOrGettter, restoreAttr, retry, reverseString, scrollTo, setElChildByIndex, snakeCase, splitArray, strPad, studlyCase, svgToDataURL, titleCase, toArrayIfNot, unset, viewportPositionToFixed, waitFor, waitTime, walkTreeData, watchChange, windowLoaded, withoutUndefined };\n","import { defineComponent as J, ref as I, computed as s, reactive as re, watch as ie, onMounted as oe, nextTick as W } from \"vue-demi\";\nimport * as p from \"helper-js\";\nimport { openBlock as k, createElementBlock as w, renderSlot as u, createElementVNode as ae, resolveComponent as se, normalizeStyle as M, createVNode as ue, withCtx as P, Fragment as G, renderList as D } from \"vue\";\n/*!\n * @virtual-list/vue\n * Author: phphe <phphe@outlook.com> (https://github.com/phphe)\n * Homepage: https://virtual-list.phphe.com\n * Released under the MIT License.\n */\nconst ce = J({\n  props: {\n    table: Boolean\n  }\n}), Q = (e, i) => {\n  const m = e.__vccOpts || e;\n  for (const [d, v] of i)\n    m[d] = v;\n  return m;\n}, de = { key: 0 }, fe = { key: 1 };\nfunction me(e, i, m, d, v, z) {\n  return e.table ? (k(), w(\"table\", de, [\n    u(e.$slots, \"prepend\"),\n    ae(\"tbody\", null, [\n      u(e.$slots, \"default\")\n    ]),\n    u(e.$slots, \"append\")\n  ])) : (k(), w(\"div\", fe, [\n    u(e.$slots, \"prepend\"),\n    u(e.$slots, \"default\"),\n    u(e.$slots, \"append\")\n  ]));\n}\nconst ve = /* @__PURE__ */ Q(ce, [[\"render\", me]]), be = J({\n  components: { VirtualListTable: ve },\n  props: {\n    items: Array,\n    disabled: Boolean,\n    horizontal: Boolean,\n    firstRender: { type: Number, default: 10 },\n    buffer: { type: Number, default: 100 },\n    itemKey: {\n      type: [String, Function]\n    },\n    itemSize: {\n      type: Function\n    },\n    table: Boolean\n  },\n  setup(e) {\n    const i = I(0), m = I(e.firstRender - 1), d = s(\n      () => {\n        var t;\n        return p.notGreaterThan(m.value, (((t = e.items) == null ? void 0 : t.length) || 1) - 1);\n      }\n    ), v = I(0), z = s(() => f.value[i.value] ? E(i.value) : 0), C = s(\n      () => f.value.length > 0 ? E(f.value.length - 1) + p.arrayLast(L.value) : 0\n    ), o = s(\n      () => f.value[d.value] ? C.value - E(d.value) - L.value[d.value] : 0\n    ), b = s(\n      () => e.disabled ? {} : { overflow: \"auto\" }\n    ), U = s(() => {\n      const t = {\n        display: \"flex\"\n      };\n      return e.disabled || (e.horizontal ? Object.assign(t, {\n        \"margin-left\": z.value + \"px\",\n        \"margin-right\": o.value + \"px\",\n        width: C.value - o.value - z.value + \"px\"\n      }) : Object.assign(t, {\n        \"margin-top\": z.value + \"px\",\n        \"margin-bottom\": o.value + \"px\"\n      })), t[\"flex-direction\"] = e.horizontal ? \"row\" : \"column\", e.table && (delete t.display, delete t[\"flex-direction\"]), t;\n    }), $ = s(\n      () => re((e.items || []).map(() => null))\n    ), L = s(\n      () => (e.items || []).map((t, n) => {\n        var g;\n        if ($[n] != null)\n          return $[n];\n        let l = (g = e.itemSize) == null ? void 0 : g.call(e, t, n);\n        return l == null && (l = v.value), l;\n      })\n    ), f = s(() => {\n      const t = [];\n      return L.value.reduce((n, l) => (t.push(n), n + l), 0), t;\n    });\n    ie(() => e.items, y);\n    const X = s(() => {\n      if (!e.items || e.disabled)\n        return;\n      const t = [];\n      for (let n = i.value; n <= d.value; n++) {\n        const l = e.items[n];\n        if (!l)\n          break;\n        t.push({ item: l, index: n });\n      }\n      return t;\n    }), N = I(), V = I();\n    oe(async () => {\n      y();\n      try {\n        Z();\n      } catch {\n        await W(), y();\n      }\n    });\n    let T;\n    function Y() {\n      const t = N.value;\n      if (!t)\n        return;\n      const n = O(t);\n      T != null && e.buffer - Math.abs(n - T) >= 10 || (T = n, y());\n    }\n    let B = !1, K = !1;\n    async function y() {\n      var H;\n      if (B) {\n        K = !0;\n        return;\n      }\n      if (!e.items || e.disabled)\n        return;\n      B = !0;\n      const t = N.value, n = (H = V.value) == null ? void 0 : H.$el;\n      if (!t || !n)\n        return;\n      v.value || (v.value = ne()), i.value = ee(), m.value = te(), await W();\n      let l, g = 0;\n      const F = {}, q = e.table ? n.querySelector(\"tbody\").children : n.children;\n      for (let a = 0; a < q.length; a++) {\n        const r = q[a], c = p.css(r, \"position\");\n        if (c && [\"absolute\", \"fixed\"].includes(c))\n          continue;\n        const h = p.css(r, \"display\") !== \"none\" ? A(r) : 0, S = r.getAttribute(\"vt-index\"), R = S ? parseInt(S) : i.value + g;\n        F[R] = (F[R] || 0) + h, g++;\n      }\n      for (const a of Object.keys(F)) {\n        const r = parseInt(a);\n        $.value[r] !== F[r] && ($.value[r] = F[r], l = !0);\n      }\n      l && await W(), B = !1, K && (K = !1, y());\n      function ee() {\n        const a = O(t) - j(t) - e.buffer;\n        return p.binarySearch(\n          f.value,\n          (c) => c - a,\n          { returnNearestIfNoHit: !0 }\n        ).index;\n      }\n      function te() {\n        const a = O(t) - j(t) + x(t) + e.buffer;\n        return p.binarySearch(\n          f.value,\n          (c) => c - a,\n          { returnNearestIfNoHit: !0 }\n        ).index;\n      }\n      function ne() {\n        const r = [], c = e.table ? n.querySelector(\"tbody\").children : n.children;\n        for (let h = 0; h < c.length; h++) {\n          const S = c[h], R = getComputedStyle(S);\n          if ([\"absolute\", \"fixed\"].includes(R.position))\n            continue;\n          const le = A(S);\n          if (r.push(le), r.length >= 10)\n            break;\n        }\n        return r.length === 0 ? 0 : r.reduce((h, S) => h + S, 0) / r.length;\n      }\n    }\n    function x(t) {\n      const n = getComputedStyle(t);\n      let l = parseFloat(e.horizontal ? n.width : n.height);\n      return n.boxSizing === \"border-box\" && (e.horizontal ? l = l - parseFloat(n.borderLeftWidth) - parseFloat(n.borderRightWidth) : l = l - parseFloat(n.borderTopWidth) - parseFloat(n.borderBottomWidth)), l;\n    }\n    function A(t) {\n      let n = x(t);\n      const l = getComputedStyle(t);\n      return e.horizontal ? n += parseFloat(l.borderLeftWidth) + parseFloat(l.borderRightWidth) + parseFloat(l.marginLeft) + parseFloat(l.marginRight) : n += parseFloat(l.borderTopWidth) + parseFloat(l.borderBottomWidth) + parseFloat(l.marginTop) + parseFloat(l.marginBottom), n = Number.isNaN(n) ? 0 : n, n;\n    }\n    function O(t) {\n      return e.horizontal ? t.scrollLeft : t.scrollTop;\n    }\n    function j(t) {\n      const n = getComputedStyle(t);\n      return e.horizontal ? parseFloat(n.paddingLeft) : parseFloat(n.paddingTop);\n    }\n    function E(t) {\n      return f.value[t];\n    }\n    function Z() {\n      const t = N.value;\n      new ResizeObserver((l) => {\n        for (let g of l)\n          if (p.hasClass(g.target, \"vtlist\")) {\n            y();\n            break;\n          }\n      }).observe(t);\n    }\n    function _(t, n) {\n      if (e.itemKey) {\n        if (typeof e.itemKey == \"string\" && e.itemKey === \"index\")\n          return n;\n        if (typeof e.itemKey == \"function\")\n          return e.itemKey(t, n);\n      }\n    }\n    return {\n      listElRef: N,\n      listInnerRef: V,\n      onscroll: Y,\n      listStyle: b,\n      listInnerStyle: U,\n      visibleItemsInfo: X,\n      getItemKey: _,\n      update: y,\n      sizes: L,\n      positions: f,\n      runtimeSizes: $\n    };\n  }\n});\nfunction ye(e, i, m, d, v, z) {\n  const C = se(\"VirtualListTable\");\n  return k(), w(\"div\", {\n    class: \"vtlist\",\n    ref: \"listElRef\",\n    style: M(e.listStyle),\n    onScrollPassive: i[0] || (i[0] = (...o) => e.onscroll && e.onscroll(...o))\n  }, [\n    ue(C, {\n      class: \"vtlist-inner\",\n      ref: \"listInnerRef\",\n      style: M(e.listInnerStyle),\n      table: e.table\n    }, {\n      prepend: P(() => [\n        u(e.$slots, \"prepend\")\n      ]),\n      append: P(() => [\n        u(e.$slots, \"append\")\n      ]),\n      default: P(() => [\n        e.disabled ? (k(!0), w(G, { key: 0 }, D(e.items, (o, b) => u(e.$slots, \"default\", {\n          key: e.getItemKey(o, b),\n          item: o,\n          index: b\n        })), 128)) : (k(!0), w(G, { key: 1 }, D(e.visibleItemsInfo, ({ item: o, index: b }) => u(e.$slots, \"default\", {\n          key: e.getItemKey(o, b),\n          item: o,\n          index: b\n        })), 128))\n      ]),\n      _: 3\n    }, 8, [\"style\", \"table\"])\n  ], 36);\n}\nconst Se = /* @__PURE__ */ Q(be, [[\"render\", ye]]);\nexport {\n  Se as default\n};\n","<template>\n  <div v-if=\"!table\" class=\"tree-node\" :class=\"{ 'tree-node--with-tree-line': treeLine }\" :style=\"indentStyle\" ref=\"el\">\n    <template v-if=\"treeLine\">\n      <div v-for=\"line in vLines\" class=\"tree-line tree-vline\" :style=\"line.style\"></div>\n      <div v-if=\"stat.level > 1\" class=\"tree-line tree-hline\" :style=\"hLineStyle\"></div>\n    </template>\n    <div class=\"tree-node-inner\">\n      <slot :indentStyle=\"indentStyle\"></slot>\n    </div>\n  </div>\n  <tr v-else class=\"tree-node\" ref=\"el\">\n    <slot :indentStyle=\"indentStyle\"></slot>\n  </tr>\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent, computed, watch } from \"vue-demi\";\n\nlet justToggleOpen = false\nconst afterToggleOpen = () => {\n  justToggleOpen = true\n  setTimeout(() => {\n    justToggleOpen = false\n  }, 100)\n}\n\nconst cpt = defineComponent({\n  // components: {},\n  props: [\"stat\", \"rtl\", \"btt\", \"indent\", \"table\", \"treeLine\", \"treeLineOffset\", \"processor\"],\n  emits: [\"open\", \"close\", \"check\"],\n  setup(props, { emit }) {\n    const indentStyle = computed(() => {\n      return {\n        [!props.rtl ? \"paddingLeft\" : \"paddingRight\"]:\n          props.indent * (props.stat.level - 1) + \"px\",\n      };\n    });\n    // watch checked\n    watch(\n      () => props.stat.checked,\n      (checked) => {\n        // fix issue: https://github.com/phphe/he-tree/issues/98\n        // when open/close above node, the after nodes' states 'checked' and 'open' will be updated. It should be caused by Vue's key. We don't use Vue's key prop.\n        if (justToggleOpen) {\n          return\n        }\n        if (props.processor.afterOneCheckChanged(props.stat)) {\n          emit(\"check\", props.stat);\n        }\n      }\n    );\n    // watch open\n    watch(\n      () => props.stat.open,\n      (open) => {\n        if (justToggleOpen) {\n          return\n        }\n        if (open) {\n          emit(\"open\", props.stat);\n        } else {\n          emit(\"close\", props.stat);\n        }\n        afterToggleOpen()\n      }\n    );\n    // tree lines\n    const vLines = computed(() => {\n      const lines: { style: object }[] = [];\n      const hasNextVisibleNode = (stat) => {\n        if (stat.parent) {\n          let i = stat.parent?.children.indexOf(stat);\n          do {\n            i++\n            let next = stat.parent.children[i]\n            if (next) {\n              if (!next.hidden) {\n                return true\n              }\n            } else {\n              break\n            }\n          } while (true);\n        }\n        return false\n      }\n      const leftOrRight = props.rtl ? 'right' : 'left'\n      const bottomOrTop = props.btt ? 'top' : 'bottom'\n      let current = props.stat\n      while (current) {\n        let left = (current.level - 2) * props.indent + props.treeLineOffset\n        const hasNext = hasNextVisibleNode(current)\n        const addLine = () => {\n          lines.push({\n            style: {\n              [leftOrRight]: left + 'px',\n              [bottomOrTop]: hasNext ? 0 : '50%',\n            }\n          })\n        }\n        if (current === props.stat) {\n          if (current.level > 1) {\n            addLine()\n          }\n        } else if (hasNext) {\n          addLine()\n        }\n        current = current.parent\n      }\n      return lines\n    })\n    const hLineStyle = computed(() => {\n      let left = (props.stat.level - 2) * props.indent + props.treeLineOffset\n      const leftOrRight = props.rtl ? 'right' : 'left'\n      return {\n        [leftOrRight]: left + 'px',\n      }\n    })\n    return { indentStyle, vLines, hLineStyle, }\n  },\n  // data() {\n  //   return {}\n  // },\n  // computed: {},\n  // watch: {},\n  // methods: {},\n  // created() {},\n  // mounted() {}\n});\nexport default cpt;\nexport type TreeNodeType = InstanceType<typeof cpt>;\n</script>\n\n<style>\n/* tree line start */\n.tree-node--with-tree-line {\n  position: relative;\n}\n\n.tree-line {\n  position: absolute;\n  background-color: #bbbbbb;\n}\n\n.tree-vline {\n  width: 1px;\n  top: 0;\n  bottom: 0;\n}\n\n.tree-hline {\n  height: 1px;\n  top: 50%;\n  width: 10px;\n}\n\n/* tree line end */\n</style>","<template>\n  <div v-if=\"!table\" class=\"tree-node\" :class=\"{ 'tree-node--with-tree-line': treeLine }\" :style=\"indentStyle\" ref=\"el\">\n    <template v-if=\"treeLine\">\n      <div v-for=\"line in vLines\" class=\"tree-line tree-vline\" :style=\"line.style\"></div>\n      <div v-if=\"stat.level > 1\" class=\"tree-line tree-hline\" :style=\"hLineStyle\"></div>\n    </template>\n    <div class=\"tree-node-inner\">\n      <slot :indentStyle=\"indentStyle\"></slot>\n    </div>\n  </div>\n  <tr v-else class=\"tree-node\" ref=\"el\">\n    <slot :indentStyle=\"indentStyle\"></slot>\n  </tr>\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent, computed, watch } from \"vue-demi\";\n\nlet justToggleOpen = false\nconst afterToggleOpen = () => {\n  justToggleOpen = true\n  setTimeout(() => {\n    justToggleOpen = false\n  }, 100)\n}\n\nconst cpt = defineComponent({\n  // components: {},\n  props: [\"stat\", \"rtl\", \"btt\", \"indent\", \"table\", \"treeLine\", \"treeLineOffset\", \"processor\"],\n  emits: [\"open\", \"close\", \"check\"],\n  setup(props, { emit }) {\n    const indentStyle = computed(() => {\n      return {\n        [!props.rtl ? \"paddingLeft\" : \"paddingRight\"]:\n          props.indent * (props.stat.level - 1) + \"px\",\n      };\n    });\n    // watch checked\n    watch(\n      () => props.stat.checked,\n      (checked) => {\n        // fix issue: https://github.com/phphe/he-tree/issues/98\n        // when open/close above node, the after nodes' states 'checked' and 'open' will be updated. It should be caused by Vue's key. We don't use Vue's key prop.\n        if (justToggleOpen) {\n          return\n        }\n        if (props.processor.afterOneCheckChanged(props.stat)) {\n          emit(\"check\", props.stat);\n        }\n      }\n    );\n    // watch open\n    watch(\n      () => props.stat.open,\n      (open) => {\n        if (justToggleOpen) {\n          return\n        }\n        if (open) {\n          emit(\"open\", props.stat);\n        } else {\n          emit(\"close\", props.stat);\n        }\n        afterToggleOpen()\n      }\n    );\n    // tree lines\n    const vLines = computed(() => {\n      const lines: { style: object }[] = [];\n      const hasNextVisibleNode = (stat) => {\n        if (stat.parent) {\n          let i = stat.parent?.children.indexOf(stat);\n          do {\n            i++\n            let next = stat.parent.children[i]\n            if (next) {\n              if (!next.hidden) {\n                return true\n              }\n            } else {\n              break\n            }\n          } while (true);\n        }\n        return false\n      }\n      const leftOrRight = props.rtl ? 'right' : 'left'\n      const bottomOrTop = props.btt ? 'top' : 'bottom'\n      let current = props.stat\n      while (current) {\n        let left = (current.level - 2) * props.indent + props.treeLineOffset\n        const hasNext = hasNextVisibleNode(current)\n        const addLine = () => {\n          lines.push({\n            style: {\n              [leftOrRight]: left + 'px',\n              [bottomOrTop]: hasNext ? 0 : '50%',\n            }\n          })\n        }\n        if (current === props.stat) {\n          if (current.level > 1) {\n            addLine()\n          }\n        } else if (hasNext) {\n          addLine()\n        }\n        current = current.parent\n      }\n      return lines\n    })\n    const hLineStyle = computed(() => {\n      let left = (props.stat.level - 2) * props.indent + props.treeLineOffset\n      const leftOrRight = props.rtl ? 'right' : 'left'\n      return {\n        [leftOrRight]: left + 'px',\n      }\n    })\n    return { indentStyle, vLines, hLineStyle, }\n  },\n  // data() {\n  //   return {}\n  // },\n  // computed: {},\n  // watch: {},\n  // methods: {},\n  // created() {},\n  // mounted() {}\n});\nexport default cpt;\nexport type TreeNodeType = InstanceType<typeof cpt>;\n</script>\n\n<style>\n/* tree line start */\n.tree-node--with-tree-line {\n  position: relative;\n}\n\n.tree-line {\n  position: absolute;\n  background-color: #bbbbbb;\n}\n\n.tree-vline {\n  width: 1px;\n  top: 0;\n  bottom: 0;\n}\n\n.tree-hline {\n  height: 1px;\n  top: 50%;\n  width: 10px;\n}\n\n/* tree line end */\n</style>","/*!\n * @he-tree/tree-utils v0.1.0-alpha.5\n * Author: phphe <phphe@outlook.com> (https://github.com/phphe)\n * Homepage: null\n * Released under the MIT License.\n */\nimport * as hp from 'helper-js';\n\nconst CHILDREN = \"children\"; // inner childrenKey\n\n/**\r\n * help to handle tree data. 帮助处理树形数据.\r\n */\n\nfunction makeTreeProcessor(data) {\n  let opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const opt2 = opt;\n  const utilsBase = { ...defaultOptions,\n    ...opt2,\n    data,\n    stats: null,\n    statsFlat: null,\n    _statsMap: null,\n    initialized: false,\n\n    init() {\n      const {\n        data,\n        childrenKey\n      } = this;\n      const td = new hp.TreeData([]);\n      this._statsMap = new Map();\n      hp.walkTreeData(data, (nodeData, index, parent, path) => {\n        const stat = this.statHandler({ ...statDefault(),\n          data: nodeData,\n          open: Boolean(this.defaultOpen),\n          parent: td.getParent(path),\n          children: [],\n          level: path.length\n        });\n\n        this._statsMap.set(nodeData, stat);\n\n        td.set(path, stat);\n      }, {\n        childrenKey\n      });\n      const statsFlat = [];\n      td.walk(stat => {\n        statsFlat.push(stat);\n      });\n      this.stats = this.statsHandler(td.rootChildren);\n      this.statsFlat = this.statsFlatHandler(statsFlat);\n      this.initialized = true;\n    },\n\n    getStat(nodeData) {\n      let r = this._statsMap.get(nodeData);\n\n      if (!r) {\n        throw new StatNotFoundError(\"Stat not found\");\n      }\n\n      return r;\n    },\n\n    has(nodeData) {\n      if (nodeData[\"isStat\"]) {\n        // @ts-ignore\n        return this.statsFlat.indexOf(nodeData) > -1;\n      } else {\n        try {\n          // @ts-ignore\n          let r = this.getStat(nodeData);\n          return Boolean(r);\n        } catch (error) {\n          if (error instanceof StatNotFoundError) {\n            return false;\n          }\n\n          throw error;\n        }\n      }\n    },\n\n    _getPathByStat(stat) {\n      if (stat == null) {\n        return [];\n      }\n\n      const siblings = this.getSiblings(stat);\n      const index = siblings.indexOf(stat);\n      return [...(stat.parent ? this._getPathByStat(stat.parent) : []), index];\n    },\n\n    /**\r\n     * call it after a stat's `checked` changed\r\n     * @param stat\r\n     * @returns return false mean ignored\r\n     */\n    afterOneCheckChanged(stat) {\n      const {\n        checked\n      } = stat;\n\n      if (stat._ignoreCheckedOnce) {\n        delete stat._ignoreCheckedOnce;\n        return false;\n      } // change parent\n\n\n      const checkParent = stat => {\n        const {\n          parent\n        } = stat;\n\n        if (parent) {\n          let hasChecked;\n          let hasUnchecked;\n          let hasHalfChecked;\n\n          for (const child of parent.children) {\n            if (child.checked) {\n              hasChecked = true;\n            } else if (child.checked === 0) {\n              hasHalfChecked = true;\n            } else {\n              hasUnchecked = true;\n            }\n          }\n\n          const parentChecked = hasHalfChecked ? 0 : !hasUnchecked ? true : hasChecked ? 0 : false;\n\n          if (parent.checked !== parentChecked) {\n            this._ignoreCheckedOnce(parent);\n\n            parent.checked = parentChecked;\n          }\n\n          checkParent(parent);\n        }\n      };\n\n      checkParent(stat); // change children\n\n      hp.walkTreeData(stat.children, child => {\n        if (child.checked !== checked) {\n          this._ignoreCheckedOnce(child);\n\n          child.checked = checked;\n        }\n      }, {\n        childrenKey: CHILDREN\n      });\n      return true;\n    },\n\n    _ignoreCheckedOnce(stat) {\n      stat._ignoreCheckedOnce = true; // cancel ignore immediately if not triggered\n\n      setTimeout(() => {\n        if (stat._ignoreCheckedOnce) {\n          stat._ignoreCheckedOnce = false;\n        }\n      }, 100);\n    },\n\n    isVisible(statOrNodeData) {\n      // @ts-ignore\n      const stat = statOrNodeData[\"isStat\"] ? statOrNodeData : this.getStat(statOrNodeData); // prettier-ignore\n\n      const walk = stat => {\n        return !stat || !stat.hidden && stat.open && walk(stat.parent);\n      };\n\n      return Boolean(!stat.hidden && walk(stat.parent));\n    },\n\n    /**\r\n     * call it to update all stats' `checked`\r\n     */\n    updateCheck() {\n      hp.walkTreeData(this.stats, stat => {\n        if (stat.children && stat.children.length > 0) {\n          const checked = stat.children.every(v => v.checked);\n\n          if (stat.checked !== checked) {\n            this._ignoreCheckedOnce(stat);\n\n            stat.checked = checked;\n          }\n        }\n      }, {\n        childFirst: true,\n        childrenKey: CHILDREN\n      });\n    },\n\n    getChecked() {\n      let withDemi = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      return this.statsFlat.filter(v => {\n        return v.checked || withDemi && v.checked === 0;\n      });\n    },\n\n    getUnchecked() {\n      let withDemi = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      return this.statsFlat.filter(v => {\n        return withDemi ? !v.checked : v.checked === false;\n      });\n    },\n\n    /**\r\n     * open all nodes\r\n     */\n    openAll() {\n      for (const stat of this.statsFlat) {\n        stat.open = true;\n      }\n    },\n\n    /**\r\n     * close all nodes\r\n     */\n    closeAll() {\n      for (const stat of this.statsFlat) {\n        stat.open = false;\n      }\n    },\n\n    openNodeAndParents(nodeOrStat) {\n      // @ts-ignore\n      const stat = nodeOrStat[\"isStat\"] ? nodeOrStat : this.getStat(nodeOrStat); // prettier-ignore\n\n      for (const parentStat of this.iterateParent(stat, {\n        withSelf: true\n      })) {\n        parentStat.open = true;\n      }\n    },\n\n    // actions\n    _calcFlatIndex(parent, index) {\n      let flatIndex = parent ? this.statsFlat.indexOf(parent) + 1 : 0;\n      const siblings = parent ? parent.children : this.stats;\n\n      for (let i = 0; i < index; i++) {\n        flatIndex += this._count(siblings[i]);\n      }\n\n      return flatIndex;\n    },\n\n    add(nodeData, parent, index) {\n      if (this.has(nodeData)) {\n        throw \"Can't add because data exists in tree\";\n      }\n\n      const siblings = parent ? parent.children : this.stats;\n\n      if (index == null) {\n        index = siblings.length;\n      }\n\n      const stat = this.statHandler({ ...statDefault(),\n        open: Boolean(this.defaultOpen),\n        data: nodeData,\n        parent: parent || null,\n        children: [],\n        level: parent ? parent.level + 1 : 1\n      });\n\n      this._setPosition(stat, parent || null, index);\n\n      const children = nodeData[this.childrenKey];\n\n      if (children) {\n        const childrenSnap = children.slice();\n\n        for (const child of childrenSnap) {\n          this.add(child, stat);\n        }\n      }\n    },\n\n    remove(stat) {\n      const siblings = this.getSiblings(stat);\n\n      if (siblings.includes(stat)) {\n        hp.arrayRemove(siblings, stat);\n\n        const stats = this._flat(stat);\n\n        this.statsFlat.splice(this.statsFlat.indexOf(stat), stats.length);\n\n        for (const stat of stats) {\n          this._statsMap.delete(stat.data);\n        }\n\n        this.afterRemoveStat(stat);\n        return true;\n      }\n\n      return false;\n    },\n\n    getSiblings(stat) {\n      const {\n        parent\n      } = stat;\n      return parent ? parent.children : this.stats;\n    },\n\n    /**\r\n     * The node should not exsit.\r\n     * @param node\r\n     * @param parent\r\n     * @param index\r\n     */\n    _setPosition(stat, parent, index) {\n      const siblings = parent ? parent.children : this.stats;\n      siblings.splice(index, 0, stat);\n      stat.parent = parent;\n      stat.level = parent ? parent.level + 1 : 1;\n\n      const flatIndex = this._calcFlatIndex(parent, index);\n\n      const stats = this._flat(stat);\n\n      this.statsFlat.splice(flatIndex, 0, ...stats);\n\n      for (const stat of stats) {\n        if (!this._statsMap.has(stat.data)) {\n          this._statsMap.set(stat.data, stat);\n        }\n      }\n\n      hp.walkTreeData(stat, (node, index, parent) => {\n        if (parent) {\n          node.level = parent.level + 1;\n        }\n      }, {\n        childrenKey: CHILDREN\n      });\n      this.afterSetStat(stat, parent, index);\n    },\n\n    *iterateParent(stat, opt) {\n      let t = opt !== null && opt !== void 0 && opt.withSelf ? stat : stat.parent;\n\n      while (t) {\n        yield t;\n        t = t.parent;\n      }\n    },\n\n    move(stat, parent, index) {\n      if (this.has(stat)) {\n        if (stat.parent === parent && this.getSiblings(stat).indexOf(stat) === index) {\n          return false;\n        } // check if is self\n\n\n        if (stat === parent) {\n          // 不允许移动目标为自己\n          throw new Error(\"Can't move node to it self\");\n        } // check if is descendant\n\n\n        if (parent && stat.level < parent.level) {\n          let t;\n\n          for (const item of this.iterateParent(parent)) {\n            if (item.level === stat.level) {\n              t = item;\n              break;\n            }\n          }\n\n          if (stat === t) {\n            // 不允许移动节点到其后代节点下\n            throw new Error(\"Can't move node to its descendant\");\n          }\n        }\n\n        this.remove(stat);\n      }\n\n      this._setPosition(stat, parent, index);\n\n      return true;\n    },\n\n    /**\r\n     * convert stat and its children to one-dimensional array\r\n     * 转换节点和其后代节点为一维数组\r\n     * @param stat\r\n     * @returns\r\n     */\n    _flat(stat) {\n      const r = [];\n      hp.walkTreeData(stat, child => {\n        r.push(child);\n      }, {\n        childrenKey: CHILDREN\n      });\n      return r;\n    },\n\n    /**\r\n     * get count of stat and its all children\r\n     * 统计节点和其后代节点数量\r\n     * @param stat\r\n     */\n    _count(stat) {\n      return this._flat(stat).length;\n    },\n\n    getData(filter, root) {\n      const {\n        childrenKey\n      } = this;\n      const td = new hp.TreeData([]);\n      td.childrenKey = childrenKey;\n      hp.walkTreeData(root || this.stats, (stat, index, parent, path) => {\n        let newData = { ...stat.data,\n          [childrenKey]: []\n        };\n\n        if (filter) {\n          // @ts-ignore\n          newData = filter(newData);\n        }\n\n        td.set(path, newData);\n      }, {\n        childrenKey: CHILDREN\n      });\n      return td.data;\n    }\n\n  };\n  const utils = utilsBase;\n\n  if (!utilsBase.noInitialization) {\n    utils.init();\n  }\n\n  return utils;\n}\nconst defaultOptions = {\n  childrenKey: \"children\",\n  defaultOpen: false,\n\n  statsHandler(stats) {\n    return stats;\n  },\n\n  statsFlatHandler(statsFlat) {\n    return statsFlat;\n  },\n\n  afterSetStat(stat, parent, index) {},\n\n  afterRemoveStat(stat) {},\n\n  statHandler(stat) {\n    return stat;\n  }\n\n};\nfunction statDefault() {\n  return {\n    isStat: true,\n    hidden: false,\n    checked: false,\n    style: null,\n    class: null,\n    draggable: null,\n    droppable: null\n  };\n}\n\nclass StatNotFoundError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = \"StatNotFoundError\";\n  }\n\n}\n\nexport { CHILDREN, defaultOptions, makeTreeProcessor, statDefault };\n","import { makeTreeProcessor, Options } from \"@he-tree/tree-utils\";\nexport * from \"@he-tree/tree-utils\";\nimport { reactive } from \"vue-demi\";\n\nexport function vueMakeTreeProcessor<T>(data: T[], options: Options = {}) {\n  const opt = {\n    ...options,\n    statHandler(input) {\n      if (this[\"_statHandler2\"]) {\n        input = this[\"_statHandler2\"](input);\n      }\n      return filter(options.statHandler, reactive(input));\n    },\n    statsHandler(input) {\n      return filter(options.statsHandler, reactive(input));\n    },\n    statsFlatHandler(input) {\n      return filter(options.statsFlatHandler, reactive(input));\n    },\n  };\n  return makeTreeProcessor(data, opt);\n}\nfunction filter<T>(func: Function | null | undefined, input: T): T {\n  return func ? func(input) : input;\n}\n","<template>\n  <VirtualList\n    class=\"he-tree\"\n    :class=\"{\n      'he-tree--rtl rtl': rtl,\n      'he-tree--drag-overing drag-overing': dragOvering,\n    }\"\n    ref=\"vtlist\"\n    :items=\"visibleStats\"\n    :disabled=\"!virtualization\"\n    :table=\"table\"\n    :itemKey=\"nodeKey\"\n  >\n    <template #prepend>\n      <slot name=\"prepend\" :tree=\"self\"></slot>\n    </template>\n    <template #default=\"{ item: stat, index }\">\n      <TreeNode\n        :vt-index=\"index\"\n        :class=\"[\n          stat.class,\n          {\n            'drag-placeholder-wrapper': stat.data === placeholderData,\n            'dragging-node': stat === dragNode,\n          },\n        ]\"\n        :style=\"stat.style\"\n        :stat=\"stat\"\n        :rtl=\"rtl\"\n        :btt=\"btt\"\n        :indent=\"indent\"\n        :table=\"table\"\n        :treeLine=\"treeLine\"\n        :treeLineOffset=\"treeLineOffset\"\n        :processor=\"processor\"\n        @click=\"$emit('click:node', stat)\"\n        @open=\"$emit('open:node', $event)\"\n        @close=\"$emit('close:node', $event)\"\n        @check=\"$emit('check:node', $event)\"\n      >\n        <template #default=\"{ indentStyle }\">\n          <template v-if=\"stat.data === placeholderData\">\n            <div\n              v-if=\"!table\"\n              class=\"drag-placeholder he-tree-drag-placeholder\"\n            >\n              <slot name=\"placeholder\" :tree=\"self\"></slot>\n            </div>\n            <td v-else :style=\"indentStyle\" :colspan=\"placeholderColspan\">\n              <div class=\"drag-placeholder he-tree-drag-placeholder\">\n                <slot name=\"placeholder\" :tree=\"self\"></slot>\n              </div>\n            </td>\n          </template>\n          <slot\n            v-else\n            :node=\"stat.data\"\n            :stat=\"stat\"\n            :indentStyle=\"indentStyle\"\n            :tree=\"self\"\n            >{{ stat.data[textKey] }}\n          </slot>\n        </template>\n      </TreeNode>\n    </template>\n    <template #append>\n      <slot name=\"append\" :tree=\"self\"></slot>\n    </template>\n  </VirtualList>\n</template>\n\n<script lang=\"ts\">\n// 如果遇到滚动不流畅的情况，不用处理，因为Dev tool造成的。\n// If the scrolling is not smooth, do not deal with it, because it is caused by the Dev tool.\nimport { PropType, defineComponent, isVue2, isVue3, reactive } from \"vue-demi\";\nimport * as hp from \"helper-js\";\nimport VirtualList from \"../virtual-list\";\nimport TreeNode from \"./TreeNode.vue\";\nimport { vueMakeTreeProcessor, Stat, TreeProcessor } from \"./TreeProcessorVue\";\n\nconst cpt = defineComponent({\n  components: { VirtualList, TreeNode },\n  props: {\n    // for vue2\n    value: { required: isVue2, type: Array as PropType<any[]> },\n    // for vue3\n    modelValue: { required: isVue3, type: Array as PropType<any[]> },\n    updateBehavior: {\n      type: String as PropType<\"modify\" | \"new\" | \"disabled\">,\n      default: \"modify\",\n    },\n    processor: {\n      type: Object as PropType<TreeProcessor>,\n      default: () =>\n        vueMakeTreeProcessor([], {\n          noInitialization: true,\n        }),\n    },\n    childrenKey: { type: String, default: \"children\" },\n    /**\n     * for default slot. 用于默认插槽\n     */\n    textKey: { type: String, default: \"text\" },\n    /**\n     * node indent. 节点缩进\n     */\n    indent: { type: Number, default: 20 },\n    /**\n     * Enable virtual list. 启用虚拟列表\n     */\n    virtualization: { type: Boolean, default: false },\n    /**\n     * Render count for virtual list at start. 虚拟列表初始渲染数量.\n     */\n    virtualizationPrerenderCount: { type: Number, default: 20 },\n    /**\n     * Open all nodes by default. 默认打开所有节点.\n     */\n    defaultOpen: { type: Boolean, default: true },\n    statHandler: { type: Function as PropType<(stat: Stat<any>) => Stat<any>> },\n    /**\n     * From right to left. 由右向左显示.\n     */\n    rtl: { type: Boolean, default: false },\n    /**\n     * From bottom to top. 由下向上显示\n     */\n    btt: { type: Boolean, default: false },\n    /**\n     * Display as table\n     */\n    table: { type: Boolean, default: false },\n    watermark: { type: Boolean, default: false },\n    nodeKey: {\n      type: [String, Function] as PropType<\n        \"index\" | ((stat: Stat<any>, index: number) => any)\n      >,\n      default: \"index\",\n    },\n    treeLine: { type: Boolean, default: false },\n    treeLineOffset: { type: Number, default: 8 },\n  },\n  emits: [\n    \"update:modelValue\",\n    \"click:node\",\n    \"open:node\",\n    \"close:node\",\n    \"check:node\",\n    \"beforeDragStart\",\n    \"before-drag-start\",\n    \"after-drop\",\n    \"change\",\n    \"enter\",\n    \"leave\",\n  ],\n  data() {\n    return {\n      stats: [],\n      statsFlat: [],\n      dragNode: null,\n      dragOvering: false,\n      placeholderData: {},\n      placeholderColspan: 1,\n      batchUpdateWaiting: false,\n      self: this,\n      _ignoreValueChangeOnce: false,\n    } as {\n      stats: Exclude<TreeProcessor[\"stats\"], null>;\n      statsFlat: Exclude<TreeProcessor[\"statsFlat\"], null>;\n      dragNode: Stat<any> | null;\n      dragOvering: boolean;\n      placeholderData: {};\n      placeholderColspan: number;\n      batchUpdateWaiting: boolean;\n      self: any;\n      _ignoreValueChangeOnce: boolean;\n    };\n  },\n  computed: {\n    valueComputed() {\n      return (isVue2 ? this.value : this.modelValue) || [];\n    },\n    visibleStats() {\n      const { statsFlat, isVisible } = this;\n      let items = statsFlat;\n      if (this.btt) {\n        items = items.slice();\n        items.reverse();\n      }\n      return items.filter((stat) => isVisible(stat));\n    },\n    rootChildren() {\n      return this.stats;\n    },\n  },\n  methods: {\n    _emitValue(value: any[]) {\n      // @ts-ignore\n      this.$emit(isVue2 ? \"input\" : \"update:modelValue\", value);\n    },\n    /**\n     * private method\n     * @param value\n     */\n    _updateValue(value: any[]) {\n      if (this.updateBehavior === \"disabled\") {\n        return false;\n      }\n      // if value changed, ignore change once\n      if (value !== this.valueComputed) {\n        this._ignoreValueChangeOnce = true;\n      }\n      this._emitValue(value);\n      return true;\n    },\n    getStat: reactiveFirstArg(\n      processorMethodProxy(\"getStat\")\n    ) as TreeProcessor[\"getStat\"],\n    has: reactiveFirstArg(processorMethodProxy(\"has\")) as TreeProcessor[\"has\"],\n    updateCheck: processorMethodProxy(\n      \"updateCheck\"\n    ) as TreeProcessor[\"updateCheck\"],\n    getChecked: processorMethodProxy(\n      \"getChecked\"\n    ) as TreeProcessor[\"getChecked\"],\n    getUnchecked: processorMethodProxy(\n      \"getUnchecked\"\n    ) as TreeProcessor[\"getUnchecked\"],\n    openAll: processorMethodProxy(\"openAll\") as TreeProcessor[\"openAll\"],\n    closeAll: processorMethodProxy(\"closeAll\") as TreeProcessor[\"closeAll\"],\n    openNodeAndParents: processorMethodProxy(\n      \"openNodeAndParents\"\n    ) as TreeProcessor[\"openNodeAndParents\"],\n    isVisible: processorMethodProxy(\"isVisible\") as TreeProcessor[\"isVisible\"],\n    move: processorMethodProxyWithBatchUpdate(\"move\") as TreeProcessor[\"move\"],\n    add: reactiveFirstArg(\n      processorMethodProxyWithBatchUpdate(\"add\")\n    ) as TreeProcessor[\"add\"],\n    addMulti(\n      dataArr: any[],\n      parent?: Stat<any> | null,\n      startIndex?: number | null\n    ) {\n      this.batchUpdate(() => {\n        let index = startIndex;\n        for (const data of dataArr) {\n          this.add(data, parent, index);\n          if (index != null) {\n            index++;\n          }\n        }\n      });\n    },\n    remove: processorMethodProxy(\"remove\") as TreeProcessor[\"remove\"],\n    removeMulti(dataArr: any[]) {\n      let cloned = [...dataArr];\n      this.batchUpdate(() => {\n        for (const data of cloned) {\n          this.remove(data);\n        }\n      });\n    },\n    iterateParent: processorMethodProxy(\n      \"iterateParent\"\n    ) as TreeProcessor[\"iterateParent\"],\n    getSiblings: processorMethodProxy(\n      \"getSiblings\"\n    ) as TreeProcessor[\"getSiblings\"],\n    getData: processorMethodProxy(\"getData\") as hp.ReplaceReturnType<\n      TreeProcessor[\"getData\"],\n      any[]\n    >,\n    getRootEl() {\n      // @ts-ignore\n      return this.$refs.vtlist.listElRef as HTMLElement;\n    },\n    batchUpdate(task: () => any | Promise<any>) {\n      const r = this.ignoreUpdate(task);\n      if (!this.batchUpdateWaiting) {\n        this._updateValue(\n          this.updateBehavior === \"new\" ? this.getData() : this.valueComputed\n        );\n      }\n      return r;\n    },\n    ignoreUpdate(task: () => any | Promise<any>) {\n      const old = this.batchUpdateWaiting;\n      this.batchUpdateWaiting = true;\n      const r = task();\n      this.batchUpdateWaiting = old;\n      return r;\n    },\n  },\n  watch: {\n    processor: {\n      immediate: true,\n      handler(processor: typeof this.processor) {\n        if (processor) {\n          // hook\n          const getNodeDataChildren = (nodeData: any): any[] => {\n            if (!nodeData) {\n              return this.valueComputed;\n            } else {\n              const { childrenKey } = this;\n              if (!nodeData[childrenKey]) {\n                nodeData[childrenKey] = [];\n              }\n              return nodeData[childrenKey];\n            }\n          };\n          processor[\"_statHandler2\"] = this.statHandler\n            ? (stat) => {\n                if (stat.data === this.placeholderData) {\n                  return stat;\n                }\n                return this.statHandler!(stat);\n              }\n            : null;\n          processor.afterSetStat = (stat, parent, index) => {\n            const { childrenKey, updateBehavior } = this;\n            let value = this.valueComputed;\n            if (updateBehavior === \"new\") {\n              if (this.batchUpdateWaiting) {\n                return;\n              }\n              value = this.getData();\n            } else if (updateBehavior === \"modify\") {\n              const siblings = getNodeDataChildren(parent?.data);\n              if (siblings.includes(stat.data)) {\n                // when call add -> add child -> _setPositionm ignore because the child already in parent.children\n              } else {\n                siblings.splice(index, 0, stat.data);\n              }\n            } else if (updateBehavior === \"disabled\") {\n            }\n            if (this.batchUpdateWaiting) {\n              return;\n            }\n            this._updateValue(value);\n          };\n          processor.afterRemoveStat = (stat) => {\n            const { childrenKey, updateBehavior } = this;\n            let value = this.valueComputed;\n            if (updateBehavior === \"new\") {\n              if (this.batchUpdateWaiting) {\n                return;\n              }\n              value = this.getData();\n            } else if (updateBehavior === \"modify\") {\n              const siblings = getNodeDataChildren(stat.parent?.data);\n              hp.arrayRemove(siblings, stat.data);\n            } else if (updateBehavior === \"disabled\") {\n            }\n            if (this.batchUpdateWaiting) {\n              return;\n            }\n            this._updateValue(value);\n          };\n        }\n        if (!processor.initialized) {\n          processor.data = this.valueComputed;\n          Object.assign(\n            processor,\n            hp.objectOnly(this, [\"childrenKey\", \"defaultOpen\"])\n          );\n          processor.init();\n          processor.updateCheck();\n        }\n        this.stats = processor.stats!;\n        this.statsFlat = processor.statsFlat!;\n        if (processor.data !== this.valueComputed) {\n          this._updateValue(processor.data);\n        }\n      },\n    },\n    valueComputed: {\n      handler(value) {\n        // isDragging triggered in Vue2 because its array is not same with Vue3\n        const isDragging = this.dragOvering || this.dragNode;\n        if (isDragging || this._ignoreValueChangeOnce) {\n          this._ignoreValueChangeOnce = false;\n        } else {\n          const { processor } = this;\n          processor.data = value;\n          processor.init();\n          this.stats = processor.stats!;\n          this.statsFlat = processor.statsFlat!;\n        }\n      },\n    },\n  },\n  created() {},\n  mounted() {\n    if (typeof window !== \"undefined\") {\n      if (this.watermark === false) {\n        // @ts-ignore\n        window._heTreeWatermarkDisabled = true;\n      }\n      // @ts-ignore\n      if (this.watermark && !window._heTreeWatermarkDisabled) {\n        // @ts-ignore\n        if (!window._heTreeWatermark) {\n          // @ts-ignore\n          window._heTreeWatermark = true;\n          console.log(\n            `%c[he-tree] Vue tree component:  https://hetree.phphe.com`,\n            \"color:#0075ff; font-size:14px;\"\n          );\n        }\n      }\n    }\n  },\n});\n\nexport default cpt;\nexport type BaseTreeType = InstanceType<typeof cpt>;\n\nfunction processorMethodProxy(name: string) {\n  return function (...args) {\n    // @ts-ignore\n    return this.processor[name](...args);\n  };\n}\nfunction processorMethodProxyWithBatchUpdate(name: string) {\n  return function (...args) {\n    // @ts-ignore\n    return this.batchUpdate(() => {\n      // @ts-ignore\n      return this.processor[name](...args);\n    });\n  };\n}\nfunction reactiveFirstArg(func: any) {\n  return function (arg1, ...args) {\n    if (arg1) {\n      arg1 = reactive(arg1);\n    }\n    // @ts-ignore\n    return func.call(this, arg1, ...args);\n  };\n}\n</script>\n\n<style>\n.he-tree--rtl {\n  direction: rtl;\n}\n\n.he-tree-drag-placeholder {\n  background: #ddf2f9;\n  border: 1px dashed #00d9ff;\n  height: 22px;\n  width: 100%;\n}\n</style>\n","<template>\n  <VirtualList\n    class=\"he-tree\"\n    :class=\"{\n      'he-tree--rtl rtl': rtl,\n      'he-tree--drag-overing drag-overing': dragOvering,\n    }\"\n    ref=\"vtlist\"\n    :items=\"visibleStats\"\n    :disabled=\"!virtualization\"\n    :table=\"table\"\n    :itemKey=\"nodeKey\"\n  >\n    <template #prepend>\n      <slot name=\"prepend\" :tree=\"self\"></slot>\n    </template>\n    <template #default=\"{ item: stat, index }\">\n      <TreeNode\n        :vt-index=\"index\"\n        :class=\"[\n          stat.class,\n          {\n            'drag-placeholder-wrapper': stat.data === placeholderData,\n            'dragging-node': stat === dragNode,\n          },\n        ]\"\n        :style=\"stat.style\"\n        :stat=\"stat\"\n        :rtl=\"rtl\"\n        :btt=\"btt\"\n        :indent=\"indent\"\n        :table=\"table\"\n        :treeLine=\"treeLine\"\n        :treeLineOffset=\"treeLineOffset\"\n        :processor=\"processor\"\n        @click=\"$emit('click:node', stat)\"\n        @open=\"$emit('open:node', $event)\"\n        @close=\"$emit('close:node', $event)\"\n        @check=\"$emit('check:node', $event)\"\n      >\n        <template #default=\"{ indentStyle }\">\n          <template v-if=\"stat.data === placeholderData\">\n            <div\n              v-if=\"!table\"\n              class=\"drag-placeholder he-tree-drag-placeholder\"\n            >\n              <slot name=\"placeholder\" :tree=\"self\"></slot>\n            </div>\n            <td v-else :style=\"indentStyle\" :colspan=\"placeholderColspan\">\n              <div class=\"drag-placeholder he-tree-drag-placeholder\">\n                <slot name=\"placeholder\" :tree=\"self\"></slot>\n              </div>\n            </td>\n          </template>\n          <slot\n            v-else\n            :node=\"stat.data\"\n            :stat=\"stat\"\n            :indentStyle=\"indentStyle\"\n            :tree=\"self\"\n            >{{ stat.data[textKey] }}\n          </slot>\n        </template>\n      </TreeNode>\n    </template>\n    <template #append>\n      <slot name=\"append\" :tree=\"self\"></slot>\n    </template>\n  </VirtualList>\n</template>\n\n<script lang=\"ts\">\n// 如果遇到滚动不流畅的情况，不用处理，因为Dev tool造成的。\n// If the scrolling is not smooth, do not deal with it, because it is caused by the Dev tool.\nimport { PropType, defineComponent, isVue2, isVue3, reactive } from \"vue-demi\";\nimport * as hp from \"helper-js\";\nimport VirtualList from \"../virtual-list\";\nimport TreeNode from \"./TreeNode.vue\";\nimport { vueMakeTreeProcessor, Stat, TreeProcessor } from \"./TreeProcessorVue\";\n\nconst cpt = defineComponent({\n  components: { VirtualList, TreeNode },\n  props: {\n    // for vue2\n    value: { required: isVue2, type: Array as PropType<any[]> },\n    // for vue3\n    modelValue: { required: isVue3, type: Array as PropType<any[]> },\n    updateBehavior: {\n      type: String as PropType<\"modify\" | \"new\" | \"disabled\">,\n      default: \"modify\",\n    },\n    processor: {\n      type: Object as PropType<TreeProcessor>,\n      default: () =>\n        vueMakeTreeProcessor([], {\n          noInitialization: true,\n        }),\n    },\n    childrenKey: { type: String, default: \"children\" },\n    /**\n     * for default slot. 用于默认插槽\n     */\n    textKey: { type: String, default: \"text\" },\n    /**\n     * node indent. 节点缩进\n     */\n    indent: { type: Number, default: 20 },\n    /**\n     * Enable virtual list. 启用虚拟列表\n     */\n    virtualization: { type: Boolean, default: false },\n    /**\n     * Render count for virtual list at start. 虚拟列表初始渲染数量.\n     */\n    virtualizationPrerenderCount: { type: Number, default: 20 },\n    /**\n     * Open all nodes by default. 默认打开所有节点.\n     */\n    defaultOpen: { type: Boolean, default: true },\n    statHandler: { type: Function as PropType<(stat: Stat<any>) => Stat<any>> },\n    /**\n     * From right to left. 由右向左显示.\n     */\n    rtl: { type: Boolean, default: false },\n    /**\n     * From bottom to top. 由下向上显示\n     */\n    btt: { type: Boolean, default: false },\n    /**\n     * Display as table\n     */\n    table: { type: Boolean, default: false },\n    watermark: { type: Boolean, default: false },\n    nodeKey: {\n      type: [String, Function] as PropType<\n        \"index\" | ((stat: Stat<any>, index: number) => any)\n      >,\n      default: \"index\",\n    },\n    treeLine: { type: Boolean, default: false },\n    treeLineOffset: { type: Number, default: 8 },\n  },\n  emits: [\n    \"update:modelValue\",\n    \"click:node\",\n    \"open:node\",\n    \"close:node\",\n    \"check:node\",\n    \"beforeDragStart\",\n    \"before-drag-start\",\n    \"after-drop\",\n    \"change\",\n    \"enter\",\n    \"leave\",\n  ],\n  data() {\n    return {\n      stats: [],\n      statsFlat: [],\n      dragNode: null,\n      dragOvering: false,\n      placeholderData: {},\n      placeholderColspan: 1,\n      batchUpdateWaiting: false,\n      self: this,\n      _ignoreValueChangeOnce: false,\n    } as {\n      stats: Exclude<TreeProcessor[\"stats\"], null>;\n      statsFlat: Exclude<TreeProcessor[\"statsFlat\"], null>;\n      dragNode: Stat<any> | null;\n      dragOvering: boolean;\n      placeholderData: {};\n      placeholderColspan: number;\n      batchUpdateWaiting: boolean;\n      self: any;\n      _ignoreValueChangeOnce: boolean;\n    };\n  },\n  computed: {\n    valueComputed() {\n      return (isVue2 ? this.value : this.modelValue) || [];\n    },\n    visibleStats() {\n      const { statsFlat, isVisible } = this;\n      let items = statsFlat;\n      if (this.btt) {\n        items = items.slice();\n        items.reverse();\n      }\n      return items.filter((stat) => isVisible(stat));\n    },\n    rootChildren() {\n      return this.stats;\n    },\n  },\n  methods: {\n    _emitValue(value: any[]) {\n      // @ts-ignore\n      this.$emit(isVue2 ? \"input\" : \"update:modelValue\", value);\n    },\n    /**\n     * private method\n     * @param value\n     */\n    _updateValue(value: any[]) {\n      if (this.updateBehavior === \"disabled\") {\n        return false;\n      }\n      // if value changed, ignore change once\n      if (value !== this.valueComputed) {\n        this._ignoreValueChangeOnce = true;\n      }\n      this._emitValue(value);\n      return true;\n    },\n    getStat: reactiveFirstArg(\n      processorMethodProxy(\"getStat\")\n    ) as TreeProcessor[\"getStat\"],\n    has: reactiveFirstArg(processorMethodProxy(\"has\")) as TreeProcessor[\"has\"],\n    updateCheck: processorMethodProxy(\n      \"updateCheck\"\n    ) as TreeProcessor[\"updateCheck\"],\n    getChecked: processorMethodProxy(\n      \"getChecked\"\n    ) as TreeProcessor[\"getChecked\"],\n    getUnchecked: processorMethodProxy(\n      \"getUnchecked\"\n    ) as TreeProcessor[\"getUnchecked\"],\n    openAll: processorMethodProxy(\"openAll\") as TreeProcessor[\"openAll\"],\n    closeAll: processorMethodProxy(\"closeAll\") as TreeProcessor[\"closeAll\"],\n    openNodeAndParents: processorMethodProxy(\n      \"openNodeAndParents\"\n    ) as TreeProcessor[\"openNodeAndParents\"],\n    isVisible: processorMethodProxy(\"isVisible\") as TreeProcessor[\"isVisible\"],\n    move: processorMethodProxyWithBatchUpdate(\"move\") as TreeProcessor[\"move\"],\n    add: reactiveFirstArg(\n      processorMethodProxyWithBatchUpdate(\"add\")\n    ) as TreeProcessor[\"add\"],\n    addMulti(\n      dataArr: any[],\n      parent?: Stat<any> | null,\n      startIndex?: number | null\n    ) {\n      this.batchUpdate(() => {\n        let index = startIndex;\n        for (const data of dataArr) {\n          this.add(data, parent, index);\n          if (index != null) {\n            index++;\n          }\n        }\n      });\n    },\n    remove: processorMethodProxy(\"remove\") as TreeProcessor[\"remove\"],\n    removeMulti(dataArr: any[]) {\n      let cloned = [...dataArr];\n      this.batchUpdate(() => {\n        for (const data of cloned) {\n          this.remove(data);\n        }\n      });\n    },\n    iterateParent: processorMethodProxy(\n      \"iterateParent\"\n    ) as TreeProcessor[\"iterateParent\"],\n    getSiblings: processorMethodProxy(\n      \"getSiblings\"\n    ) as TreeProcessor[\"getSiblings\"],\n    getData: processorMethodProxy(\"getData\") as hp.ReplaceReturnType<\n      TreeProcessor[\"getData\"],\n      any[]\n    >,\n    getRootEl() {\n      // @ts-ignore\n      return this.$refs.vtlist.listElRef as HTMLElement;\n    },\n    batchUpdate(task: () => any | Promise<any>) {\n      const r = this.ignoreUpdate(task);\n      if (!this.batchUpdateWaiting) {\n        this._updateValue(\n          this.updateBehavior === \"new\" ? this.getData() : this.valueComputed\n        );\n      }\n      return r;\n    },\n    ignoreUpdate(task: () => any | Promise<any>) {\n      const old = this.batchUpdateWaiting;\n      this.batchUpdateWaiting = true;\n      const r = task();\n      this.batchUpdateWaiting = old;\n      return r;\n    },\n  },\n  watch: {\n    processor: {\n      immediate: true,\n      handler(processor: typeof this.processor) {\n        if (processor) {\n          // hook\n          const getNodeDataChildren = (nodeData: any): any[] => {\n            if (!nodeData) {\n              return this.valueComputed;\n            } else {\n              const { childrenKey } = this;\n              if (!nodeData[childrenKey]) {\n                nodeData[childrenKey] = [];\n              }\n              return nodeData[childrenKey];\n            }\n          };\n          processor[\"_statHandler2\"] = this.statHandler\n            ? (stat) => {\n                if (stat.data === this.placeholderData) {\n                  return stat;\n                }\n                return this.statHandler!(stat);\n              }\n            : null;\n          processor.afterSetStat = (stat, parent, index) => {\n            const { childrenKey, updateBehavior } = this;\n            let value = this.valueComputed;\n            if (updateBehavior === \"new\") {\n              if (this.batchUpdateWaiting) {\n                return;\n              }\n              value = this.getData();\n            } else if (updateBehavior === \"modify\") {\n              const siblings = getNodeDataChildren(parent?.data);\n              if (siblings.includes(stat.data)) {\n                // when call add -> add child -> _setPositionm ignore because the child already in parent.children\n              } else {\n                siblings.splice(index, 0, stat.data);\n              }\n            } else if (updateBehavior === \"disabled\") {\n            }\n            if (this.batchUpdateWaiting) {\n              return;\n            }\n            this._updateValue(value);\n          };\n          processor.afterRemoveStat = (stat) => {\n            const { childrenKey, updateBehavior } = this;\n            let value = this.valueComputed;\n            if (updateBehavior === \"new\") {\n              if (this.batchUpdateWaiting) {\n                return;\n              }\n              value = this.getData();\n            } else if (updateBehavior === \"modify\") {\n              const siblings = getNodeDataChildren(stat.parent?.data);\n              hp.arrayRemove(siblings, stat.data);\n            } else if (updateBehavior === \"disabled\") {\n            }\n            if (this.batchUpdateWaiting) {\n              return;\n            }\n            this._updateValue(value);\n          };\n        }\n        if (!processor.initialized) {\n          processor.data = this.valueComputed;\n          Object.assign(\n            processor,\n            hp.objectOnly(this, [\"childrenKey\", \"defaultOpen\"])\n          );\n          processor.init();\n          processor.updateCheck();\n        }\n        this.stats = processor.stats!;\n        this.statsFlat = processor.statsFlat!;\n        if (processor.data !== this.valueComputed) {\n          this._updateValue(processor.data);\n        }\n      },\n    },\n    valueComputed: {\n      handler(value) {\n        // isDragging triggered in Vue2 because its array is not same with Vue3\n        const isDragging = this.dragOvering || this.dragNode;\n        if (isDragging || this._ignoreValueChangeOnce) {\n          this._ignoreValueChangeOnce = false;\n        } else {\n          const { processor } = this;\n          processor.data = value;\n          processor.init();\n          this.stats = processor.stats!;\n          this.statsFlat = processor.statsFlat!;\n        }\n      },\n    },\n  },\n  created() {},\n  mounted() {\n    if (typeof window !== \"undefined\") {\n      if (this.watermark === false) {\n        // @ts-ignore\n        window._heTreeWatermarkDisabled = true;\n      }\n      // @ts-ignore\n      if (this.watermark && !window._heTreeWatermarkDisabled) {\n        // @ts-ignore\n        if (!window._heTreeWatermark) {\n          // @ts-ignore\n          window._heTreeWatermark = true;\n          console.log(\n            `%c[he-tree] Vue tree component:  https://hetree.phphe.com`,\n            \"color:#0075ff; font-size:14px;\"\n          );\n        }\n      }\n    }\n  },\n});\n\nexport default cpt;\nexport type BaseTreeType = InstanceType<typeof cpt>;\n\nfunction processorMethodProxy(name: string) {\n  return function (...args) {\n    // @ts-ignore\n    return this.processor[name](...args);\n  };\n}\nfunction processorMethodProxyWithBatchUpdate(name: string) {\n  return function (...args) {\n    // @ts-ignore\n    return this.batchUpdate(() => {\n      // @ts-ignore\n      return this.processor[name](...args);\n    });\n  };\n}\nfunction reactiveFirstArg(func: any) {\n  return function (arg1, ...args) {\n    if (arg1) {\n      arg1 = reactive(arg1);\n    }\n    // @ts-ignore\n    return func.call(this, arg1, ...args);\n  };\n}\n</script>\n\n<style>\n.he-tree--rtl {\n  direction: rtl;\n}\n\n.he-tree-drag-placeholder {\n  background: #ddf2f9;\n  border: 1px dashed #00d9ff;\n  height: 22px;\n  width: 100%;\n}\n</style>\n","/*!\n * drag-event-service v2.0.0\n * Author: phphe <phphe@outlook.com> (https://github.com/phphe)\n * Homepage: null\n * Released under the MIT License.\n */\nimport * as hp from 'helper-js';\n\n// support desktop and mobile\nconst events = {\n  start: [\"mousedown\", \"touchstart\"],\n  move: [\"mousemove\", \"touchmove\"],\n  end: [\"mouseup\", \"touchend\"]\n};\nconst DragEventService = {\n  isTouch(e) {\n    return e.type && e.type.startsWith(\"touch\");\n  },\n\n  _getStore(el) {\n    // @ts-ignore\n    if (!el._wrapperStore) {\n      // @ts-ignore\n      el._wrapperStore = [];\n    } // @ts-ignore\n\n\n    return el._wrapperStore;\n  },\n\n  on(el, name, handler, options) {\n    const {\n      args,\n      mouseArgs,\n      touchArgs\n    } = resolveOptions(options);\n\n    const store = this._getStore(el);\n\n    const ts = this;\n\n    const wrapper = function (e) {\n      let mouse;\n      const isTouch = ts.isTouch(e);\n\n      if (isTouch) {\n        // touch\n        mouse = {\n          x: e.changedTouches[0].pageX,\n          y: e.changedTouches[0].pageY,\n          pageX: e.changedTouches[0].pageX,\n          pageY: e.changedTouches[0].pageY,\n          clientX: e.changedTouches[0].clientX,\n          clientY: e.changedTouches[0].clientY,\n          screenX: e.changedTouches[0].screenX,\n          screenY: e.changedTouches[0].screenY\n        };\n      } else {\n        // mouse\n        mouse = {\n          x: e.pageX,\n          y: e.pageY,\n          pageX: e.pageX,\n          pageY: e.pageY,\n          clientX: e.clientX,\n          clientY: e.clientY,\n          screenX: e.screenX,\n          screenY: e.screenY\n        };\n\n        if (name === \"start\" && e.which !== 1) {\n          // not left button mousedown\n          return;\n        }\n      }\n\n      return handler.call(this, e, mouse);\n    };\n\n    store.push({\n      handler,\n      wrapper\n    }); // follow format will cause big bundle size\n    // 以下写法将会使打包工具认为hp是上下文, 导致打包整个hp\n    // hp.on(el, events[name][0], wrapper, ...args)\n\n    hp.on.call(null, el, events[name][0], wrapper, ...[...args, ...mouseArgs]);\n    hp.on.call(null, el, events[name][1], wrapper, ...[...args, ...touchArgs]);\n  },\n\n  off(el, name, handler, options) {\n    const {\n      args,\n      mouseArgs,\n      touchArgs\n    } = resolveOptions(options);\n\n    const store = this._getStore(el);\n\n    for (let i = store.length - 1; i >= 0; i--) {\n      const {\n        handler: handler2,\n        wrapper\n      } = store[i];\n\n      if (handler === handler2) {\n        hp.off.call(null, el, events[name][0], wrapper, ...[...args, ...mouseArgs]);\n        hp.off.call(null, el, events[name][1], wrapper, ...[...args, ...mouseArgs]);\n        store.splice(i, 1);\n      }\n    }\n  }\n\n};\n\nfunction resolveOptions(options) {\n  if (!options) {\n    options = {};\n  }\n\n  const args = options.args || [];\n  const mouseArgs = options.mouseArgs || [];\n  const touchArgs = options.touchArgs || [];\n  return {\n    args,\n    mouseArgs,\n    touchArgs\n  };\n}\n\nexport { DragEventService as default };\n","/*!\n * @he-tree/dnd-utils v0.1.0-alpha.4\n * Author: phphe <phphe@outlook.com> (https://github.com/phphe)\n * Homepage: null\n * Released under the MIT License.\n */\nimport * as hp from 'helper-js';\nimport DragEventService from 'drag-event-service';\n\nconst instances = new Map();\nconst context = {\n  triggerElement: null,\n  dragElement: null,\n  internal: false,\n  dropEffect: \"none\",\n  preventDefault: false\n};\nconst ctx = context;\n\nfunction syncDropEffect(e) {\n  if (e.dataTransfer) {\n    e.dataTransfer.dropEffect = ctx.dropEffect;\n  }\n} //\n\n\nfunction extendedDND(root) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (instances.has(root)) {\n    throw \"Already registered on specified element\";\n  } // opt is same with thisInstance\n\n\n  const opt = { ...options\n  }; // clone options object\n\n  const ins = opt;\n  hp.objectAssignIfNoKey(opt, defaultOptions);\n  DragEventService.on(root, \"start\", beforeDragStart, {\n    touchArgs: [{\n      passive: true\n    }]\n  });\n  DragEventService.on(root, \"end\", onClickEnd); // methods\n\n  function beforeDragStart(e) {\n    var _opt$beforeDragStart;\n\n    const node = e.target; // only process element node\n\n    if (node.nodeType === Node.ELEMENT_NODE) {\n      ctx.triggerElement = node;\n    }\n\n    const el = node; // if in ingoreHTMLTags\n\n    if (opt.ingoreHTMLTags && el.tagName) {\n      if (opt.ingoreHTMLTags.find(tag => tag.toUpperCase() === el.tagName)) {\n        return;\n      }\n    }\n\n    const dragElement = (_opt$beforeDragStart = opt.beforeDragStart) === null || _opt$beforeDragStart === void 0 ? void 0 : _opt$beforeDragStart.call(opt, e);\n\n    if (dragElement) {\n      dragElement.setAttribute(\"draggable\", \"true\");\n      ctx.dragElement = dragElement;\n    }\n  } // triggered when quick click\n\n\n  function onClickEnd(e) {\n    if (ctx.dragElement) {\n      ctx.dragElement.removeAttribute(\"draggable\");\n    }\n  }\n\n  function onDragStart(e) {\n    var _opt$onDragStart;\n\n    ctx.internal = true;\n    (_opt$onDragStart = opt.onDragStart) === null || _opt$onDragStart === void 0 ? void 0 : _opt$onDragStart.call(opt, e);\n    syncDropEffect(e);\n  }\n\n  function onDrag(e) {\n    var _opt$onDrag;\n\n    (_opt$onDrag = opt.onDrag) === null || _opt$onDrag === void 0 ? void 0 : _opt$onDrag.call(opt, e);\n    syncDropEffect(e);\n  }\n\n  function onDragEnd(e) {\n    var _opt$onDragEnd;\n\n    (_opt$onDragEnd = opt.onDragEnd) === null || _opt$onDragEnd === void 0 ? void 0 : _opt$onDragEnd.call(opt, e);\n    ctx.internal = false;\n\n    if (ctx.dragElement) {\n      ctx.dragElement.removeAttribute(\"draggable\");\n    }\n\n    ctx.triggerElement = null;\n    ctx.dragElement = null;\n    ctx.dropEffect = \"none\";\n  } // follow is called on target instance\n\n\n  const destroyDropZoneListeners = extendedDropZone(root, {\n    onDragLeave(e) {\n      var _opt$onDragLeave;\n\n      (_opt$onDragLeave = opt.onDragLeave) === null || _opt$onDragLeave === void 0 ? void 0 : _opt$onDragLeave.call(opt, e);\n      syncDropEffect(e);\n    },\n\n    onDragEnter(e) {\n      var _opt$onDragEnter;\n\n      ins.ifPreventDefault(e) && e.preventDefault();\n      (_opt$onDragEnter = opt.onDragEnter) === null || _opt$onDragEnter === void 0 ? void 0 : _opt$onDragEnter.call(opt, e);\n      syncDropEffect(e);\n    },\n\n    onDragOver(e) {\n      var _opt$onDragOver;\n\n      ins.ifPreventDefault(e) && e.preventDefault();\n      (_opt$onDragOver = opt.onDragOver) === null || _opt$onDragOver === void 0 ? void 0 : _opt$onDragOver.call(opt, e);\n      syncDropEffect(e);\n    },\n\n    onDrop(e) {\n      var _opt$onDrop;\n\n      ins.ifPreventDefault(e) && e.preventDefault();\n      (_opt$onDrop = opt.onDrop) === null || _opt$onDrop === void 0 ? void 0 : _opt$onDrop.call(opt, e);\n    },\n\n    onEnter(e) {\n      var _opt$onEnter;\n\n      (_opt$onEnter = opt.onEnter) === null || _opt$onEnter === void 0 ? void 0 : _opt$onEnter.call(opt, e);\n    },\n\n    onLeave(e) {\n      var _opt$onLeave;\n\n      (_opt$onLeave = opt.onLeave) === null || _opt$onLeave === void 0 ? void 0 : _opt$onLeave.call(opt, e);\n    }\n\n  });\n  hp.on(root, \"dragstart\", onDragStart);\n  hp.on(root, \"drag\", onDrag);\n  hp.on(root, \"dragend\", onDragEnd); // define the destroy function\n  // 定义销毁/退出的方法\n\n  const destroy = () => {\n    DragEventService.off(root, \"start\", beforeDragStart, {\n      touchArgs: [{\n        passive: true\n      }]\n    });\n    hp.off(root, \"dragstart\", onDragStart);\n    hp.off(root, \"drag\", onDrag);\n    hp.off(root, \"dragend\", onDragEnd);\n    destroyDropZoneListeners();\n    instances.delete(root);\n  };\n\n  Object.assign(opt, {\n    root,\n    destroy\n  });\n  instances.set(root, ins);\n  return ins;\n}\nconst defaultOptions = {\n  ingoreHTMLTags: [\"INPUT\", \"TEXTAREA\", \"SELECT\", \"OPTGROUP\", \"OPTION\"],\n\n  ifPreventDefault(event) {\n    if (context.dragElement) {\n      return true;\n    }\n\n    return ctx.preventDefault;\n  },\n\n  beforeDragStart(event) {},\n\n  onDragStart(event) {},\n\n  onDrag(event) {},\n\n  onDragEnter(event) {},\n\n  onDragLeave(event) {},\n\n  onDragOver(event) {},\n\n  onDragEnd(event) {},\n\n  onDrop(event) {}\n\n};\n/*\r\n## extendedDropZone\r\n为元素绑定DND相关事件。\r\n其中onEnter和onLeave不是原生事件。\r\nonEnter原理：\r\n使用变量表示是否进入，每次触发onDragEnter和onDragOver都会使该变量为真。\r\nonLeave原理：\r\n当进入子元素时，会依次触发onDragEnter和onDragLeave事件。onDragEnter时短暂记住事件target，onDragLeave检查是否刚刚触发onDragLeave事件，且事件target是子元素，否则触发onLeave。\r\n*/\n\nlet justEnteredTarget = null;\n\nconst setJustEnteredTarget = el => {\n  justEnteredTarget = el;\n  setTimeout(() => {\n    justEnteredTarget = null;\n  }, 20);\n};\n\nfunction extendedDropZone(el) {\n  let opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const dropZone = el; // just rename\n\n  let entered = false;\n\n  const onEnter = e => {\n    var _opt$onEnter2;\n\n    entered = true;\n    (_opt$onEnter2 = opt.onEnter) === null || _opt$onEnter2 === void 0 ? void 0 : _opt$onEnter2.call(opt, e);\n    endListeners.resume();\n  };\n\n  const onDragEnter = e => {\n    var _opt$onDragEnter2;\n\n    setJustEnteredTarget(e.target);\n    (_opt$onDragEnter2 = opt.onDragEnter) === null || _opt$onDragEnter2 === void 0 ? void 0 : _opt$onDragEnter2.call(opt, e);\n\n    if (!entered) {\n      onEnter(e);\n    }\n  };\n\n  const onDragOver = e => {\n    var _opt$onDragOver2;\n\n    if (!entered) {\n      onEnter(e);\n    }\n\n    (_opt$onDragOver2 = opt.onDragOver) === null || _opt$onDragOver2 === void 0 ? void 0 : _opt$onDragOver2.call(opt, e);\n  };\n\n  const onDragLeave = e => {\n    var _opt$onDragLeave2;\n\n    (_opt$onDragLeave2 = opt.onDragLeave) === null || _opt$onDragLeave2 === void 0 ? void 0 : _opt$onDragLeave2.call(opt, e);\n\n    const doLeave = function () {\n      var _opt$onLeave2;\n\n      let event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : e;\n      entered = false;\n      (_opt$onLeave2 = opt.onLeave) === null || _opt$onLeave2 === void 0 ? void 0 : _opt$onLeave2.call(opt, event);\n      endListeners.stop();\n    };\n\n    const justEnter = justEnteredTarget;\n    justEnteredTarget = null;\n\n    if (justEnter && hp.isDescendantOf(justEnter, dropZone)) ; else {\n      doLeave();\n    }\n  };\n\n  const onDrop = e => {\n    var _opt$onDrop2;\n\n    (_opt$onDrop2 = opt.onDrop) === null || _opt$onDrop2 === void 0 ? void 0 : _opt$onDrop2.call(opt, e);\n  };\n\n  const onEndBeforeLeave = e => {\n    var _opt$onEndBeforeLeave;\n\n    if (e instanceof KeyboardEvent) {\n      if (e.key !== \"Escape\") {\n        return;\n      }\n    }\n\n    entered = false;\n    endListeners.stop();\n    (_opt$onEndBeforeLeave = opt.onEndBeforeLeave) === null || _opt$onEndBeforeLeave === void 0 ? void 0 : _opt$onEndBeforeLeave.call(opt, e);\n  };\n\n  const endListeners = hp.extendedListen([[el, \"drop\", onEndBeforeLeave], [window, \"mouseup\", onEndBeforeLeave], [window, \"touchend\", onEndBeforeLeave], [window, \"keydown\", onEndBeforeLeave]]);\n  endListeners.stop();\n\n  const resume = () => {\n    hp.on(el, \"dragenter\", onDragEnter);\n    hp.on(el, \"dragover\", onDragOver);\n    hp.on(el, \"dragleave\", onDragLeave);\n    hp.on(el, \"drop\", onDrop);\n  };\n\n  const destroy = () => {\n    hp.off(el, \"dragenter\", onDragEnter);\n    hp.off(el, \"dragover\", onDragOver);\n    hp.off(el, \"dragleave\", onDragLeave);\n    hp.off(el, \"drop\", onDrop);\n    endListeners.stop();\n  };\n\n  resume();\n  return destroy;\n}\n\nexport { context, defaultOptions, extendedDND, extendedDropZone, instances };\n","import { PropType, defineComponent } from \"vue-demi\";\nimport BaseTree from \"./BaseTree.vue\";\nimport { Stat, CHILDREN } from \"@he-tree/tree-utils\";\nimport { context as ctx, Point } from \"@he-tree/dnd-utils\";\nimport { extendedDND, ExtendedDND } from \"@he-tree/dnd-utils\";\nimport * as hp from \"helper-js\";\nimport { Nullable } from \"helper-js\";\n\nexport type PropDraggable = (stat: Stat<any>) => boolean | null;\nexport type PropDroppable = (stat: Stat<any>) => boolean | null;\nexport type RootDroppable = () => boolean;\nexport type BeforeDragOpen = (stat: Stat<any>) => void | Promise<void>;\nexport type DragCopyDataHandler<T> = (nodeData: T) => T;\nexport type OnExternalDragOver = (event: DragEvent) => boolean;\nexport type ExternalDataHandler = (event: DragEvent) => any;\nlet startTree: DraggableTreeType | null = null;\nlet targetTree: DraggableTreeType | null = null;\nlet startInfo: StartInfo;\nlet targetInfo: TargetInfo;\nlet dragOpenLastNode: Nullable<Stat<any>>;\nlet startMovePoint: Point;\nlet startMouse: Point;\nlet dragNode: Nullable<Stat<any>>;\nlet closestNode: Nullable<Stat<any>>;\n\nexport const context = {\n  get startInfo() {\n    return startInfo;\n  },\n  get targetInfo() {\n    return targetInfo;\n  },\n  get dragNode() {\n    return dragNode;\n  },\n  get startTree() {\n    return startTree;\n  },\n  get targetTree() {\n    return targetTree;\n  },\n  get closestNode() {\n    return closestNode;\n  },\n};\n\nconst cpt = defineComponent({\n  extends: BaseTree,\n  props: {\n    triggerClass: { type: [String, Array] as PropType<string | string[]> },\n    disableDrag: Boolean,\n    disableDrop: Boolean,\n    eachDraggable: {\n      type: Function as PropType<PropDraggable>,\n    },\n    eachDroppable: {\n      type: Function as PropType<PropDroppable>,\n    },\n    rootDroppable: {\n      type: [Boolean, Function] as PropType<boolean | RootDroppable>,\n      default: true,\n    },\n    /**\n     * open closed node when drag over\n     */\n    dragOpen: { type: Boolean, default: true },\n    dragOpenDelay: { type: Number, default: 0 },\n    /**\n     * e.g.: you can load children by ajax in the hook\n     */\n    beforeDragOpen: { type: Function as PropType<BeforeDragOpen> },\n    resolveStartMovePoint: {\n      type: [String, Function] as PropType<\n        \"mouse\" | \"default\" | ((dragElement: HTMLElement) => Point)\n      >,\n    },\n    /**\n     * if remove placeholder when drag leave a tree\n     */\n    keepPlaceholder: { type: Boolean },\n    /**\n     * prevent drop if greater than maxLevel\n     */\n    maxLevel: { type: Number },\n    /**\n     * copy when drag\n     */\n    dragCopy: { type: Boolean },\n    /**\n     * return new data when drag copy\n     */\n    dragCopyDataHandler: {\n      type: Function as PropType<DragCopyDataHandler<any>>,\n    },\n    onExternalDragOver: {\n      type: Function as PropType<OnExternalDragOver>,\n    },\n    externalDataHandler: {\n      type: Function as PropType<ExternalDataHandler>,\n    },\n    // hook of event HTML5 Drag and Drop API's dragstart event\n    ondragstart: {\n      type: Function as PropType<(event: DragEvent) => void>,\n    },\n  },\n  data() {\n    return {\n      treeDraggableInstance: null,\n    } as {\n      treeDraggableInstance: ExtendedDND | null;\n    };\n  },\n  computed: {},\n  methods: {\n    getNodeByElement(el: HTMLElement): Stat<any> | null {\n      const i = el.getAttribute(\"vt-index\");\n      return i == null ? null : this.visibleStats[i];\n    },\n    isDraggable(node: Stat<any>): boolean {\n      if (this.disableDrag) {\n        return false;\n      }\n      if (node.draggable != null) {\n        return node.draggable;\n      }\n      if (this.eachDraggable) {\n        const t = this.eachDraggable(node);\n        if (t != null) {\n          return t;\n        }\n      }\n      const { parent } = node;\n      if (!parent) {\n        return true;\n      } else {\n        return this.isDraggable(parent);\n      }\n    },\n    isDroppable(node: Stat<any> | null): boolean {\n      if (this.disableDrop) {\n        return false;\n      }\n      if (!node) {\n        return hp.resolveValueOrGettter(this.rootDroppable, [this, startTree]);\n      }\n      if (node.droppable != null) {\n        return node.droppable;\n      }\n      if (this.eachDroppable) {\n        const t = this.eachDroppable(node);\n        if (t != null) {\n          return t;\n        }\n      }\n      const { parent } = node;\n      if (!parent) {\n        return true;\n      } else {\n        return this.isDroppable(parent);\n      }\n    },\n    _eachDroppable() {\n      return hp.resolveValueOrGettter(this[\"_isDragCopy\"]?.(), [this]);\n    },\n  },\n  mounted() {\n    // Deprecated old watermark\n    // const hetreeWatermark = window[\"_hetreeWatermark\"];\n    // window[\"_hetreeWatermark\"] = () =>\n    //   hp.resolveValueOrGettter(document[\"_hetreeWatermark\"], [\n    //     true,\n    //     false,\n    //     true,\n    //   ]);\n    // if (\n    //   hp.resolveValueOrGettter(!window[\"_hetreeWatermark\"]()) &&\n    //   !hetreeWatermark\n    // ) {\n    //   console.log(\n    //     `%c[he-tree] Vue tree component:  https://hetree.phphe.com`,\n    //     \"color:#0075ff; font-size:14px;\"\n    //   );\n    // }\n    //\n    const isMoved = (mouse: Point, lastMouse: Point) => {\n      let r = true;\n      if (startTree && startTree !== this) {\n        r = r && this[\"_isMoved\"];\n      }\n      if (this.table && !this[\"_isDragCopy\"]) {\n        r = r && this[\"_isDragCopy\"];\n      }\n      return r && (mouse.x !== lastMouse.x || mouse.y !== lastMouse.y);\n    };\n    //\n    const movePlaceholder = (parent: Stat<any> | null, index: number) => {\n      targetTree!.ignoreUpdate(() => {\n        // get placeholder\n        if (!targetTree!.has(targetTree!.placeholderData)) {\n          if (targetTree!.table) {\n            let colspan = 0;\n            const tr = targetTree!.getRootEl().querySelector(\"tr\");\n            if (tr) {\n              for (const {\n                value: childEl,\n              } of hp.iterateAll<HTMLTableCellElement>(tr.children)) {\n                if (hp.css(childEl, \"display\") !== \"none\") {\n                  colspan += childEl.colSpan || 1;\n                }\n              }\n            }\n            if (colspan < 1) {\n              colspan = 1;\n            }\n            targetTree!.placeholderColspan = colspan;\n          }\n          targetTree!.add(targetTree!.placeholderData);\n        }\n        const placeholder = targetTree!.getStat(targetTree!.placeholderData);\n        targetTree!.move(placeholder, parent, index);\n      });\n    };\n    const removePlaceholder = () => {\n      const tree = this;\n      if (tree.has(tree.placeholderData)) {\n        tree.remove(tree.getStat(tree.placeholderData));\n        return true;\n      }\n    };\n    /**\n     * set cursor should be synchronously with event. This function will try update cursor at next dragover event.\n     */\n    const setCursor = (droppable: boolean) => {\n      if (!droppable) {\n        ctx.dropEffect = \"none\";\n      } else {\n        ctx.dropEffect = startTree?.dragCopy ? \"copy\" : \"move\";\n      }\n    };\n    const setDroppable = (droppable: boolean) => {\n      const tree = this; // targetTree\n      if (!droppable) {\n        if (!tree.keepPlaceholder) {\n          removePlaceholder();\n          setCursor(false);\n        } else if (!tree.has(tree.placeholderData)) {\n          setCursor(false);\n        }\n      } else {\n        setCursor(true);\n      }\n    };\n    let lastMouse = { x: 0, y: 0 }; // for dragover to detect if moved\n    const rootEl = this.getRootEl();\n    let dragElement: HTMLElement | null = null; // dragElement is the drag node element\n    const removePlaceholderWhenEnd = () => {\n      if (targetTree?.has(targetTree!.placeholderData)) {\n        targetTree!.ignoreUpdate(() => {\n          targetTree!.remove(targetTree!.getStat(targetTree!.placeholderData));\n          // update together to prevent flick\n          if (startTree) {\n            startTree.dragNode!.hidden = false;\n            startTree.dragOvering = false;\n          }\n        });\n      }\n    };\n    this.treeDraggableInstance = extendedDND(rootEl, {\n      beforeDragStart: (event) => {\n        // triggerElement trigger click\n        if (!ctx.triggerElement) {\n          return;\n        }\n        let triggerClass = this.triggerClass;\n        if (!triggerClass || triggerClass.length === 0) {\n          triggerClass = \"tree-node\";\n        }\n        let triggerClasses = hp.toArrayIfNot(triggerClass);\n        let triggerDragElement = hp.findParent(\n          ctx.triggerElement,\n          (el) => {\n            if (hp.hasClassIn(el, triggerClasses)) {\n              return true;\n            } else if (hp.hasClass(el, \"tree-node\")) {\n              return \"break\";\n            }\n          },\n          { withSelf: true, until: rootEl }\n        );\n        // dragElement is the drag node element\n        dragElement = hp.findParent(\n          triggerDragElement,\n          (el) => {\n            if (hp.hasClass(el, \"tree-node\")) {\n              return true;\n            }\n          },\n          { withSelf: true, until: rootEl }\n        );\n        if (!dragElement) {\n          return;\n        }\n        dragNode = this.getNodeByElement(dragElement);\n        if (!dragNode) {\n          throw `Can't find drag node`;\n        }\n        if (!this.isDraggable(dragNode)) {\n          return;\n        }\n        this.$emit(\"before-drag-start\", dragNode);\n        this.$emit(\"beforeDragStart\", dragNode);\n        return rootEl;\n      },\n      onDragStart: (event) => {\n        if (!dragElement || !dragNode) {\n          return;\n        }\n        {\n          const { x, y } = dragElement.getBoundingClientRect();\n          const { clientX, clientY } = event;\n          event.dataTransfer?.setDragImage(\n            dragElement,\n            clientX - x,\n            clientY - y\n          );\n        }\n        const mouse = { x: event.clientX, y: event.clientY };\n        startMouse = mouse;\n        startTree = this;\n        startTree.dragNode = dragNode;\n        startMovePoint = (() => {\n          if (this.resolveStartMovePoint === \"mouse\") {\n            return { x: event.clientX, y: event.clientY };\n          } else if (typeof this.resolveStartMovePoint === \"function\") {\n            return this.resolveStartMovePoint(dragElement);\n          } else {\n            // top_left\n            let point: Point;\n            let height = 0;\n            if (!this.table) {\n              if (!this.rtl) {\n                point = dragElement.children[0]\n                  .getBoundingClientRect()\n                  .toJSON();\n                height = (<DOMRect>point).height;\n              } else {\n                const rect = dragElement.children[0].getBoundingClientRect();\n                point = {\n                  x: rect.right,\n                  y: rect.y,\n                };\n                height = rect.height;\n              }\n            } else {\n              let rect = dragElement.getBoundingClientRect();\n              point = { x: rect.x, y: rect.y };\n              if (this.rtl) {\n                point.x = rect.right;\n              }\n              height = rect.height;\n            }\n            if (this.btt) {\n              point.y += height;\n            }\n            return point!;\n          }\n        })();\n        this.dragOvering = true;\n        const siblings = startTree.getSiblings(startTree!.dragNode!);\n        const indexBeforeDrop = siblings.indexOf(dragNode);\n        startInfo = {\n          tree: startTree,\n          dragNode,\n          parent: dragNode.parent,\n          siblings,\n          indexBeforeDrop,\n        };\n        targetTree = this;\n        event.dataTransfer?.setData(\n          \"text\",\n          `he-tree drag start at ${new Date().toISOString()}`\n        ); // required for Chrome Andriod, or Drag and Drop API does't  work\n        if (!startTree._eachDroppable()) {\n          setTimeout(() => {\n            dragNode!.hidden = true;\n            movePlaceholder(dragNode!.parent, indexBeforeDrop + 1);\n          }, 0);\n        }\n        this.ondragstart?.(event);\n      },\n      // onDragEnter, onDragLeave, onDragOver, onDrop execute on target tree\n      onEnter: (event) => {\n        this.$emit(\"enter\", event);\n      },\n      onLeave: (event) => {\n        dragOpenLastNode = null;\n        this.dragOvering = false;\n        ctx.preventDefault = false;\n        removePlaceholder();\n        this.$emit(\"leave\", event);\n      },\n      onDragOver: hp.applyFinally(\n        (event: DragEvent) => {\n          if (!startTree) {\n            // from external\n            if (\n              !this.onExternalDragOver ||\n              this.onExternalDragOver(event) === false\n            ) {\n              return;\n            } else {\n              ctx.preventDefault = true;\n            }\n          }\n          // return if not moved\n          const mouse = { x: event.clientX, y: event.clientY };\n          const isMoved2 = isMoved(mouse, lastMouse);\n          lastMouse = mouse;\n          if (!isMoved2) {\n            return;\n          }\n          //\n          this.dragOvering = true;\n          //\n          targetTree = this;\n          const movePoint = startMovePoint\n            ? {\n                x: startMovePoint.x + (mouse.x - startMouse.x),\n                y: startMovePoint.y + (mouse.y - startMouse.y),\n              }\n            : { ...mouse };\n          const { btt, rtl } = targetTree;\n          // if undroppable, return\n          if (targetTree!.disableDrop) {\n            ctx.dropEffect = \"none\";\n            return;\n          }\n\n          let prevNode: Stat<any> | null;\n          let nextNode: Stat<any> | null;\n          const nodeList = targetTree\n            .getRootEl()\n            .querySelectorAll(`.tree-node`);\n          const nodeEls: HTMLElement[] = [];\n          nodeList.forEach((el) => {\n            if (\n              !hp.hasClassIn(el, [\n                \"drag-placeholder-wrapper\",\n                \"dragging-node\",\n              ]) &&\n              hp.css(el, \"display\") !== \"none\"\n            ) {\n              nodeEls.push(el as HTMLElement);\n            }\n          });\n          const t = hp.binarySearch(\n            nodeEls,\n            (node) =>\n              hp.getBoundingClientRect(node)[!btt ? \"top\" : \"bottom\"] -\n              movePoint.y,\n            { returnNearestIfNoHit: true }\n          )!;\n          let prevIndex: number | null = null;\n          let prevNodeEl: HTMLElement;\n          let nextNodeEl: HTMLElement;\n          if (t.hit) {\n          } else {\n            if (t.greater) {\n              if (!btt) {\n                prevIndex = t.index - 1;\n                if (!nodeEls[prevIndex]) {\n                  prevIndex++;\n                }\n              } else {\n              }\n            } else {\n              if (!btt) {\n              } else {\n                prevIndex = t.index + 1;\n                if (!nodeEls[prevIndex]) {\n                  prevIndex--;\n                }\n              }\n            }\n          }\n          if (prevIndex == null) {\n            prevIndex = t.index;\n          }\n          prevNodeEl = nodeEls[prevIndex];\n          nextNodeEl = !btt ? nodeEls[prevIndex + 1] : nodeEls[prevIndex - 1];\n          prevNode = prevNodeEl && targetTree!.getNodeByElement(prevNodeEl);\n          nextNode = nextNodeEl && targetTree!.getNodeByElement(nextNodeEl);\n\n          //\n          const { indent } = targetTree;\n          // prev node BoundingClientRect\n          // the element is the first child of prevNode\n          const prevBCR = hp.cacheFunction(() => {\n            if (!targetTree!.table) {\n              return hp.getBoundingClientRect(prevNodeEl.firstElementChild!);\n            } else {\n              let r = hp.getBoundingClientRect(prevNodeEl).toJSON();\n              const indentSize = indent * (prevNode!.level - 1);\n              if (!rtl) {\n                r.x += indentSize;\n              } else {\n                r.width -= indentSize;\n                r.right -= indentSize;\n              }\n              return r as DOMRect;\n            }\n          }).action;\n          const onPrevMiddle = hp.cacheFunction(() => {\n            if (!btt) {\n              return movePoint.y < prevBCR().y + prevBCR().height / 2;\n            } else {\n              return movePoint.y > prevBCR().y + prevBCR().height / 2;\n            }\n          }).action;\n          const atTop = hp.cacheFunction(() => {\n            // special. at the top of the tree\n            if (!btt) {\n              return !prevNodeEl || (prevIndex === 0 && onPrevMiddle());\n            } else {\n              return (\n                !prevNodeEl ||\n                (prevIndex === nodeEls.length - 1 && onPrevMiddle())\n              );\n            }\n          }).action;\n          // Positive number mean moving node at left of prev node\n          const prevX_minusMovePointX = hp.cacheFunction(() =>\n            !rtl\n              ? prevBCR().x - movePoint.x\n              : movePoint.x - (prevBCR().x + prevBCR().width)\n          ).action;\n          const atPrevIndentRight = hp.cacheFunction(() =>\n            !rtl\n              ? movePoint.x > prevBCR().x + indent\n              : movePoint.x < prevBCR().x + prevBCR().width - indent\n          ).action;\n          //\n          let targetLevel: number;\n          if (atTop()) {\n            targetLevel = 1;\n            prevNode = null;\n          } else if (!prevNode) {\n            return;\n          } else if (prevX_minusMovePointX() > 0) {\n            // at left\n            targetLevel =\n              prevNode!.level - Math.ceil(prevX_minusMovePointX() / indent);\n          } else if (atPrevIndentRight()) {\n            targetLevel = prevNode!.level + 1;\n          } else {\n            targetLevel = prevNode!.level;\n          }\n\n          if (nextNode && targetLevel < nextNode.level) {\n            targetLevel = nextNode.level;\n          }\n          //\n          const findDroppablePosition = async () => {\n            let parent, prevSibling;\n            let cancelled = false;\n            let _dragOpenLastNode: typeof dragOpenLastNode = null; // for reset dragOpenLastNode\n            const isOpen = async (stat: Stat<any>) => {\n              if (stat.open) {\n                return true;\n              } else if (targetTree!.dragOpen) {\n                if (!targetTree!.dragOpenDelay) {\n                  if (targetTree!.beforeDragOpen) {\n                    await targetTree!.beforeDragOpen(stat);\n                  }\n                  stat.open = true;\n                  return true;\n                } else {\n                  _dragOpenLastNode = stat;\n                  if (dragOpenLastNode === stat) {\n                    cancelled = true;\n                  } else {\n                    let wait = hp.promisePin<boolean, any>();\n                    dragOpenLastNode = stat;\n                    const localNode = stat;\n                    setTimeout(async () => {\n                      if (localNode !== dragOpenLastNode) {\n                        cancelled = true;\n                        wait.resolve(true);\n                      } else {\n                        if (targetTree!.beforeDragOpen) {\n                          await targetTree!.beforeDragOpen(stat);\n                        }\n                        if (localNode !== dragOpenLastNode) {\n                          cancelled = true;\n                          wait.resolve(true);\n                        } else {\n                          stat.open = true;\n                          _dragOpenLastNode = null;\n                          wait.resolve(true);\n                        }\n                      }\n                    }, targetTree!.dragOpenDelay);\n                    return await wait.promise;\n                  }\n                }\n              } else {\n                return false;\n              }\n            };\n            const tryPrepend = async () => {\n              // prevNode must existing\n              if (\n                targetTree!.isDroppable(prevNode) &&\n                (await isOpen(prevNode!))\n              ) {\n                if (cancelled) {\n                  return;\n                }\n                parent = prevNode;\n                prevSibling = null;\n              } else {\n                return false;\n              }\n            };\n            const tryAfter = (minLevel = targetLevel) => {\n              // prevNode must existing\n              let t: Stat<any> | null = prevNode!;\n              let t3: (Stat<any> | null)[] = [];\n              while (t && t.level >= minLevel) {\n                t = t.parent || null; // null mean root\n                t3.unshift(t);\n              }\n              let i = 0;\n              for (const node of t3) {\n                if (targetTree!.isDroppable(node)) {\n                  parent = node;\n                  prevSibling = t3[i + 1] || prevNode;\n                  return true;\n                }\n                i++;\n              }\n              return false;\n            };\n            closestNode = prevNode || null; // assign to public variable\n            if (!prevNode) {\n              if (targetTree!.isDroppable(null)) {\n                parent = null;\n              }\n            } else if (targetLevel > prevNode.level) {\n              if ((await tryPrepend()) === false) {\n                tryAfter(prevNode.level);\n              }\n            } else {\n              if (tryAfter() === false) {\n                await tryPrepend();\n              }\n            }\n            dragOpenLastNode = _dragOpenLastNode;\n            const success = Boolean(!cancelled && (parent || parent === null));\n            const getIndex = () =>\n              prevSibling\n                ? (parent ? parent.children : targetTree!.stats)\n                    .filter((v) => v.data !== targetTree!.placeholderData)\n                    .indexOf(prevSibling) + 1\n                : 0;\n            return {\n              cancelled,\n              success,\n              parent,\n              index: success ? getIndex() : -1,\n            };\n          };\n          findDroppablePosition().then((dp) => {\n            if (dp.cancelled) {\n              return;\n            }\n            if (!dp.success) {\n              setDroppable(false);\n              return;\n            }\n            // check max level\n            if (targetTree!.maxLevel != null && targetTree!.maxLevel > 0) {\n              let dragNodeWithChildLevel = 1;\n              if (startTree) {\n                const dragNode = startTree.dragNode!;\n                let childMaxLevel = 0;\n                hp.walkTreeData(\n                  dragNode,\n                  (node) => {\n                    if (node!.level > childMaxLevel) {\n                      childMaxLevel = node!.level;\n                    }\n                  },\n                  {\n                    childrenKey: CHILDREN,\n                  }\n                );\n                dragNodeWithChildLevel = childMaxLevel - dragNode.level + 1;\n              }\n              const willLevel =\n                dragNodeWithChildLevel + (dp.parent ? dp.parent.level : 0);\n              if (willLevel > targetTree!.maxLevel) {\n                setDroppable(false);\n                return;\n              }\n            }\n            setDroppable(true);\n            // move placeholder\n            movePlaceholder(dp.parent, dp.index);\n          });\n        },\n        () => {\n          // do nothing\n        }\n      ),\n      onDrop: (event) => {\n        targetTree = this;\n        const external = !startTree;\n        if (!targetTree) {\n          return;\n        }\n        const dragNode = startTree?.dragNode!;\n        let externalData: any;\n        let dragChanged = (() => {\n          let changed = true;\n          if (!targetTree!.has(targetTree!.placeholderData)) {\n            changed = false;\n          } else if (external) {\n            externalData = this.externalDataHandler?.(event);\n            changed = externalData != null;\n          } else if (!startTree!.dragCopy) {\n            const placeholder = targetTree!.getStat(\n              targetTree!.placeholderData\n            );\n            if (\n              startTree === targetTree &&\n              placeholder.parent === dragNode!.parent\n            ) {\n              if (\n                (hp.findTreeData(dragNode, (node) => node === placeholder),\n                { childrenKey: CHILDREN })\n              ) {\n              } else {\n                const siblings = this.processor.getSiblings(placeholder);\n                const placeholderIndex = siblings.indexOf(placeholder);\n                const prev = siblings[placeholderIndex - 1];\n                const next = siblings[placeholderIndex + 1];\n                if (prev === dragNode || next === dragNode) {\n                  changed = false;\n                }\n              }\n            }\n          }\n          return changed;\n        })();\n        if (dragChanged) {\n          const placeholder = targetTree!.getStat(targetTree!.placeholderData);\n          const siblings = targetTree!.getSiblings(placeholder);\n          targetInfo = {\n            tree: targetTree,\n            dragNode,\n            parent: placeholder.parent,\n            siblings,\n            indexBeforeDrop: siblings.indexOf(placeholder),\n          };\n        }\n        (() => {\n          removePlaceholderWhenEnd();\n          if (dragChanged) {\n            // resolve targetIndex\n            let targetIndex = targetInfo.indexBeforeDrop;\n            if (\n              startTree &&\n              !startTree.dragCopy &&\n              startTree === targetTree &&\n              startInfo.parent == targetInfo.parent &&\n              startInfo.indexBeforeDrop < targetIndex\n            ) {\n              targetIndex--;\n            }\n            //\n            if (\n              startTree &&\n              startTree !== targetTree &&\n              !startTree._eachDroppable()\n            ) {\n              startTree.batchUpdate(() => {\n                startTree!.remove(dragNode);\n                startTree!.updateCheck();\n              });\n            }\n            targetTree!.batchUpdate(() => {\n              let newDragNode = startTree?.dragNode!;\n              let newData: any;\n              if (externalData) {\n                newData = externalData;\n              } else if (startTree!._eachDroppable()) {\n                newData = hp.cloneTreeData(startTree!.dragNode!.data, {\n                  childrenKey: startTree!.childrenKey,\n                });\n                if (startTree!.dragCopyDataHandler) {\n                  newData = startTree!.dragCopyDataHandler(newData);\n                }\n              }\n              if (newData) {\n                targetTree!.add(newData);\n                newDragNode = targetTree!.getStat(newData);\n              }\n              targetTree!.move(newDragNode, targetInfo.parent, targetIndex);\n              targetTree!.updateCheck();\n            });\n          }\n          targetTree!.$emit(\"after-drop\");\n          if (dragChanged) {\n            if (startTree) {\n              // don't emit change when dragCopy\n              if (!startTree.dragCopy) {\n                startTree.$emit(\"change\");\n              }\n            }\n            if (targetTree !== startTree) {\n              targetTree!.$emit(\"change\");\n            }\n          }\n        })();\n      },\n      onDragEnd: (event) => {\n        removePlaceholderWhenEnd();\n        // reset\n        if (startTree) {\n          startTree.dragNode && (startTree.dragNode.hidden = false);\n          startTree.dragNode = null;\n          startTree.dragOvering = false;\n          startTree = null;\n        }\n        targetTree = null;\n        dragOpenLastNode = null;\n        dragNode = null;\n        closestNode = null;\n      },\n    });\n  },\n  unmounted() {\n    this.treeDraggableInstance?.destroy();\n  },\n});\nexport default cpt;\nexport type DraggableTreeType = InstanceType<typeof cpt>;\nexport interface StartInfo {\n  tree: DraggableTreeType;\n  dragNode: Stat<any>;\n  parent: Stat<any> | null;\n  siblings: Stat<any>[];\n  indexBeforeDrop: number;\n}\nexport type TargetInfo = StartInfo;\n","<template>\n  <a class=\"he-tree__open-icon\" :class=\"{ open: open }\">\n    <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n      <title>chevron-right</title>\n      <path d=\"M8.59,16.58L13.17,12L8.59,7.41L10,6L16,12L10,18L8.59,16.58Z\" />\n    </svg>\n  </a>\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent } from \"vue-demi\";\n\nexport default defineComponent({\n  props: {\n    open: { type: Boolean },\n  },\n})\n</script>\n\n<style>\n.he-tree__open-icon {\n  cursor: pointer;\n  user-select: none;\n  display: inline-block;\n}\n\n.he-tree__open-icon.open {\n  transform: rotate(90deg);\n}\n\n.he-tree__open-icon svg {\n  width: 1em;\n}\n</style>","<template>\n  <a class=\"he-tree__open-icon\" :class=\"{ open: open }\">\n    <svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 24 24\">\n      <title>chevron-right</title>\n      <path d=\"M8.59,16.58L13.17,12L8.59,7.41L10,6L16,12L10,18L8.59,16.58Z\" />\n    </svg>\n  </a>\n</template>\n\n<script lang=\"ts\">\nimport { defineComponent } from \"vue-demi\";\n\nexport default defineComponent({\n  props: {\n    open: { type: Boolean },\n  },\n})\n</script>\n\n<style>\n.he-tree__open-icon {\n  cursor: pointer;\n  user-select: none;\n  display: inline-block;\n}\n\n.he-tree__open-icon.open {\n  transform: rotate(90deg);\n}\n\n.he-tree__open-icon svg {\n  width: 1em;\n}\n</style>","// library entry\nexport { default as BaseTree } from \"./components/BaseTree.vue\";\nexport { default as TreeNode } from \"./components/TreeNode.vue\"; // Internal component, not recommended\nimport Draggable from \"./components/DraggableTree\";\nexport {\n  default as Draggable,\n  context as dragContext,\n} from \"./components/DraggableTree\";\nexport * from \"./components/DraggableTree\"; // export types\nexport { walkTreeData } from \"helper-js\";\n// material design\nexport { default as OpenIcon } from \"./components/OpenIcon.vue\";\n\nexport function pro(account: string, secretKey: string): typeof Draggable {\n  try {\n    // @ts-ignore\n    return {\n      mixins: [Draggable],\n      created: new Function(deSecretKey(account, secretKey))(),\n    };\n  } catch (error) {\n    throw new Error(\"he-tree-pro: wrong secret key\");\n  }\n}\n\nfunction deSecretKey(account: string, code: string) {\n  account = encodeURIComponent(account);\n  if (account.length % 2 === 1) {\n    account += \"h\";\n  }\n  account = account.split(\"\").reverse().join(\"\");\n  code = atob(code);\n  for (let index = 0; index < account.length; index += 2) {\n    const a = account[index];\n    const b = account[index + 1];\n    code = doubleReplace(code, a, b);\n  }\n  return join2(\n    \"arb=inowc=ocmet;etrnfucton){are=1,=tistr{evod !=b}ath(){e&(c_htreWtemak=)=e,._sMve=(=>._eteeatrmrkd.israCoy=)=d.abe,._acDrppbl=(=>.dagop)}\",\n    code\n  );\n}\n\nfunction doubleReplace(str: string, char1: string, char2: string) {\n  let r = \"\";\n  for (let index = 0; index < str.length; index++) {\n    const char = str[index];\n    if (char === char1) {\n      r += char2;\n    } else if (char === char2) {\n      r += char1;\n    } else {\n      r += char;\n    }\n  }\n  return r;\n}\n\nfunction join2(a: string, b: string) {\n  let i = 0;\n  let r = \"\";\n  while (true) {\n    let index;\n    index = i;\n    if (index >= b.length) {\n      break;\n    }\n    r += b[index];\n    index = i * 2;\n    if (index >= a.length) {\n      break;\n    }\n    r += a[index];\n    index += 1;\n    if (index >= a.length) {\n      break;\n    }\n    r += a[index];\n    i++;\n  }\n  return r;\n}\n"],"names":["_defineProperty","obj","key","value","isArray","v","isObject","isFunction","notGreaterThan","n","max","arrayRemove","arr","index","count","arrayLast","toArrayIfNot","arrOrNot","objectOnly","keys","keysSet","iterateAll","val","opt","i","info","assignIfNoKey","objectAssignIfNoKey","obj1","obj2","withoutUndefined","r","walkTreeData","handler","childrenKey","rootChildren","StopException","func","children","parent","parentPath","len","item","path","e","findInfoInTreeData","findTreeData","cloneTreeData","root","options","nodeHandler","td","TreeData","node","newNode","data","list","path0","prevPath","prevChildren","currentPath","currentNode","all","parentChildren","resolveValueOrGettter","valueOrGetter","args","applyFinally","finallyFunc","error","cacheFunction","cachedArgsArr","map","defaultValue","noArgsCache","_len6","_key6","ArrayKeyMap","removed","promisePin","resolve","reject","resolve2","reject2","isDescendantOf","el","getBoundingClientRect","xy","top","bottom","left","right","width","height","json","findParent","callback","cur","shouldBreak","hasClass","className","hasClassIn","classNames","on","name","off","extendedListen","destroyFuncs","destroy","css","binarySearch","start","end","returnNearestIfNoHit","maxTimes","midNum","mid","_map","t","_values","key2","str","ce","J","Q","m","d","de","fe","me","z","k","w","u","ae","ve","be","I","s","p.notGreaterThan","f","E","C","p.arrayLast","L","o","b","U","$","re","g","l","ie","y","X","N","V","oe","Z","W","T","Y","O","B","H","ne","ee","te","F","q","a","c","p.css","h","A","S","R","j","p.binarySearch","x","le","p.hasClass","_","ye","se","M","ue","P","G","D","Se","justToggleOpen","afterToggleOpen","cpt","defineComponent","props","emit","indentStyle","computed","watch","checked","open","vLines","lines","hasNextVisibleNode","stat","_a","next","leftOrRight","bottomOrTop","current","hasNext","addLine","hLineStyle","_hoisted_2","_ctx","_cache","$props","$setup","$data","$options","_openBlock","_createElementBlock","_normalizeClass","_normalizeStyle","_Fragment","_renderList","line","_createCommentVNode","_createElementVNode","_hoisted_1","CHILDREN","makeTreeProcessor","opt2","utilsBase","defaultOptions","hp.TreeData","hp.walkTreeData","nodeData","statDefault","statsFlat","StatNotFoundError","checkParent","hasChecked","hasUnchecked","hasHalfChecked","child","parentChecked","statOrNodeData","walk","withDemi","nodeOrStat","parentStat","flatIndex","siblings","childrenSnap","hp.arrayRemove","stats","filter","newData","utils","message","vueMakeTreeProcessor","input","reactive","VirtualList","TreeNode","isVue2","isVue3","isVisible","items","reactiveFirstArg","processorMethodProxy","processorMethodProxyWithBatchUpdate","dataArr","startIndex","cloned","task","old","processor","getNodeDataChildren","updateBehavior","hp.objectOnly","arg1","_resolveComponent","_createBlock","_component_VirtualList","_renderSlot","_withCtx","_createVNode","_component_TreeNode","$event","events","DragEventService","mouseArgs","touchArgs","resolveOptions","store","ts","wrapper","mouse","hp.on","handler2","hp.off","instances","context","ctx","syncDropEffect","extendedDND","ins","hp.objectAssignIfNoKey","beforeDragStart","onClickEnd","_opt$beforeDragStart","tag","dragElement","onDragStart","_opt$onDragStart","onDrag","_opt$onDrag","onDragEnd","_opt$onDragEnd","destroyDropZoneListeners","extendedDropZone","_opt$onDragLeave","_opt$onDragEnter","_opt$onDragOver","_opt$onDrop","_opt$onEnter","_opt$onLeave","event","justEnteredTarget","setJustEnteredTarget","dropZone","entered","onEnter","_opt$onEnter2","endListeners","onDragEnter","_opt$onDragEnter2","onDragOver","_opt$onDragOver2","onDragLeave","_opt$onDragLeave2","doLeave","_opt$onLeave2","justEnter","hp.isDescendantOf","onDrop","_opt$onDrop2","onEndBeforeLeave","_opt$onEndBeforeLeave","hp.extendedListen","resume","startTree","targetTree","startInfo","targetInfo","dragOpenLastNode","startMovePoint","startMouse","dragNode","closestNode","BaseTree","hp.resolveValueOrGettter","isMoved","lastMouse","movePlaceholder","colspan","tr","childEl","hp.iterateAll","hp.css","placeholder","removePlaceholder","tree","setCursor","droppable","setDroppable","rootEl","removePlaceholderWhenEnd","triggerClass","triggerClasses","hp.toArrayIfNot","triggerDragElement","hp.findParent","hp.hasClassIn","hp.hasClass","clientX","clientY","point","rect","indexBeforeDrop","_b","_c","hp.applyFinally","isMoved2","movePoint","btt","rtl","prevNode","nextNode","nodeList","nodeEls","hp.binarySearch","hp.getBoundingClientRect","prevIndex","prevNodeEl","nextNodeEl","indent","prevBCR","hp.cacheFunction","indentSize","onPrevMiddle","atTop","prevX_minusMovePointX","atPrevIndentRight","targetLevel","prevSibling","cancelled","_dragOpenLastNode","isOpen","wait","hp.promisePin","localNode","tryPrepend","tryAfter","minLevel","t3","success","dp","dragNodeWithChildLevel","childMaxLevel","external","externalData","dragChanged","changed","hp.findTreeData","targetIndex","newDragNode","hp.cloneTreeData","_sfc_main","_sfc_render","pro","account","secretKey","Draggable","deSecretKey","code","doubleReplace","join2","char1","char2","char"],"mappings":"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","x_google_ignoreList":[0,1,2,9]}