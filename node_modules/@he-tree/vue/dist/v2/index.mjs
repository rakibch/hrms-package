import { defineComponent as z, computed as q, watch as oe, reactive as A, isVue2 as Y, isVue3 as ge } from "vue-demi";
import * as f from "helper-js";
import { walkTreeData as Qe } from "helper-js";
import ve from "@virtual-list/vue/vue2";
import { makeTreeProcessor as ye, CHILDREN as se } from "@he-tree/tree-utils";
import { extendedDND as me, context as P } from "@he-tree/dnd-utils";
/*!
 * @he-tree/vue v2.9.3
 * Author: phphe <phphe@outlook.com> (https://github.com/phphe)
 * Homepage: https://hetree.phphe.com/
 * Released under the MIT License.
 */
let j = !1;
const be = () => {
  j = !0, setTimeout(() => {
    j = !1;
  }, 100);
}, De = z({
  // components: {},
  props: ["stat", "rtl", "btt", "indent", "table", "treeLine", "treeLineOffset", "processor"],
  emits: ["open", "close", "check"],
  setup(e, { emit: t }) {
    const r = q(() => ({
      [e.rtl ? "paddingRight" : "paddingLeft"]: e.indent * (e.stat.level - 1) + "px"
    }));
    oe(
      () => e.stat.checked,
      (m) => {
        j || e.processor.afterOneCheckChanged(e.stat) && t("check", e.stat);
      }
    ), oe(
      () => e.stat.open,
      (m) => {
        j || (t(m ? "open" : "close", e.stat), be());
      }
    );
    const i = q(() => {
      const m = [], y = (s) => {
        var c;
        if (s.parent) {
          let d = (c = s.parent) == null ? void 0 : c.children.indexOf(s);
          do {
            d++;
            let h = s.parent.children[d];
            if (h) {
              if (!h.hidden)
                return !0;
            } else
              break;
          } while (!0);
        }
        return !1;
      }, b = e.rtl ? "right" : "left", x = e.btt ? "top" : "bottom";
      let l = e.stat;
      for (; l; ) {
        let s = (l.level - 2) * e.indent + e.treeLineOffset;
        const c = y(l), d = () => {
          m.push({
            style: {
              [b]: s + "px",
              [x]: c ? 0 : "50%"
            }
          });
        };
        l === e.stat ? l.level > 1 && d() : c && d(), l = l.parent;
      }
      return m;
    }), o = q(() => {
      let m = (e.stat.level - 2) * e.indent + e.treeLineOffset;
      return {
        [e.rtl ? "right" : "left"]: m + "px"
      };
    });
    return { indentStyle: r, vLines: i, hLineStyle: o };
  }
  // data() {
  //   return {}
  // },
  // computed: {},
  // watch: {},
  // methods: {},
  // created() {},
  // mounted() {}
});
var xe = function() {
  var e = this, t = e.$createElement, r = e._self._c || t;
  return e.table ? r("tr", { ref: "el", staticClass: "tree-node" }, [e._t("default", null, { indentStyle: e.indentStyle })], 2) : r("div", { ref: "el", staticClass: "tree-node", class: { "tree-node--with-tree-line": e.treeLine }, style: e.indentStyle }, [e.treeLine ? [e._l(e.vLines, function(i) {
    return r("div", { staticClass: "tree-line tree-vline", style: i.style });
  }), e.stat.level > 1 ? r("div", { staticClass: "tree-line tree-hline", style: e.hLineStyle }) : e._e()] : e._e(), r("div", { staticClass: "tree-node-inner" }, [e._t("default", null, { indentStyle: e.indentStyle })], 2)], 2);
}, _e = [];
function ee(e, t, r, i, o, m, y, b) {
  var x = typeof e == "function" ? e.options : e;
  t && (x.render = t, x.staticRenderFns = r, x._compiled = !0);
  var l;
  if (o && (l = o), l)
    if (x.functional) {
      x._injectStyles = l;
      var s = x.render;
      x.render = function(h, v) {
        return l.call(v), s(h, v);
      };
    } else {
      var c = x.beforeCreate;
      x.beforeCreate = c ? [].concat(c, l) : [l];
    }
  return {
    exports: e,
    options: x
  };
}
const de = {};
var Ce = /* @__PURE__ */ ee(
  De,
  xe,
  _e,
  !1,
  Se
);
function Se(e) {
  for (let t in de)
    this[t] = de[t];
}
const Oe = /* @__PURE__ */ function() {
  return Ce.exports;
}();
function we(e, t = {}) {
  const r = {
    ...t,
    statHandler(i) {
      return this._statHandler2 && (i = this._statHandler2(i)), G(t.statHandler, A(i));
    },
    statsHandler(i) {
      return G(t.statsHandler, A(i));
    },
    statsFlatHandler(i) {
      return G(t.statsFlatHandler, A(i));
    }
  };
  return ye(e, r);
}
function G(e, t) {
  return e ? e(t) : t;
}
const Ne = z({
  components: { VirtualList: ve, TreeNode: Oe },
  props: {
    // for vue2
    value: { required: Y, type: Array },
    // for vue3
    modelValue: { required: ge, type: Array },
    updateBehavior: {
      type: String,
      default: "modify"
    },
    processor: {
      type: Object,
      default: () => we([], {
        noInitialization: !0
      })
    },
    childrenKey: { type: String, default: "children" },
    /**
     * for default slot. 用于默认插槽
     */
    textKey: { type: String, default: "text" },
    /**
     * node indent. 节点缩进
     */
    indent: { type: Number, default: 20 },
    /**
     * Enable virtual list. 启用虚拟列表
     */
    virtualization: { type: Boolean, default: !1 },
    /**
     * Render count for virtual list at start. 虚拟列表初始渲染数量.
     */
    virtualizationPrerenderCount: { type: Number, default: 20 },
    /**
     * Open all nodes by default. 默认打开所有节点.
     */
    defaultOpen: { type: Boolean, default: !0 },
    statHandler: { type: Function },
    /**
     * From right to left. 由右向左显示.
     */
    rtl: { type: Boolean, default: !1 },
    /**
     * From bottom to top. 由下向上显示
     */
    btt: { type: Boolean, default: !1 },
    /**
     * Display as table
     */
    table: { type: Boolean, default: !1 },
    watermark: { type: Boolean, default: !1 },
    nodeKey: {
      type: [String, Function],
      default: "index"
    },
    treeLine: { type: Boolean, default: !1 },
    treeLineOffset: { type: Number, default: 8 }
  },
  emits: [
    "update:modelValue",
    "click:node",
    "open:node",
    "close:node",
    "check:node",
    "beforeDragStart",
    "before-drag-start",
    "after-drop",
    "change",
    "enter",
    "leave"
  ],
  data() {
    return {
      stats: [],
      statsFlat: [],
      dragNode: null,
      dragOvering: !1,
      placeholderData: {},
      placeholderColspan: 1,
      batchUpdateWaiting: !1,
      self: this,
      _ignoreValueChangeOnce: !1
    };
  },
  computed: {
    valueComputed() {
      return (Y ? this.value : this.modelValue) || [];
    },
    visibleStats() {
      const { statsFlat: e, isVisible: t } = this;
      let r = e;
      return this.btt && (r = r.slice(), r.reverse()), r.filter((i) => t(i));
    },
    rootChildren() {
      return this.stats;
    }
  },
  methods: {
    _emitValue(e) {
      this.$emit(Y ? "input" : "update:modelValue", e);
    },
    /**
     * private method
     * @param value
     */
    _updateValue(e) {
      return this.updateBehavior === "disabled" ? !1 : (e !== this.valueComputed && (this._ignoreValueChangeOnce = !0), this._emitValue(e), !0);
    },
    getStat: J(
      O("getStat")
    ),
    has: J(O("has")),
    updateCheck: O(
      "updateCheck"
    ),
    getChecked: O(
      "getChecked"
    ),
    getUnchecked: O(
      "getUnchecked"
    ),
    openAll: O("openAll"),
    closeAll: O("closeAll"),
    openNodeAndParents: O(
      "openNodeAndParents"
    ),
    isVisible: O("isVisible"),
    move: ce("move"),
    add: J(
      ce("add")
    ),
    addMulti(e, t, r) {
      this.batchUpdate(() => {
        let i = r;
        for (const o of e)
          this.add(o, t, i), i != null && i++;
      });
    },
    remove: O("remove"),
    removeMulti(e) {
      let t = [...e];
      this.batchUpdate(() => {
        for (const r of t)
          this.remove(r);
      });
    },
    iterateParent: O(
      "iterateParent"
    ),
    getSiblings: O(
      "getSiblings"
    ),
    getData: O("getData"),
    getRootEl() {
      return this.$refs.vtlist.listElRef;
    },
    batchUpdate(e) {
      const t = this.ignoreUpdate(e);
      return this.batchUpdateWaiting || this._updateValue(
        this.updateBehavior === "new" ? this.getData() : this.valueComputed
      ), t;
    },
    ignoreUpdate(e) {
      const t = this.batchUpdateWaiting;
      this.batchUpdateWaiting = !0;
      const r = e();
      return this.batchUpdateWaiting = t, r;
    }
  },
  watch: {
    processor: {
      immediate: !0,
      handler(e) {
        if (e) {
          const t = (r) => {
            if (r) {
              const { childrenKey: i } = this;
              return r[i] || (r[i] = []), r[i];
            } else
              return this.valueComputed;
          };
          e._statHandler2 = this.statHandler ? (r) => r.data === this.placeholderData ? r : this.statHandler(r) : null, e.afterSetStat = (r, i, o) => {
            const { childrenKey: m, updateBehavior: y } = this;
            let b = this.valueComputed;
            if (y === "new") {
              if (this.batchUpdateWaiting)
                return;
              b = this.getData();
            } else if (y === "modify") {
              const x = t(i == null ? void 0 : i.data);
              x.includes(r.data) || x.splice(o, 0, r.data);
            }
            this.batchUpdateWaiting || this._updateValue(b);
          }, e.afterRemoveStat = (r) => {
            var y;
            const { childrenKey: i, updateBehavior: o } = this;
            let m = this.valueComputed;
            if (o === "new") {
              if (this.batchUpdateWaiting)
                return;
              m = this.getData();
            } else if (o === "modify") {
              const b = t((y = r.parent) == null ? void 0 : y.data);
              f.arrayRemove(b, r.data);
            }
            this.batchUpdateWaiting || this._updateValue(m);
          };
        }
        e.initialized || (e.data = this.valueComputed, Object.assign(
          e,
          f.objectOnly(this, ["childrenKey", "defaultOpen"])
        ), e.init(), e.updateCheck()), this.stats = e.stats, this.statsFlat = e.statsFlat, e.data !== this.valueComputed && this._updateValue(e.data);
      }
    },
    valueComputed: {
      handler(e) {
        if (this.dragOvering || this.dragNode || this._ignoreValueChangeOnce)
          this._ignoreValueChangeOnce = !1;
        else {
          const { processor: r } = this;
          r.data = e, r.init(), this.stats = r.stats, this.statsFlat = r.statsFlat;
        }
      }
    }
  },
  created() {
  },
  mounted() {
    typeof window < "u" && (this.watermark === !1 && (window._heTreeWatermarkDisabled = !0), this.watermark && !window._heTreeWatermarkDisabled && (window._heTreeWatermark || (window._heTreeWatermark = !0, console.log(
      "%c[he-tree] Vue tree component:  https://hetree.phphe.com",
      "color:#0075ff; font-size:14px;"
    ))));
  }
});
function O(e) {
  return function(...t) {
    return this.processor[e](...t);
  };
}
function ce(e) {
  return function(...t) {
    return this.batchUpdate(() => this.processor[e](...t));
  };
}
function J(e) {
  return function(t, ...r) {
    return t && (t = A(t)), e.call(this, t, ...r);
  };
}
var ke = function() {
  var e = this, t = e.$createElement, r = e._self._c || t;
  return r("VirtualList", { ref: "vtlist", staticClass: "he-tree", class: {
    "he-tree--rtl rtl": e.rtl,
    "he-tree--drag-overing drag-overing": e.dragOvering
  }, attrs: { items: e.visibleStats, disabled: !e.virtualization, table: e.table, itemKey: e.nodeKey }, scopedSlots: e._u([{ key: "prepend", fn: function() {
    return [e._t("prepend", null, { tree: e.self })];
  }, proxy: !0 }, { key: "default", fn: function(i) {
    var o = i.item, m = i.index;
    return [r("TreeNode", { class: [
      o.class,
      {
        "drag-placeholder-wrapper": o.data === e.placeholderData,
        "dragging-node": o === e.dragNode
      }
    ], style: o.style, attrs: { "vt-index": m, stat: o, rtl: e.rtl, btt: e.btt, indent: e.indent, table: e.table, treeLine: e.treeLine, treeLineOffset: e.treeLineOffset, processor: e.processor }, on: { click: function(y) {
      return e.$emit("click:node", o);
    }, open: function(y) {
      return e.$emit("open:node", y);
    }, close: function(y) {
      return e.$emit("close:node", y);
    }, check: function(y) {
      return e.$emit("check:node", y);
    } }, scopedSlots: e._u([{ key: "default", fn: function(y) {
      var b = y.indentStyle;
      return [o.data === e.placeholderData ? [e.table ? r("td", { style: b, attrs: { colspan: e.placeholderColspan } }, [r("div", { staticClass: "drag-placeholder he-tree-drag-placeholder" }, [e._t("placeholder", null, { tree: e.self })], 2)]) : r("div", { staticClass: "drag-placeholder he-tree-drag-placeholder" }, [e._t("placeholder", null, { tree: e.self })], 2)] : e._t("default", function() {
        return [e._v(e._s(o.data[e.textKey]) + " ")];
      }, { node: o.data, stat: o, indentStyle: b, tree: e.self })];
    } }], null, !0) })];
  } }, { key: "append", fn: function() {
    return [e._t("append", null, { tree: e.self })];
  }, proxy: !0 }], null, !0) });
}, Le = [];
const ue = {};
var Be = /* @__PURE__ */ ee(
  Ne,
  ke,
  Le,
  !1,
  Ee
);
function Ee(e) {
  for (let t in ue)
    this[t] = ue[t];
}
const Fe = /* @__PURE__ */ function() {
  return Be.exports;
}();
let a = null, n = null, K, H, I, W, Z, C, Q;
const qe = {
  get startInfo() {
    return K;
  },
  get targetInfo() {
    return H;
  },
  get dragNode() {
    return C;
  },
  get startTree() {
    return a;
  },
  get targetTree() {
    return n;
  },
  get closestNode() {
    return Q;
  }
}, $e = z({
  extends: Fe,
  props: {
    triggerClass: { type: [String, Array] },
    disableDrag: Boolean,
    disableDrop: Boolean,
    eachDraggable: {
      type: Function
    },
    eachDroppable: {
      type: Function
    },
    rootDroppable: {
      type: [Boolean, Function],
      default: !0
    },
    /**
     * open closed node when drag over
     */
    dragOpen: { type: Boolean, default: !0 },
    dragOpenDelay: { type: Number, default: 0 },
    /**
     * e.g.: you can load children by ajax in the hook
     */
    beforeDragOpen: { type: Function },
    resolveStartMovePoint: {
      type: [String, Function]
    },
    /**
     * if remove placeholder when drag leave a tree
     */
    keepPlaceholder: { type: Boolean },
    /**
     * prevent drop if greater than maxLevel
     */
    maxLevel: { type: Number },
    /**
     * copy when drag
     */
    dragCopy: { type: Boolean },
    /**
     * return new data when drag copy
     */
    dragCopyDataHandler: {
      type: Function
    },
    onExternalDragOver: {
      type: Function
    },
    externalDataHandler: {
      type: Function
    },
    // hook of event HTML5 Drag and Drop API's dragstart event
    ondragstart: {
      type: Function
    }
  },
  data() {
    return {
      treeDraggableInstance: null
    };
  },
  computed: {},
  methods: {
    getNodeByElement(e) {
      const t = e.getAttribute("vt-index");
      return t == null ? null : this.visibleStats[t];
    },
    isDraggable(e) {
      if (this.disableDrag)
        return !1;
      if (e.draggable != null)
        return e.draggable;
      if (this.eachDraggable) {
        const r = this.eachDraggable(e);
        if (r != null)
          return r;
      }
      const { parent: t } = e;
      return t ? this.isDraggable(t) : !0;
    },
    isDroppable(e) {
      if (this.disableDrop)
        return !1;
      if (!e)
        return f.resolveValueOrGettter(this.rootDroppable, [this, a]);
      if (e.droppable != null)
        return e.droppable;
      if (this.eachDroppable) {
        const r = this.eachDroppable(e);
        if (r != null)
          return r;
      }
      const { parent: t } = e;
      return t ? this.isDroppable(t) : !0;
    },
    _eachDroppable() {
      var e;
      return f.resolveValueOrGettter((e = this._isDragCopy) == null ? void 0 : e.call(this), [this]);
    }
  },
  mounted() {
    const e = (l, s) => {
      let c = !0;
      return a && a !== this && (c = c && this._isMoved), this.table && !this._isDragCopy && (c = c && this._isDragCopy), c && (l.x !== s.x || l.y !== s.y);
    }, t = (l, s) => {
      n.ignoreUpdate(() => {
        if (!n.has(n.placeholderData)) {
          if (n.table) {
            let d = 0;
            const h = n.getRootEl().querySelector("tr");
            if (h)
              for (const {
                value: v
              } of f.iterateAll(h.children))
                f.css(v, "display") !== "none" && (d += v.colSpan || 1);
            d < 1 && (d = 1), n.placeholderColspan = d;
          }
          n.add(n.placeholderData);
        }
        const c = n.getStat(n.placeholderData);
        n.move(c, l, s);
      });
    }, r = () => {
      const l = this;
      if (l.has(l.placeholderData))
        return l.remove(l.getStat(l.placeholderData)), !0;
    }, i = (l) => {
      l ? P.dropEffect = a != null && a.dragCopy ? "copy" : "move" : P.dropEffect = "none";
    }, o = (l) => {
      const s = this;
      l ? i(!0) : s.keepPlaceholder ? s.has(s.placeholderData) || i(!1) : (r(), i(!1));
    };
    let m = { x: 0, y: 0 };
    const y = this.getRootEl();
    let b = null;
    const x = () => {
      n != null && n.has(n.placeholderData) && n.ignoreUpdate(() => {
        n.remove(n.getStat(n.placeholderData)), a && (a.dragNode.hidden = !1, a.dragOvering = !1);
      });
    };
    this.treeDraggableInstance = me(y, {
      beforeDragStart: (l) => {
        if (!P.triggerElement)
          return;
        let s = this.triggerClass;
        (!s || s.length === 0) && (s = "tree-node");
        let c = f.toArrayIfNot(s), d = f.findParent(
          P.triggerElement,
          (h) => {
            if (f.hasClassIn(h, c))
              return !0;
            if (f.hasClass(h, "tree-node"))
              return "break";
          },
          { withSelf: !0, until: y }
        );
        if (b = f.findParent(
          d,
          (h) => {
            if (f.hasClass(h, "tree-node"))
              return !0;
          },
          { withSelf: !0, until: y }
        ), !!b) {
          if (C = this.getNodeByElement(b), !C)
            throw "Can't find drag node";
          if (this.isDraggable(C))
            return this.$emit("before-drag-start", C), this.$emit("beforeDragStart", C), y;
        }
      },
      onDragStart: (l) => {
        var h, v, u;
        if (!b || !C)
          return;
        {
          const { x: g, y: w } = b.getBoundingClientRect(), { clientX: D, clientY: B } = l;
          (h = l.dataTransfer) == null || h.setDragImage(
            b,
            D - g,
            B - w
          );
        }
        Z = { x: l.clientX, y: l.clientY }, a = this, a.dragNode = C, W = (() => {
          if (this.resolveStartMovePoint === "mouse")
            return { x: l.clientX, y: l.clientY };
          if (typeof this.resolveStartMovePoint == "function")
            return this.resolveStartMovePoint(b);
          {
            let g, w = 0;
            if (this.table) {
              let D = b.getBoundingClientRect();
              g = { x: D.x, y: D.y }, this.rtl && (g.x = D.right), w = D.height;
            } else if (!this.rtl)
              g = b.children[0].getBoundingClientRect().toJSON(), w = g.height;
            else {
              const D = b.children[0].getBoundingClientRect();
              g = {
                x: D.right,
                y: D.y
              }, w = D.height;
            }
            return this.btt && (g.y += w), g;
          }
        })(), this.dragOvering = !0;
        const c = a.getSiblings(a.dragNode), d = c.indexOf(C);
        K = {
          tree: a,
          dragNode: C,
          parent: C.parent,
          siblings: c,
          indexBeforeDrop: d
        }, n = this, (v = l.dataTransfer) == null || v.setData(
          "text",
          `he-tree drag start at ${(/* @__PURE__ */ new Date()).toISOString()}`
        ), a._eachDroppable() || setTimeout(() => {
          C.hidden = !0, t(C.parent, d + 1);
        }, 0), (u = this.ondragstart) == null || u.call(this, l);
      },
      // onDragEnter, onDragLeave, onDragOver, onDrop execute on target tree
      onEnter: (l) => {
        this.$emit("enter", l);
      },
      onLeave: (l) => {
        I = null, this.dragOvering = !1, P.preventDefault = !1, r(), this.$emit("leave", l);
      },
      onDragOver: f.applyFinally(
        (l) => {
          if (!a) {
            if (!this.onExternalDragOver || this.onExternalDragOver(l) === !1)
              return;
            P.preventDefault = !0;
          }
          const s = { x: l.clientX, y: l.clientY }, c = e(s, m);
          if (m = s, !c)
            return;
          this.dragOvering = !0, n = this;
          const d = W ? {
            x: W.x + (s.x - Z.x),
            y: W.y + (s.y - Z.y)
          } : { ...s }, { btt: h, rtl: v } = n;
          if (n.disableDrop) {
            P.dropEffect = "none";
            return;
          }
          let u, g;
          const w = n.getRootEl().querySelectorAll(".tree-node"), D = [];
          w.forEach((p) => {
            !f.hasClassIn(p, [
              "drag-placeholder-wrapper",
              "dragging-node"
            ]) && f.css(p, "display") !== "none" && D.push(p);
          });
          const B = f.binarySearch(
            D,
            (p) => f.getBoundingClientRect(p)[h ? "bottom" : "top"] - d.y,
            { returnNearestIfNoHit: !0 }
          );
          let _ = null, F, X;
          B.hit || (B.greater ? h || (_ = B.index - 1, D[_] || _++) : h && (_ = B.index + 1, D[_] || _--)), _ == null && (_ = B.index), F = D[_], X = h ? D[_ - 1] : D[_ + 1], u = F && n.getNodeByElement(F), g = X && n.getNodeByElement(X);
          const { indent: T } = n, k = f.cacheFunction(() => {
            if (n.table) {
              let p = f.getBoundingClientRect(F).toJSON();
              const N = T * (u.level - 1);
              return v ? (p.width -= N, p.right -= N) : p.x += N, p;
            } else
              return f.getBoundingClientRect(F.firstElementChild);
          }).action, te = f.cacheFunction(() => h ? d.y > k().y + k().height / 2 : d.y < k().y + k().height / 2).action, he = f.cacheFunction(() => h ? !F || _ === D.length - 1 && te() : !F || _ === 0 && te()).action, re = f.cacheFunction(
            () => v ? d.x - (k().x + k().width) : k().x - d.x
          ).action, pe = f.cacheFunction(
            () => v ? d.x < k().x + k().width - T : d.x > k().x + T
          ).action;
          let E;
          if (he())
            E = 1, u = null;
          else if (u)
            re() > 0 ? E = u.level - Math.ceil(re() / T) : pe() ? E = u.level + 1 : E = u.level;
          else return;
          g && E < g.level && (E = g.level), (async () => {
            let p, N, $ = !1, R = null;
            const M = async (S) => {
              if (S.open)
                return !0;
              if (n.dragOpen)
                if (n.dragOpenDelay)
                  if (R = S, I === S)
                    $ = !0;
                  else {
                    let L = f.promisePin();
                    I = S;
                    const V = S;
                    return setTimeout(async () => {
                      V !== I ? ($ = !0, L.resolve(!0)) : (n.beforeDragOpen && await n.beforeDragOpen(S), V !== I ? ($ = !0, L.resolve(!0)) : (S.open = !0, R = null, L.resolve(!0)));
                    }, n.dragOpenDelay), await L.promise;
                  }
                else
                  return n.beforeDragOpen && await n.beforeDragOpen(S), S.open = !0, !0;
              else
                return !1;
            }, U = async () => {
              if (n.isDroppable(u) && await M(u)) {
                if ($)
                  return;
                p = u, N = null;
              } else
                return !1;
            }, ne = (S = E) => {
              let L = u, V = [];
              for (; L && L.level >= S; )
                L = L.parent || null, V.unshift(L);
              let le = 0;
              for (const ie of V) {
                if (n.isDroppable(ie))
                  return p = ie, N = V[le + 1] || u, !0;
                le++;
              }
              return !1;
            };
            Q = u || null, u ? E > u.level ? await U() === !1 && ne(u.level) : ne() === !1 && await U() : n.isDroppable(null) && (p = null), I = R;
            const ae = !!(!$ && (p || p === null));
            return {
              cancelled: $,
              success: ae,
              parent: p,
              index: ae ? N ? (p ? p.children : n.stats).filter((S) => S.data !== n.placeholderData).indexOf(N) + 1 : 0 : -1
            };
          })().then((p) => {
            if (!p.cancelled) {
              if (!p.success) {
                o(!1);
                return;
              }
              if (n.maxLevel != null && n.maxLevel > 0) {
                let N = 1;
                if (a) {
                  const R = a.dragNode;
                  let M = 0;
                  f.walkTreeData(
                    R,
                    (U) => {
                      U.level > M && (M = U.level);
                    },
                    {
                      childrenKey: se
                    }
                  ), N = M - R.level + 1;
                }
                if (N + (p.parent ? p.parent.level : 0) > n.maxLevel) {
                  o(!1);
                  return;
                }
              }
              o(!0), t(p.parent, p.index);
            }
          });
        },
        () => {
        }
      ),
      onDrop: (l) => {
        n = this;
        const s = !a;
        if (!n)
          return;
        const c = a == null ? void 0 : a.dragNode;
        let d, h = (() => {
          var u;
          let v = !0;
          if (!n.has(n.placeholderData))
            v = !1;
          else if (s)
            d = (u = this.externalDataHandler) == null ? void 0 : u.call(this, l), v = d != null;
          else if (!a.dragCopy) {
            const g = n.getStat(
              n.placeholderData
            );
            a === n && g.parent === c.parent && (f.findTreeData(c, (w) => w === g), se);
          }
          return v;
        })();
        if (h) {
          const v = n.getStat(n.placeholderData), u = n.getSiblings(v);
          H = {
            tree: n,
            dragNode: c,
            parent: v.parent,
            siblings: u,
            indexBeforeDrop: u.indexOf(v)
          };
        }
        (() => {
          if (x(), h) {
            let v = H.indexBeforeDrop;
            a && !a.dragCopy && a === n && K.parent == H.parent && K.indexBeforeDrop < v && v--, a && a !== n && !a._eachDroppable() && a.batchUpdate(() => {
              a.remove(c), a.updateCheck();
            }), n.batchUpdate(() => {
              let u = a == null ? void 0 : a.dragNode, g;
              d ? g = d : a._eachDroppable() && (g = f.cloneTreeData(a.dragNode.data, {
                childrenKey: a.childrenKey
              }), a.dragCopyDataHandler && (g = a.dragCopyDataHandler(g))), g && (n.add(g), u = n.getStat(g)), n.move(u, H.parent, v), n.updateCheck();
            });
          }
          n.$emit("after-drop"), h && (a && (a.dragCopy || a.$emit("change")), n !== a && n.$emit("change"));
        })();
      },
      onDragEnd: (l) => {
        x(), a && (a.dragNode && (a.dragNode.hidden = !1), a.dragNode = null, a.dragOvering = !1, a = null), n = null, I = null, C = null, Q = null;
      }
    });
  },
  unmounted() {
    var e;
    (e = this.treeDraggableInstance) == null || e.destroy();
  }
}), Pe = z({
  props: {
    open: { type: Boolean }
  }
});
var Ie = function() {
  var e = this, t = e.$createElement, r = e._self._c || t;
  return r("a", { staticClass: "he-tree__open-icon", class: { open: e.open } }, [r("svg", { attrs: { xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 24 24" } }, [r("title", [e._v("chevron-right")]), r("path", { attrs: { d: "M8.59,16.58L13.17,12L8.59,7.41L10,6L16,12L10,18L8.59,16.58Z" } })])]);
}, Re = [];
const fe = {};
var Ve = /* @__PURE__ */ ee(
  Pe,
  Ie,
  Re,
  !1,
  Me
);
function Me(e) {
  for (let t in fe)
    this[t] = fe[t];
}
const Ye = /* @__PURE__ */ function() {
  return Ve.exports;
}();
function Ge(e, t) {
  try {
    return {
      mixins: [$e],
      created: new Function(Ue(e, t))()
    };
  } catch {
    throw new Error("he-tree-pro: wrong secret key");
  }
}
function Ue(e, t) {
  e = encodeURIComponent(e), e.length % 2 === 1 && (e += "h"), e = e.split("").reverse().join(""), t = atob(t);
  for (let r = 0; r < e.length; r += 2) {
    const i = e[r], o = e[r + 1];
    t = He(t, i, o);
  }
  return Te(
    "arb=inowc=ocmet;etrnfucton){are=1,=tistr{evod !=b}ath(){e&(c_htreWtemak=)=e,._sMve=(=>._eteeatrmrkd.israCoy=)=d.abe,._acDrppbl=(=>.dagop)}",
    t
  );
}
function He(e, t, r) {
  let i = "";
  for (let o = 0; o < e.length; o++) {
    const m = e[o];
    m === t ? i += r : m === r ? i += t : i += m;
  }
  return i;
}
function Te(e, t) {
  let r = 0, i = "";
  for (; ; ) {
    let o;
    if (o = r, o >= t.length || (i += t[o], o = r * 2, o >= e.length) || (i += e[o], o += 1, o >= e.length))
      break;
    i += e[o], r++;
  }
  return i;
}
export {
  Fe as BaseTree,
  $e as Draggable,
  Ye as OpenIcon,
  Oe as TreeNode,
  qe as context,
  qe as dragContext,
  Ge as pro,
  Qe as walkTreeData
};
