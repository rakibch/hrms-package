import { defineComponent as J, ref as I, computed as s, reactive as re, watch as ie, onMounted as oe, nextTick as W } from "vue-demi";
import * as p from "helper-js";
import { openBlock as k, createElementBlock as w, renderSlot as u, createElementVNode as ae, resolveComponent as se, normalizeStyle as M, createVNode as ue, withCtx as P, Fragment as G, renderList as D } from "vue";
/*!
 * @virtual-list/vue
 * Author: phphe <phphe@outlook.com> (https://github.com/phphe)
 * Homepage: https://virtual-list.phphe.com
 * Released under the MIT License.
 */
const ce = J({
  props: {
    table: Boolean
  }
}), Q = (e, i) => {
  const m = e.__vccOpts || e;
  for (const [d, v] of i)
    m[d] = v;
  return m;
}, de = { key: 0 }, fe = { key: 1 };
function me(e, i, m, d, v, z) {
  return e.table ? (k(), w("table", de, [
    u(e.$slots, "prepend"),
    ae("tbody", null, [
      u(e.$slots, "default")
    ]),
    u(e.$slots, "append")
  ])) : (k(), w("div", fe, [
    u(e.$slots, "prepend"),
    u(e.$slots, "default"),
    u(e.$slots, "append")
  ]));
}
const ve = /* @__PURE__ */ Q(ce, [["render", me]]), be = J({
  components: { VirtualListTable: ve },
  props: {
    items: Array,
    disabled: Boolean,
    horizontal: Boolean,
    firstRender: { type: Number, default: 10 },
    buffer: { type: Number, default: 100 },
    itemKey: {
      type: [String, Function]
    },
    itemSize: {
      type: Function
    },
    table: Boolean
  },
  setup(e) {
    const i = I(0), m = I(e.firstRender - 1), d = s(
      () => {
        var t;
        return p.notGreaterThan(m.value, (((t = e.items) == null ? void 0 : t.length) || 1) - 1);
      }
    ), v = I(0), z = s(() => f.value[i.value] ? E(i.value) : 0), C = s(
      () => f.value.length > 0 ? E(f.value.length - 1) + p.arrayLast(L.value) : 0
    ), o = s(
      () => f.value[d.value] ? C.value - E(d.value) - L.value[d.value] : 0
    ), b = s(
      () => e.disabled ? {} : { overflow: "auto" }
    ), U = s(() => {
      const t = {
        display: "flex"
      };
      return e.disabled || (e.horizontal ? Object.assign(t, {
        "margin-left": z.value + "px",
        "margin-right": o.value + "px",
        width: C.value - o.value - z.value + "px"
      }) : Object.assign(t, {
        "margin-top": z.value + "px",
        "margin-bottom": o.value + "px"
      })), t["flex-direction"] = e.horizontal ? "row" : "column", e.table && (delete t.display, delete t["flex-direction"]), t;
    }), $ = s(
      () => re((e.items || []).map(() => null))
    ), L = s(
      () => (e.items || []).map((t, n) => {
        var g;
        if ($[n] != null)
          return $[n];
        let l = (g = e.itemSize) == null ? void 0 : g.call(e, t, n);
        return l == null && (l = v.value), l;
      })
    ), f = s(() => {
      const t = [];
      return L.value.reduce((n, l) => (t.push(n), n + l), 0), t;
    });
    ie(() => e.items, y);
    const X = s(() => {
      if (!e.items || e.disabled)
        return;
      const t = [];
      for (let n = i.value; n <= d.value; n++) {
        const l = e.items[n];
        if (!l)
          break;
        t.push({ item: l, index: n });
      }
      return t;
    }), N = I(), V = I();
    oe(async () => {
      y();
      try {
        Z();
      } catch {
        await W(), y();
      }
    });
    let T;
    function Y() {
      const t = N.value;
      if (!t)
        return;
      const n = O(t);
      T != null && e.buffer - Math.abs(n - T) >= 10 || (T = n, y());
    }
    let B = !1, K = !1;
    async function y() {
      var H;
      if (B) {
        K = !0;
        return;
      }
      if (!e.items || e.disabled)
        return;
      B = !0;
      const t = N.value, n = (H = V.value) == null ? void 0 : H.$el;
      if (!t || !n)
        return;
      v.value || (v.value = ne()), i.value = ee(), m.value = te(), await W();
      let l, g = 0;
      const F = {}, q = e.table ? n.querySelector("tbody").children : n.children;
      for (let a = 0; a < q.length; a++) {
        const r = q[a], c = p.css(r, "position");
        if (c && ["absolute", "fixed"].includes(c))
          continue;
        const h = p.css(r, "display") !== "none" ? A(r) : 0, S = r.getAttribute("vt-index"), R = S ? parseInt(S) : i.value + g;
        F[R] = (F[R] || 0) + h, g++;
      }
      for (const a of Object.keys(F)) {
        const r = parseInt(a);
        $.value[r] !== F[r] && ($.value[r] = F[r], l = !0);
      }
      l && await W(), B = !1, K && (K = !1, y());
      function ee() {
        const a = O(t) - j(t) - e.buffer;
        return p.binarySearch(
          f.value,
          (c) => c - a,
          { returnNearestIfNoHit: !0 }
        ).index;
      }
      function te() {
        const a = O(t) - j(t) + x(t) + e.buffer;
        return p.binarySearch(
          f.value,
          (c) => c - a,
          { returnNearestIfNoHit: !0 }
        ).index;
      }
      function ne() {
        const r = [], c = e.table ? n.querySelector("tbody").children : n.children;
        for (let h = 0; h < c.length; h++) {
          const S = c[h], R = getComputedStyle(S);
          if (["absolute", "fixed"].includes(R.position))
            continue;
          const le = A(S);
          if (r.push(le), r.length >= 10)
            break;
        }
        return r.length === 0 ? 0 : r.reduce((h, S) => h + S, 0) / r.length;
      }
    }
    function x(t) {
      const n = getComputedStyle(t);
      let l = parseFloat(e.horizontal ? n.width : n.height);
      return n.boxSizing === "border-box" && (e.horizontal ? l = l - parseFloat(n.borderLeftWidth) - parseFloat(n.borderRightWidth) : l = l - parseFloat(n.borderTopWidth) - parseFloat(n.borderBottomWidth)), l;
    }
    function A(t) {
      let n = x(t);
      const l = getComputedStyle(t);
      return e.horizontal ? n += parseFloat(l.borderLeftWidth) + parseFloat(l.borderRightWidth) + parseFloat(l.marginLeft) + parseFloat(l.marginRight) : n += parseFloat(l.borderTopWidth) + parseFloat(l.borderBottomWidth) + parseFloat(l.marginTop) + parseFloat(l.marginBottom), n = Number.isNaN(n) ? 0 : n, n;
    }
    function O(t) {
      return e.horizontal ? t.scrollLeft : t.scrollTop;
    }
    function j(t) {
      const n = getComputedStyle(t);
      return e.horizontal ? parseFloat(n.paddingLeft) : parseFloat(n.paddingTop);
    }
    function E(t) {
      return f.value[t];
    }
    function Z() {
      const t = N.value;
      new ResizeObserver((l) => {
        for (let g of l)
          if (p.hasClass(g.target, "vtlist")) {
            y();
            break;
          }
      }).observe(t);
    }
    function _(t, n) {
      if (e.itemKey) {
        if (typeof e.itemKey == "string" && e.itemKey === "index")
          return n;
        if (typeof e.itemKey == "function")
          return e.itemKey(t, n);
      }
    }
    return {
      listElRef: N,
      listInnerRef: V,
      onscroll: Y,
      listStyle: b,
      listInnerStyle: U,
      visibleItemsInfo: X,
      getItemKey: _,
      update: y,
      sizes: L,
      positions: f,
      runtimeSizes: $
    };
  }
});
function ye(e, i, m, d, v, z) {
  const C = se("VirtualListTable");
  return k(), w("div", {
    class: "vtlist",
    ref: "listElRef",
    style: M(e.listStyle),
    onScrollPassive: i[0] || (i[0] = (...o) => e.onscroll && e.onscroll(...o))
  }, [
    ue(C, {
      class: "vtlist-inner",
      ref: "listInnerRef",
      style: M(e.listInnerStyle),
      table: e.table
    }, {
      prepend: P(() => [
        u(e.$slots, "prepend")
      ]),
      append: P(() => [
        u(e.$slots, "append")
      ]),
      default: P(() => [
        e.disabled ? (k(!0), w(G, { key: 0 }, D(e.items, (o, b) => u(e.$slots, "default", {
          key: e.getItemKey(o, b),
          item: o,
          index: b
        })), 128)) : (k(!0), w(G, { key: 1 }, D(e.visibleItemsInfo, ({ item: o, index: b }) => u(e.$slots, "default", {
          key: e.getItemKey(o, b),
          item: o,
          index: b
        })), 128))
      ]),
      _: 3
    }, 8, ["style", "table"])
  ], 36);
}
const Se = /* @__PURE__ */ Q(be, [["render", ye]]);
export {
  Se as default
};
