{"version":3,"file":"index.iife.js","sources":["../../../node_modules/.pnpm/helper-js@3.1.2/node_modules/helper-js/dist/index.esm.js","../../../node_modules/.pnpm/drag-event-service@2.0.0/node_modules/drag-event-service/dist/index.esm.js","../src/index.ts"],"sourcesContent":["/*!\n * helper-js v3.1.2\n * Author: phphe <phphe@outlook.com> (https://github.com/phphe)\n * Homepage: null\n * Released under the MIT License.\n */\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\n\n// ## base functions\n// ## 基础方法\n\n/**\r\n * get global, such as window in browser.\r\n * 返回顶级全局变量. 例如浏览器的`window`\r\n * @returns\r\n */\nfunction glb() {\n  try {\n    // `this` !== global or window because of build tool. So you can't use `this` to get `global`\n    return window;\n  } catch (error) {\n    return global;\n  }\n}\n/**\r\n * detect if global variable `document` existing.\r\n * 判断全局变量`document`是否存在\r\n * @returns\r\n */\n\nfunction isDocumentExisted() {\n  try {\n    let t = document;\n  } catch (e) {\n    return false;\n  }\n\n  return true;\n}\nfunction isArray(v) {\n  return Object.prototype.toString.call(v) === \"[object Array]\";\n}\nfunction isBool(v) {\n  return Object.prototype.toString.call(v) === \"[object Boolean]\";\n}\nfunction isNumber(v) {\n  return Object.prototype.toString.call(v) === \"[object Number]\";\n}\nfunction isNumeric(v) {\n  try {\n    // @ts-ignore\n    return isFinite(v) && !isNaN(parseFloat(v));\n  } catch (error) {\n    return false;\n  }\n}\nfunction isString(v) {\n  return Object.prototype.toString.call(v) === \"[object String]\";\n}\nfunction isObject(v) {\n  return Object.prototype.toString.call(v) === \"[object Object]\";\n}\nfunction isFunction(v) {\n  return typeof v === \"function\";\n}\nfunction isPromise(v) {\n  return Object.prototype.toString.call(v) === \"[object Promise]\";\n}\n/**\r\n * detect if argumrnt is null, undefined, empty array, empty string, false, NaN, empty object\r\n * 检查是否是null, undefined, 空数组, 空字符串, false, NaN, 空对象\r\n * @param v\r\n * @returns\r\n */\n\nfunction empty(v) {\n  if (v == null) {\n    return true;\n  } else if (v[\"length\"] != null) {\n    return v[\"length\"] === 0;\n  } else if (isBool(v)) {\n    return false;\n  } else if (isNumber(v)) {\n    return isNaN(v);\n  } else if (isObject(v)) {\n    return Object.keys(v).length === 0;\n  }\n}\n/**\r\n * rand int in range, including min and max\r\n * 返回指定范围随机整数, 包括范围起始值和终止值\r\n * @param min\r\n * @param max\r\n * @returns\r\n */\n\nfunction randInt(min, max) {\n  return Math.floor(Math.random() * (max - min + 1) + min);\n}\n/**\r\n * rand item in array\r\n * 返回数组随机一项\r\n * @param arr\r\n * @returns\r\n */\n\nfunction randChoice(arr) {\n  return arr[randInt(0, arr.length - 1)];\n}\n/**\r\n * Pad a string to a certain length with another string\r\n * 左边补充指定字符, 使其达到指定长度\r\n * @param str\r\n * @param n\r\n * @param padString\r\n * @returns\r\n */\n\nfunction strPad(str, n) {\n  let padString = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"0\";\n  let r = str.toString();\n  let len = str.toString().length;\n\n  while (len < n) {\n    r = padString + r;\n    len++;\n  }\n\n  if (r.length > n) {\n    r = r.substring(r.length - n);\n  }\n\n  return str;\n}\n/**\r\n * If n less than `min`, return `min`, else n.\r\n * 如果n小于min, 返回min, 否则n.\r\n * @param n\r\n * @param min\r\n * @returns\r\n */\n\nfunction notLessThan(n, min) {\n  return n < min ? min : n;\n}\n/**\r\n * If n greater than `max`, return `max`, else n.\r\n * 如果n大于max, 返回max, 否则n.\r\n * @param n\r\n * @param max\r\n * @returns\r\n */\n\nfunction notGreaterThan(n, max) {\n  return n < max ? n : max;\n}\n/**\r\n * limit min and max of value.\r\n * 限制值的最小和最大值.\r\n * @param n\r\n * @param min\r\n * @param max\r\n * @returns\r\n */\n\nfunction between(n, min, max) {\n  return notGreaterThan(notLessThan(n, min), max);\n} // ## string\n// ## 字符串\n\n/**\r\n * 'abc abc' to 'Abc abc'\r\n * @param str\r\n * @returns\r\n */\n\nfunction studlyCase(str) {\n  return str && str[0].toUpperCase() + str.substring(1);\n}\n/**\r\n * To lower case and use `-` as delimiter. example: '-ABC abc_def camelCase-- helloMyFriend' to 'a-b-c-abc-def-camel-case-hello-my-friend'\r\n * @param str\r\n * @returns\r\n */\n\nfunction kebabCase(str) {\n  return str.replace(/ /g, \"-\").replace(/_/g, \"-\").replace(/(?<=[a-z])([A-Z])/g, \"-$1\").replace(/--+/g, \"-\").replace(/^-|-$|/g, \"\").toLowerCase();\n}\n/**\r\n * To lower case and use `_` as delimiter.\r\n * @param str\r\n * @returns\r\n */\n\nfunction snakeCase(str) {\n  return kebabCase(str).replace(/-/g, \"_\");\n}\n/**\r\n * 'abc-abc-abc_abc' to 'AbcAbcAbcAbc'\r\n * @param str\r\n * @returns\r\n */\n\nfunction camelCase(str) {\n  const temp = kebabCase(str).split(\"-\");\n\n  for (let i = 1; i < temp.length; i++) {\n    temp[i] = studlyCase(temp[i]);\n  }\n\n  return temp.join(\"\");\n}\n/**\r\n * 'AbcAbcAbcAbc' to ['Abc', 'Abc', 'Abc', 'Abc']\r\n * @param str\r\n * @returns\r\n */\n\nfunction camelToWords(str) {\n  return str.split(/(?<=[a-z])(?=[A-Z])/g);\n}\n/**\r\n * 'abcAbc' to 'Abc Abc'\r\n * @param str\r\n * @returns\r\n */\n\nfunction titleCase(str) {\n  return camelToWords(studlyCase(camelCase(str))).join(\" \");\n}\n/**\r\n * generate random string\r\n * 随机字符串\r\n * @param len default 8\r\n * @param seeds\r\n * @returns\r\n */\n\nfunction randString() {\n  let len = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 8;\n  let seeds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\";\n  let r = \"\";\n\n  for (let i = 0; i < len; i++) {\n    r += randChoice(seeds);\n  }\n\n  return r;\n}\n/**\r\n * reverse a string\r\n * @param str\r\n * @returns\r\n */\n\nfunction reverseString(str) {\n  return str.split(\"\").reverse().join(\"\");\n} // ## Array\n// ## 数组\n\n/**\r\n * remove item from array. return removed count\r\n * 从数组删除项. 返回删除计数\r\n * @param arr\r\n * @param v\r\n * @returns\r\n */\n\nfunction arrayRemove(arr, v) {\n  let index;\n  let count = 0;\n\n  while ((index = arr.indexOf(v)) > -1) {\n    arr.splice(index, 1);\n    count++;\n  }\n\n  return count;\n}\n/**\r\n * remove items from array by sorted indexes. indexes example: [0, 2, 6, 8, 9]\r\n * 通过有序的索引集删除数组项. 索引集例子: [0, 2, 6, 8, 9]\r\n * @param arr\r\n * @param sortedIndexes\r\n */\n\nfunction arrayRemoveBySortedIndexes(arr, sortedIndexes) {\n  for (let i = sortedIndexes.length - 1; i >= 0; i--) {\n    const index = sortedIndexes[i];\n    arr.splice(index, 1);\n  }\n}\n/**\r\n * get item from array by index. index can be negative number\r\n * 通过索引获取数组一项. 支持负值索引.\r\n * @param arr\r\n * @param n\r\n * @returns\r\n */\n\nfunction arrayAt(arr, n) {\n  return arr[n >= 0 ? n : arr.length + n];\n}\n/**\r\n * get first or array\r\n * 返回数组首项\r\n * @param arr\r\n * @returns\r\n */\n\nfunction arrayFirst(arr) {\n  return arr[0];\n}\n/**\r\n * get last of array\r\n * 返回数组末项\r\n * @param arr\r\n * @returns\r\n */\n\nfunction arrayLast(arr) {\n  return arr[arr.length - 1];\n}\n/**\r\n *\r\n * @param arr1\r\n * @param arr2\r\n * @returns [diff1, diff2] diff1: in arr1 not in arr2. diff2: in arr2 not in arr1\r\n */\n\nfunction arrayDiff(arr1, arr2) {\n  const m1 = new Map();\n  const m2 = new Map();\n\n  for (const item of arr1) {\n    const count = m1.has(item) ? m1.get(item) : 0;\n    m1.set(item, count + 1);\n  }\n\n  for (const item of arr2) {\n    const count = m2.has(item) ? m2.get(item) : 0;\n    m2.set(item, count + 1);\n  }\n\n  const r1 = [];\n  const r2 = [];\n  m1.forEach((count, item) => {\n    const diff = count - (m2.has(item) ? m2.get(item) : 0);\n\n    if (diff > 0) {\n      diff === 1 ? r1.push(item) : r1.push(...new Array(diff).fill(item));\n    }\n  });\n  m2.forEach((count, item) => {\n    const diff = count - (m1.has(item) ? m1.get(item) : 0);\n\n    if (diff > 0) {\n      diff === 2 ? r2.push(item) : r2.push(...new Array(diff).fill(item));\n    }\n  });\n  return [r1, r2];\n}\n/**\r\n * like indexOf, get all indexes\r\n * @param strOrArr\r\n * @param item\r\n * @returns\r\n */\n\nfunction indexesOf(strOrArr, item) {\n  let i = 0;\n  const indexes = [];\n\n  while (i < strOrArr.length) {\n    const index = strOrArr.indexOf(item, i);\n\n    if (index === -1) {\n      break;\n    } else {\n      indexes.push(index);\n\n      if (typeof strOrArr === \"string\") {\n        i = index + (item + \"\").length;\n      } else {\n        i = index + 1;\n      }\n    }\n  }\n\n  return indexes;\n}\n/**\r\n * get array item siblings. Example: getArrayItemSiblings(arr, item, [-1, 1]), get previous and next sibling\r\n * 获得数组项的多个同级. 例: getArrayItemSiblings(arr, item, [-1, 1]), 获得前一个和后一个\r\n * @param arr\r\n * @param item\r\n * @param offsets\r\n * @returns\r\n */\n\nfunction getArrayItemSiblingsByOffsets(arr, item, offsets) {\n  const index = arr.indexOf(item);\n\n  if (index === -1) {\n    throw \"item is not in array\";\n  }\n\n  return offsets.map(v => arr[index + v]);\n}\nfunction toArrayIfNot(arrOrNot) {\n  return isArray(arrOrNot) ? arrOrNot : [arrOrNot];\n}\n/**\r\n * Split array every n. n can be getter, which argument is the times.\r\n * 每n个拆分数组. n可以是方法, 参数是第几次分块\r\n * @param arr\r\n * @param n\r\n * @returns\r\n */\n\nfunction splitArray(arr, n) {\n  const r = [];\n\n  if (isFunction(n)) {\n    const getChunkLength = n;\n    let times = 1;\n    let i = 0;\n\n    while (i < arr.length) {\n      const n = getChunkLength(times);\n      const end = i + n;\n      r.push(arr.slice(i, end));\n      i = end;\n      times++;\n    }\n  } else {\n    let i = 0;\n\n    while (i < arr.length) {\n      const end = i + n;\n      r.push(arr.slice(i, end));\n      i = end;\n    }\n  }\n\n  return r;\n}\n/**\r\n * group array by mark\r\n * 计算每项的标识, 通过标识将数组项分组.\r\n * @param arr\r\n * @param getMark\r\n * @returns\r\n */\n\nfunction groupArray(arr, getMark) {\n  const groups = new Map();\n  arr.forEach(v => {\n    const mark = getMark(v);\n\n    if (!groups.has(mark)) {\n      groups.set(mark, []);\n    }\n\n    groups.get(mark).push(v);\n  });\n  return groups;\n}\n/**\r\n * Each item in the new array is unique.\r\n * 新数组每项唯一.\r\n * @param arr\r\n * @param getMark\r\n * @returns\r\n */\n\nfunction arrayDistinct(arr, getMark) {\n  const t = new Set();\n  return arr.filter((v, i) => {\n    const mark = getMark ? getMark(v, i) : v;\n\n    if (!t.has(mark)) {\n      t.add(mark);\n      return true;\n    }\n  });\n}\n/**\r\n * get items from array between 2 indeies. index can be negative\r\n * 从数组获得一个范围内的项. 范围可以为负.\r\n * @param arr\r\n * @param index\r\n * @param endIndex\r\n * @returns\r\n */\n\nfunction arrayBetween(arr, index, endIndex) {\n  if (index < 0) {\n    index += arr.length;\n  }\n\n  if (endIndex < 0) {\n    endIndex += arr.length;\n  }\n\n  return arr.slice(index, endIndex - index + 1);\n}\n/**\r\n * return new array excluding n items from end\r\n * 返回新数组排除末尾n项\r\n * @param arr\r\n * @param n\r\n * @returns\r\n */\n\nfunction arrayWithoutEnd(arr) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  return arr.slice(0, arr.length - n);\n}\n/**\r\n * get one-dimensional array from multidimensional array\r\n * 从多维数组获取一维数组\r\n * @param arr\r\n * @param depth\r\n * @returns\r\n */\n\nfunction arrayFlat(arr) {\n  let depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 10;\n  const r = [];\n\n  const rec = (arr, curentDepth) => {\n    for (const item of arr) {\n      if (isArray(item) && curentDepth < depth) {\n        rec(item, curentDepth + 1);\n      } else {\n        r.push(item);\n      }\n    }\n  };\n\n  rec(arr, 0);\n  return r;\n}\n/**\r\n * simplified array.filter()\r\n * e.g.: arrayFilter(arr, [null, undefined]) equal to arr.filter(v => v!== null && v!== undefined)\r\n * @param arr\r\n * @param without\r\n * @returns\r\n */\n\nfunction arrayFilter(arr, without) {\n  // @ts-ignore\n  return arr.filter(v => without.indexOf(v) > -1);\n}\n/**\r\n * alias of arrayFilter\r\n */\n\nconst arrayWithout = arrayFilter; // ## Object\n// ## 对象\n\n/**\r\n * return JSON.parse(JSON.stringify(obj))\r\n * @param obj\r\n * @returns\r\n */\n\nfunction cloneObject(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}\n/**\r\n * like Array.map\r\n * @param obj\r\n * @param handler\r\n * @returns\r\n */\n\nfunction objectMap(obj, handler) {\n  const r = {};\n  let i = 0;\n\n  for (const key in obj) {\n    r[key] = handler(obj[key], key, i);\n    i++;\n  }\n\n  return r;\n}\nfunction objectOnly(obj, keys) {\n  let keysSet = new Set(keys);\n  const r = {};\n  keysSet.forEach(key => {\n    r[key] = obj[key];\n  });\n  return r;\n}\nfunction objectExcept(obj, keys) {\n  let keysSet = new Set(keys);\n  const r = {};\n\n  for (const key in obj) {\n    if (!keysSet.has(key)) {\n      r[key] = obj[key];\n    }\n  }\n\n  return r;\n}\nfunction* iterateAll(val) {\n  let opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  // opt: {reverse, exclude}\n  if (!opt.reverse) {\n    // @ts-ignore\n    if (val.length != null) {\n      // @ts-ignore\n      for (let i = 0; i < val.length; i++) {\n        const info = {\n          value: val[i],\n          index: i\n        };\n\n        if (!opt.exclude || !opt.exclude(info)) {\n          yield info;\n        }\n      }\n    } else if (isObject(val)) {\n      for (const key of Object.keys(val)) {\n        const info = {\n          value: val[key],\n          key\n        };\n\n        if (!opt.exclude || !opt.exclude(info)) {\n          yield info;\n        }\n      }\n    } else {\n      throw \"Unsupported type\";\n    }\n  } else {\n    // @ts-ignore\n    if (val.length != null) {\n      // @ts-ignore\n      for (let i = val.length - 1; i >= 0; i--) {\n        const info = {\n          value: val[i],\n          index: i\n        };\n\n        if (!opt.exclude || !opt.exclude(info)) {\n          yield info;\n        }\n      }\n    } else if (isObject(val)) {\n      const keys = Object.keys(val);\n      keys.reverse();\n\n      for (const key of keys) {\n        const info = {\n          value: val[key],\n          key\n        };\n\n        if (!opt.exclude || !opt.exclude(info)) {\n          yield info;\n        }\n      }\n    } else {\n      throw \"Unsupported type\";\n    }\n  }\n}\n/**\r\n * like Array.find\r\n * @param list\r\n * @param callback\r\n * @param options\r\n * @returns\r\n */\n\nfunction findAll(list, callback, options) {\n  for (const {\n    value,\n    index\n  } of iterateAll(list, options)) {\n    if (callback(value, index)) {\n      return value;\n    }\n  }\n} // example: objectGet(window, 'document.body.children.0') . source: http://stackoverflow.com/questions/8817394/javascript-get-deep-value-from-object-by-passing-path-to-it-as-string\n// 例: objectGet(window, 'document.body.children.0') . 参考: http://stackoverflow.com/questions/8817394/javascript-get-deep-value-from-object-by-passing-path-to-it-as-string\n\n/**\r\n * example: dotGet(window, 'document.body.children.0')\r\n * @param obj\r\n * @param path\r\n * @param throwError\r\n * @returns\r\n */\n\nfunction dotGet(obj, path, throwError) {\n  const paths = isArray(path) ? path : path.split(\".\");\n  let current = obj;\n\n  try {\n    for (const key of paths) {\n      current = current[key];\n    }\n  } catch (e) {\n    if (throwError) {\n      throw \"Path does not exist\";\n    }\n  }\n\n  return current;\n}\n/**\r\n * example: dotSet(window, 'document.body.children.0', vaue)\r\n */\n\nfunction dotSet(obj, path, value) {\n  const paths = isArray(path) ? path : path.split(\".\");\n  const lastKey = arrayLast(paths);\n  const parent = dotGet(obj, paths.slice(0, paths.length - 1));\n\n  if (!parent) {\n    throw \"Path does not exist\";\n  }\n\n  parent[lastKey] = value;\n}\n/**\r\n * try to delete obj[prop]\r\n * @param obj\r\n * @param prop\r\n * @returns\r\n */\n\nfunction unset(obj, prop) {\n  try {\n    delete obj[prop];\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nfunction assignIfNoKey(obj, key, val) {\n  if (!obj.hasOwnProperty(key)) {\n    obj[key] = val;\n  }\n}\nfunction assignIfKeyNull(obj, key, val) {\n  if (obj[key] == null) {\n    obj[key] = val;\n  }\n}\n/**\r\n * Assign if value different. For assign sensitive, such as Vue.watch.\r\n * @param obj\r\n * @param key\r\n * @param val\r\n */\n\nfunction assignIfDiff(obj, key, val) {\n  if (obj[key] !== val) {\n    obj[key] = val;\n  }\n}\nfunction objectAssignIfNoKey(obj1, obj2) {\n  Object.keys(obj2).forEach(key => {\n    assignIfNoKey(obj1, key, obj2[key]);\n  });\n  return obj1;\n}\nfunction objectAssignIfKeyNull(obj1, obj2) {\n  Object.keys(obj2).forEach(key => {\n    assignIfKeyNull(obj1, key, obj2[key]);\n  });\n  return obj1;\n}\nfunction objectAssignIfDiff(obj1, obj2) {\n  Object.keys(obj2).forEach(key => {\n    assignIfDiff(obj1, key, obj2[key]);\n  });\n  return obj1;\n}\nfunction withoutUndefined(obj) {\n  // @ts-ignore\n  const r = {};\n  Object.keys(obj).forEach(key => {\n    if (obj[key] !== undefined) {\n      r[key] = obj[key];\n    }\n  });\n  return r;\n}\n/**\r\n * proxy a property to another key of this or another object\r\n * @param targetObj\r\n * @param targetKey\r\n * @param sourceObj\r\n * @param sourceKey\r\n */\n\nfunction objectDefineProxyProperty(targetObj, targetKey, sourceObj, sourceKey) {\n  const info = Object.getOwnPropertyDescriptor(sourceObj, sourceKey);\n  Object.defineProperty(targetObj, targetKey, {\n    get() {\n      return sourceObj[sourceKey];\n    },\n\n    set(value) {\n      sourceObj[sourceKey] = value;\n    },\n\n    configurable: true,\n    enumerable: info.enumerable\n  });\n}\n/**\r\n * walk object and change key, value, delete key. return cloned new object.\r\n * 深度遍历对象, 可以改变key, value, 删除key. 返回克隆的新对象.\r\n * @param obj\r\n * @param handler\r\n * return null: don't change anything\r\n * return {delete: true}: delete\r\n * return {key: newKey}: change key\r\n * return {value: newValue}: change value\r\n * return {skip: true}: skip children\r\n * return {stop: true}: stop\r\n * @param limit to prevent circular reference.\r\n * @returns\r\n */\n\nfunction mapObjectTree(obj, handler) {\n  let limit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 10000;\n  let r;\n  let count = 0;\n  const stack = [{\n    value: obj\n  }];\n\n  while (stack.length > 0) {\n    if (count >= limit) {\n      throw \"mapObjectTree: limit(\".concat(limit, \") reached, object may has circular reference\");\n    }\n\n    count++; // @ts-ignore\n\n    const {\n      value,\n      key,\n      parent,\n      newParent\n    } = stack.shift();\n    const t = handler(value, key, parent, newParent);\n\n    const assign = (value, key, canPush) => {\n      if (isArray(value)) {\n        value = [];\n      } else if (isObject(value)) {\n        value = {};\n      }\n\n      if (parent) {\n        if (isArray(newParent) && canPush) {\n          newParent.push(value);\n        } else {\n          newParent[key] = value;\n        }\n      } else {\n        r = value;\n      } // value may changed\n\n\n      return value;\n    };\n\n    let newVal, val, toDelete, stop, skip;\n\n    if (!t) {\n      // no change\n      val = value; // @ts-ignore\n\n      newVal = assign(value, key);\n    } else {\n      const {\n        key: key2,\n        value\n      } = t;\n      val = value; // @ts-ignore\n\n      if (t.delete || key2 === false) {\n        // del\n        toDelete = true;\n      } else if (key2 == null) {\n        // don't change key\n        newVal = assign(value, key, true);\n      } else if (t.hasOwnProperty(\"value\")) {\n        // @ts-ignore\n        newVal = assign(value, key2);\n      }\n\n      ({\n        stop,\n        skip\n      } = t);\n    }\n\n    if (toDelete) {\n      continue;\n    }\n\n    if (skip) {\n      continue;\n    }\n\n    if (stop) {\n      break;\n    }\n\n    if (isArray(val)) {\n      const len = val.length;\n\n      for (let i = 0; i < len; i++) {\n        // @ts-ignore\n        stack.push({\n          value: val[i],\n          key: i,\n          parent: val,\n          newParent: newVal\n        });\n      }\n    } else if (isObject(val)) {\n      Object.keys(val).forEach(key => {\n        // @ts-ignore\n        stack.push({\n          value: val[key],\n          key,\n          parent: val,\n          newParent: newVal\n        });\n      });\n    }\n  }\n\n  return r;\n}\n/**\r\n * [{id: 1}, {id: 2}] to {'1':{id: 1}, '2': {id: 2}}\r\n * @param arr\r\n * @param idKey\r\n * @returns\r\n */\n\nfunction mapObjects(arr, idKey) {\n  const r = {};\n  const len = arr.length;\n\n  for (let i = 0; i < len; i++) {\n    const item = arr[i]; // @ts-ignore\n\n    const id = isFunction(idKey) ? idKey(item, i) : item[idKey];\n    r[id] = item;\n  }\n\n  return r;\n}\n/**\r\n * example: pairRows(users, userProfiles, 'id', 'user_id')\r\n * @param rows1\r\n * @param rows2\r\n * @param key1\r\n * @param key2\r\n * @returns [{row1|null, row2|null},...]\r\n */\n\nfunction joinRows(rows1, rows2, key1, key2, ignoreUnmatched) {\n  if (key2 == null) {\n    // @ts-ignore\n    key2 = key1;\n  }\n\n  const m1 = new Map();\n  const m2 = new Map();\n  const r = [];\n  rows2.forEach((row, index) => {\n    // @ts-ignore\n    const key = typeof key2 === \"function\" ? key2(row, index) : row[key2];\n    m2.set(key, row);\n  });\n  const usedRows2 = new Set();\n  rows1.forEach((row, index) => {\n    // @ts-ignore\n    const key = typeof key1 === \"function\" ? key1(row, index) : row[key1];\n    m1.set(key, row);\n    let row2 = m2.has(key) ? m2.get(key) : null;\n\n    if (m2.has(key) || !ignoreUnmatched) {\n      r.push([row, row2]);\n      usedRows2.add(row2);\n    }\n  });\n\n  if (!ignoreUnmatched) {\n    rows2.forEach((row, index) => {\n      // @ts-ignore\n      typeof key2 === \"function\" ? key2(row, index) : row[key2];\n\n      if (!usedRows2.has(row)) {\n        r.push([null, row]);\n      }\n    });\n  }\n\n  return r;\n}\n/**\r\n * walk tree data by with depth first search. tree data example: `[{children: [{}, {}]}]`\r\n * 深度优先遍历树形数据. 树形数据示例: `[{children: [{}, {}]}]`\r\n * @param obj\r\n * @param handler\r\n * @param opt\r\n */\n\nfunction walkTreeData(obj, handler) {\n  let opt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  opt = objectAssignIfNoKey({ ...opt\n  }, {\n    childrenKey: \"children\"\n  });\n  const {\n    childrenKey\n  } = opt;\n  const rootChildren = isArray(obj) ? obj : [obj]; //\n\n  class StopException {}\n\n  const func = (children, parent, parentPath) => {\n    if (opt.reverse) {\n      children = children.slice();\n      children.reverse();\n    }\n\n    const len = children.length;\n\n    for (let i = 0; i < len; i++) {\n      const item = children[i];\n      const index = opt.reverse ? len - i - 1 : i;\n      const path = parentPath ? [...parentPath, index] : [];\n\n      if (opt.childFirst) {\n        if (item[childrenKey] != null) {\n          func(item[childrenKey], item, path);\n        }\n      }\n\n      const r = handler(item, index, parent, path);\n\n      if (r === false) {\n        // stop\n        throw new StopException();\n      } else if (r === \"skip children\") {\n        continue;\n      } else if (r === \"skip siblings\") {\n        break;\n      }\n\n      if (!opt.childFirst) {\n        if (item[childrenKey] != null) {\n          func(item[childrenKey], item, path);\n        }\n      }\n    }\n  };\n\n  try {\n    func(rootChildren, null, isArray(obj) ? [] : null);\n  } catch (e) {\n    if (e instanceof StopException) ; else {\n      throw e;\n    }\n  }\n}\n/**\r\n * like Array.find\r\n * @param obj\r\n * @param handler return true when found.\r\n * @param opt\r\n * @returns\r\n */\n\nfunction findInfoInTreeData(obj, handler) {\n  let opt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let r;\n  walkTreeData(obj, function () {\n    if (handler(...arguments)) {\n      r = {\n        node: arguments.length <= 0 ? undefined : arguments[0],\n        index: arguments.length <= 1 ? undefined : arguments[1],\n        parent: arguments.length <= 2 ? undefined : arguments[2],\n        path: arguments.length <= 3 ? undefined : arguments[3]\n      };\n      return false;\n    }\n  }, opt);\n  return r;\n}\n/**\r\n * like Array.find\r\n * @param obj\r\n * @param handler return true when found.\r\n * @param opt\r\n * @returns\r\n */\n\nfunction findTreeData(obj, handler) {\n  let opt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const r = findInfoInTreeData(obj, handler, opt);\n  return r === null || r === void 0 ? void 0 : r.node;\n}\nfunction cloneTreeData(root, options) {\n  const opt = {\n    childrenKey: \"children\"\n  };\n\n  if (options) {\n    Object.assign(opt, options);\n  }\n\n  const {\n    childrenKey,\n    nodeHandler\n  } = opt;\n  const td = new TreeData();\n  td.childrenKey = childrenKey;\n  walkTreeData(root, (node, index, parent, path) => {\n    let newNode = Object.assign({}, node);\n\n    if (newNode[childrenKey]) {\n      newNode[childrenKey] = [];\n    }\n\n    if (nodeHandler) {\n      newNode = nodeHandler(newNode, {\n        oldNode: node,\n        index,\n        parent,\n        path\n      });\n    }\n\n    td.set(path, newNode);\n  }, {\n    childrenKey\n  });\n  return td.data;\n} // tree data helpers\n\nclass TreeData {\n  // data = null;\n  constructor() {\n    let data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n    _defineProperty(this, \"data\", void 0);\n\n    _defineProperty(this, \"childrenKey\", \"children\");\n\n    this.data = data;\n  }\n\n  get rootChildren() {\n    const {\n      childrenKey\n    } = this;\n    const {\n      data\n    } = this;\n    return isArray(data) ? data : data[childrenKey];\n  }\n\n  *iteratePath(path) {\n    let opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const {\n      childrenKey,\n      rootChildren\n    } = this;\n\n    if (!opt.reverse) {\n      let prevPath = [];\n      let prevChildren = rootChildren;\n\n      for (const index of path) {\n        const currentPath = [...prevPath, index];\n        const currentNode = prevChildren[index];\n        yield {\n          path: currentPath,\n          node: currentNode\n        };\n        prevPath = currentPath;\n        prevChildren = currentNode[childrenKey];\n      }\n    } else {\n      const list = [...this.iteratePath(path, { ...opt,\n        reverse: false\n      })];\n      list.reverse();\n\n      for (const {\n        path: path0,\n        node\n      } of list) {\n        const path = path0;\n        yield {\n          path,\n          node\n        };\n      }\n    }\n  }\n\n  getFamily(path) {\n    const all = [];\n\n    for (const {\n      node\n    } of this.iteratePath(path)) {\n      all.push(node);\n    }\n\n    return all;\n  }\n\n  get(path) {\n    return arrayLast(this.getFamily(path));\n  }\n\n  getParentAndIndex(path) {\n    const parentPath = path.slice();\n    const index = parentPath.pop();\n    return {\n      parent: this.get(parentPath),\n      index,\n      parentPath\n    };\n  }\n\n  getParent(path) {\n    return this.getParentAndIndex(path).parent;\n  }\n\n  set(path, node) {\n    if (path == null || path.length === 0) {\n      this.data = node;\n    } else {\n      const {\n        childrenKey\n      } = this;\n      let {\n        rootChildren\n      } = this;\n      const {\n        parent,\n        index\n      } = this.getParentAndIndex(path);\n      let parentChildren;\n\n      if (path.length === 1) {\n        // fix data\n        if (!rootChildren) {\n          if (this.data) {\n            this.data[childrenKey] = [];\n          } else {\n            this.data = [];\n          }\n        }\n\n        parentChildren = rootChildren;\n      } else {\n        if (!parent[childrenKey]) {\n          parent[childrenKey] = [];\n        }\n\n        parentChildren = parent[childrenKey];\n      }\n\n      parentChildren[index] = node;\n    }\n  }\n\n  delete(path) {\n    const {\n      childrenKey,\n      rootChildren\n    } = this;\n    const {\n      parent,\n      index\n    } = this.getParentAndIndex(path);\n    const parentChildren = path.length === 1 ? rootChildren : parent[childrenKey];\n    const node = parentChildren[index];\n    parentChildren.splice(index, 1);\n    return node;\n  }\n\n  walk(handler, opt) {\n    const {\n      childrenKey,\n      data\n    } = this; // @ts-ignore\n\n    return walkTreeData(data, handler, childrenKey, opt);\n  }\n\n  clone() {\n    let opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return cloneTreeData(this.data), withoutUndefined({\n      childrenKey: this.childrenKey,\n      nodeHandler: opt.nodeHandler || undefined\n    });\n  }\n\n} // ## function\n// ## 函数\n\n/**\r\n * if it is function, return result, else return it directly.\r\n * @param valueOrGetter\r\n * @param args\r\n * @returns\r\n */\n\nfunction resolveValueOrGettter(valueOrGetter) {\n  let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n  if (isFunction(valueOrGetter)) {\n    return valueOrGetter(...args);\n  } else {\n    return valueOrGetter;\n  }\n}\n/**\r\n * add executed count as first argument of func\r\n * 增加执行次数作为方法的第一个参数\r\n * @param func\r\n * @returns\r\n */\n\nfunction executeWithCount(func) {\n  let count = 0;\n\n  function wrapper() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    // @ts-ignore\n    return func.call(this, count++, ...args);\n  }\n\n  return wrapper;\n}\n/**\r\n * (getVal, handler) => update . when execute update, call getVal and check if changed.\r\n * (getVal, handler) => update . 执行update时, 调用getVal并检查结果是否改变.\r\n * @param getVal\r\n * @param handler\r\n * @returns\r\n */\n\nfunction watchChange(getVal, handler) {\n  let oldVal;\n\n  const update = function () {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    // @ts-ignore\n    const newVal = getVal(...args);\n\n    if (oldVal !== newVal) {\n      // @ts-ignore\n      handler(newVal, ...args);\n    }\n\n    oldVal = newVal;\n  };\n\n  return update;\n}\nfunction debounceTrailing(action) {\n  let wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let t;\n  let lastArgs; // when trailing, use last args\n\n  let resolves = [];\n  let rejects = [];\n\n  const wrappedAction = function () {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    return new Promise((resolve, reject) => {\n      resolves.push(resolve);\n      rejects.push(reject); //\n\n      lastArgs = args;\n\n      if (t) {\n        clearTimeout(t);\n      }\n\n      t = setTimeout(() => {\n        // @ts-ignore\n        const result = action.call(this, ...lastArgs);\n        t = null;\n        resolves.forEach(resolve => resolve(result));\n        resolves = [];\n        rejects = [];\n      }, wait);\n    });\n  };\n\n  const stop = () => {\n    if (t) {\n      clearTimeout(t);\n      t = null;\n    }\n\n    resolves = [];\n    rejects.forEach(reject => reject());\n    rejects = [];\n  }; // @ts-ignore\n\n\n  return {\n    action: wrappedAction,\n    stop\n  };\n}\nfunction debounceImmediate(action) {\n  let wait = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n  let t;\n  let delaying;\n  let result;\n\n  const wrappedAction = function () {\n    return new Promise((resolve, reject) => {\n      if (delaying) {\n        resolve(result);\n      } else {\n        delaying = true; // @ts-ignore\n\n        result = action.call(this, ...lastArgs);\n        resolve(result);\n        t = setTimeout(() => {\n          t = null;\n          delaying = false;\n          result = null;\n        }, wait);\n      }\n    });\n  };\n\n  const stop = () => {\n    if (t) {\n      clearTimeout(t);\n      t = null;\n    }\n\n    delaying = false;\n  }; // @ts-ignore\n\n\n  return {\n    action: wrappedAction,\n    stop\n  };\n}\n/**\r\n * the returned function only accept one argument\r\n * @param funcs\r\n * @returns\r\n */\n\nfunction joinFunctionsByResult(funcs) {\n  let wrappedFunc = funcs[0];\n\n  for (let i = 1; i < funcs.length; i++) {\n    wrappedFunc = join2func(wrappedFunc, funcs[i]);\n  }\n\n  return wrappedFunc;\n\n  function join2func(func1, func2) {\n    return function (arg) {\n      const result1 = func1(arg);\n      return func2(result1);\n    };\n  }\n}\n/**\r\n * apply finally function to a function, execute it after target return, event it error\r\n * 在目标方法结束或出错后执行另一方法\r\n * @param func\r\n * @param finallyFunc\r\n * @returns\r\n */\n\nfunction applyFinally(func, finallyFunc) {\n  const wrapped = function () {\n    let r, e;\n\n    try {\n      r = func(...arguments);\n    } catch (error) {\n      e = error;\n    } finally {\n      finallyFunc();\n    }\n\n    if (!e) {\n      return r;\n    } else {\n      throw e;\n    }\n  }; // @ts-ignore\n\n\n  return wrapped;\n}\n/**\r\n * must pass arguments to `next` manually\r\n * @param funcs\r\n * @returns\r\n */\n\nfunction joinFunctionsByNext(funcs) {\n  let next = () => {};\n\n  for (const {\n    value: func\n  } of iterateAll(funcs, {\n    reverse: true\n  })) {\n    const currentNext = next;\n    next = wrapFuncWithNext(func, currentNext);\n  }\n\n  return next;\n\n  function wrapFuncWithNext(func, next) {\n    return function () {\n      for (var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        args[_key4] = arguments[_key4];\n      }\n\n      return func(next, ...args);\n    };\n  }\n}\n/**\r\n * wrap function, bind context(this).\r\n * @param action\r\n * @param context\r\n * @returns\r\n */\n\nfunction bindContext(action, context) {\n  const wrapped = function () {\n    for (var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n      args[_key5] = arguments[_key5];\n    }\n\n    return action.apply(context, args);\n  }; // @ts-ignore\n\n\n  return wrapped;\n}\n/**\r\n * Cache function return by arguments\r\n * @param func\r\n * @returns\r\n */\n\nfunction cacheFunction(func) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const cachedArgsArr = [];\n  let map;\n  const defaultValue = {};\n  let noArgsCache = defaultValue;\n\n  const wrapped = function () {\n    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n      args[_key6] = arguments[_key6];\n    }\n\n    if (args.length === 0) {\n      if (noArgsCache === defaultValue) {\n        noArgsCache = func();\n      }\n\n      return noArgsCache;\n    }\n\n    if (!map) {\n      map = new ArrayKeyMap();\n    }\n\n    if (!map.has(args)) {\n      map.set(args, func(...args));\n\n      if (options.capacity != null) {\n        cachedArgsArr.push(args);\n        const removed = cachedArgsArr.splice(0, cachedArgsArr.length - options.capacity);\n\n        for (const args of removed) {\n          map.delete(args);\n        }\n      }\n    }\n\n    return map.get(args);\n  };\n\n  const clearCache = () => {\n    map = null;\n    cachedArgsArr.splice(0, cachedArgsArr.length);\n  };\n\n  return {\n    // @ts-ignore\n    action: wrapped,\n    clearCache\n  };\n} // ## promise\n\n/**\r\n * execute promise in sequence\r\n * @param getters\r\n * @param concurrent\r\n * @returns\r\n */\n\nfunction executePromiseGetters(getters) {\n  let concurrent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  let stopped;\n  const promise = new Promise(async function (resolve, reject) {\n    const chunks = splitArray(getters, concurrent);\n    const promises = [];\n\n    for (const chunk of chunks) {\n      const chunkPromises = chunk.map(v => v());\n      promises.push(...chunkPromises);\n      await Promise.all(chunkPromises);\n\n      if (stopped) {\n        break;\n      }\n    }\n\n    Promise.all(promises).then(function () {\n      resolve(...arguments);\n    });\n  });\n  return {\n    promise,\n\n    stop() {\n      stopped = true;\n    }\n\n  };\n}\nfunction promiseTimeout(promise, timeout) {\n  return new Promise((resolve, reject) => {\n    let t, rejected;\n    promise.then(function () {\n      clearTimeout(t);\n      resolve(...arguments);\n    }, function () {\n      if (!rejected) {\n        clearTimeout(t);\n        reject(...arguments);\n      }\n    });\n    t = setTimeout(() => {\n      rejected = true;\n      const e = new Error(\"Promise timeout!\");\n      e.name = \"timeout\";\n      reject(e);\n    }, timeout);\n  });\n}\nfunction promisePin() {\n  let resolve, reject;\n  const promise = new Promise((resolve2, reject2) => {\n    resolve = resolve2;\n    reject = reject2;\n  });\n  return {\n    promise,\n    resolve,\n    reject\n  };\n}\n/**\r\n * warp continuous Promise method, such as mousemove handler\r\n * @param method\r\n * @param opt. strategy 'last': the wrapped method return empty if skipped\r\n */\n\nfunction continuous(method, opt) {\n  // default options\n  if (!opt) {\n    // @ts-ignore\n    opt = {};\n  }\n\n  objectAssignIfNoKey(opt, {\n    strategy: \"every\"\n  });\n  const queue = [];\n  let working = false;\n  const currentCount = {\n    value: 0\n  };\n  return async function () {\n    currentCount.value++;\n    const count = currentCount.value;\n    const done = promisePin();\n\n    for (var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {\n      args[_key7] = arguments[_key7];\n    }\n\n    queue.push({\n      count,\n      args,\n      done\n    });\n\n    if (!working) {\n      working = true;\n      task();\n    }\n\n    return done.promise;\n  };\n\n  async function task() {\n    if (opt.strategy === \"every\") {\n      while (queue.length > 0) {\n        const {\n          count,\n          args,\n          done\n        } = queue.shift();\n        let r = method({\n          count,\n          currentCount\n        }, ...args);\n\n        try {\n          await r;\n        } catch (error) {} finally {\n          done.resolve(r);\n        }\n      }\n    } else if (opt.strategy === \"last\") {\n      let currentIndex = -1;\n\n      while (queue.length > 0 && (currentIndex === -1 || queue.length - 1 > currentIndex)) {\n        currentIndex = queue.length - 1;\n        const item = queue[currentIndex];\n        const {\n          count,\n          args,\n          done\n        } = item;\n        let r = method({\n          count,\n          currentCount\n        }, ...args);\n\n        try {\n          await r;\n        } catch (error) {} finally {\n          done.resolve(r);\n          item.skipped = false;\n        }\n      }\n\n      for (let index = currentIndex - 1; index >= 0; index--) {\n        const item = queue[index]; // skip before last\n\n        if (!item || item.skipped != null) {\n          continue;\n        } else {\n          item.skipped = true; // @ts-ignore\n\n          item.done.resolve();\n        }\n      }\n\n      queue.splice(0, queue.length);\n    }\n\n    if (opt.resetCount) {\n      currentCount.value = 0;\n    }\n\n    working = false;\n  }\n}\nconst promiseContinuous = continuous; // ## url\n\nfunction getUrlParam(par) {\n  // 获取当前URL\n  var local_url = document.location.href; // 获取要取得的get参数位置\n\n  var get = local_url.indexOf(par + \"=\");\n\n  if (get == -1) {\n    return false;\n  } // 截取字符串\n\n\n  var get_par = local_url.slice(par.length + get + 1); // 判断截取后的字符串是否还有其他get参数\n\n  var nextPar = get_par.indexOf(\"&\");\n\n  if (nextPar != -1) {\n    get_par = get_par.slice(0, nextPar);\n  }\n\n  return get_par;\n}\nfunction pathJoin(p1, p2) {\n  if (!p2) {\n    return p1;\n  }\n\n  if (!p1 || p2.match(/^\\w+:/)) {\n    return p2;\n  }\n\n  if (p1 && !p1.endsWith(\"/\")) {\n    p1 = p1 + \"/\";\n  }\n\n  if (p1 && p2.startsWith(\"/\")) {\n    p2 = p2.substring(1);\n  }\n\n  return p1 + p2;\n} // ## dom\n\n/**\r\n * return NodeList if there are multiple top-level nodes\r\n * @param htmlString\r\n * @returns\r\n */\n\nfunction createElementFromHTML(htmlString) {\n  var div = document.createElement(\"div\");\n  div.innerHTML = htmlString.trim();\n\n  if (div.childNodes.length > 1) {\n    return div.childNodes;\n  } else {\n    return div.childNodes[0];\n  }\n}\n/**\r\n * NOT RECOMMEND. Use Node.contains instead.\r\n */\n\nfunction isDescendantOf(el, parent) {\n  while (true) {\n    if (el.parentNode == null) {\n      return false;\n    } else if (el.parentNode === parent) {\n      return true;\n    } else {\n      el = el.parentNode;\n    }\n  }\n}\nfunction pointIn(x, y, element) {\n  const rect = getBoundingClientRect(element);\n  return x >= rect.x && x <= rect.x + rect.width && y >= rect.y && y <= rect.y + rect.height;\n}\nfunction removeEl(el) {\n  if (el.parentNode !== null) {\n    return el.parentNode.removeChild(el);\n  }\n}\n/**\r\n * get page root scroll(body or documentElement). refer: https://stackoverflow.com/questions/871399/cross-browser-method-for-detecting-the-scrolltop-of-the-browser-window\r\n * @returns\r\n */\n\nfunction getScroll() {\n  if (typeof pageYOffset != \"undefined\") {\n    //most browsers except IE before #9\n    return {\n      top: pageYOffset,\n      left: pageXOffset\n    };\n  } else {\n    var B = document.body; //IE 'quirks'\n\n    var D = document.documentElement; //IE with doctype\n\n    D = D.clientHeight ? D : B;\n    return {\n      top: D.scrollTop,\n      left: D.scrollLeft\n    };\n  }\n}\n/**\r\n * relative to page root element(document.documentElement). refer: https://gist.github.com/aderaaij/89547e34617b95ac29d1\r\n * 相对于页面根元素.(document.documentElement)\r\n * @param el\r\n * @returns\r\n */\n\nfunction getOffset(el) {\n  const rect = getBoundingClientRect(el);\n  const t = getBoundingClientRect(document.documentElement);\n  return {\n    x: rect.left - t.left,\n    y: rect.top - t.top\n  };\n}\n/**\r\n * there is some trap in el.offsetParent, so use this func to fix\r\n * @param el\r\n * @returns\r\n */\n\nfunction getOffsetParent(el) {\n  let offsetParent = el.offsetParent;\n\n  if (!offsetParent || offsetParent === document.body && getComputedStyle(document.body).position === \"static\") {\n    offsetParent = document.body.parentElement;\n  }\n\n  return offsetParent;\n}\n/**\r\n * get el current position. like jQuery.position. The position is relative to offsetParent viewport left top. it is for set absolute position, absolute position is relative to offsetParent viewport left top.\r\n * 相对于offsetParent可视区域左上角(el.offsetLeft或top包含父元素的滚动距离, 所以要减去). position一般用于设置绝对定位的情况, 而绝对定位就是以可视区域左上角为原点.\r\n * @param el\r\n * @returns\r\n */\n\nfunction getPosition(el) {\n  const offsetParent = getOffsetParent(el);\n  const ps = {\n    x: el.offsetLeft,\n    y: el.offsetTop\n  };\n  let parent = el;\n\n  while (true) {\n    parent = parent.parentElement;\n\n    if (parent === offsetParent || !parent) {\n      break;\n    }\n\n    ps.x -= parent.scrollLeft;\n    ps.y -= parent.scrollTop;\n  }\n\n  return ps;\n}\n/**\r\n * like jQuery.offset(x, y), but it just return cmputed position, don't update style\r\n * 类似 jQuery.offset的设置功能, 但是它只返回计算的position, 不改变元素样式.\r\n * @param el\r\n * @param of\r\n * @returns\r\n */\n\nfunction getPositionFromOffset(el, of) {\n  const offsetParent = getOffsetParent(el);\n  const parentOf = getOffset(offsetParent);\n  return {\n    x: of.x - parentOf.x,\n    y: of.y - parentOf.y\n  };\n}\n/**\r\n * relative to viewport. like position fixed. alias getViewportPosition\r\n * 相对于视口. 类似 position fixed. 别名 getViewportPosition\r\n * @param el\r\n * @returns\r\n */\n\nfunction getBoundingClientRect(el) {\n  // refer: http://www.51xuediannao.com/javascript/getBoundingClientRect.html\n  let xy = el.getBoundingClientRect();\n\n  if (document.documentElement.clientTop > 0) {\n    const top = xy.top - document.documentElement.clientTop,\n          //document.documentElement.clientTop 在IE67中始终为2，其他高级点的浏览器为0\n    bottom = xy.bottom,\n          left = xy.left - document.documentElement.clientLeft,\n          //document.documentElement.clientLeft 在IE67中始终为2，其他高级点的浏览器为0\n    right = xy.right,\n          width = xy.width || right - left,\n          //IE67不存在width 使用right - left获得\n    height = xy.height || bottom - top;\n    const x = left;\n    const y = top;\n    const json = {\n      top,\n      right,\n      bottom,\n      left,\n      width,\n      height,\n      x,\n      y\n    };\n    xy = { ...json,\n      toJSON: () => json\n    };\n  }\n\n  return xy;\n} // refer [getBoundingClientRect](#getBoundingClientRect)\n\nconst getViewportPosition = getBoundingClientRect;\n/**\r\n * position fixed is not always related to viewport.\r\n * position fixed不总是相对于视口.\r\n * 参考/Check: https://developer.mozilla.org/en-US/docs/Web/CSS/position\r\n * @param el\r\n * @param viewportPosition\r\n */\n\nfunction viewportPositionToFixed(el, viewportPosition) {\n  const div = document.createElement(\"div\");\n  Object.assign(div.style, {\n    position: \"fixed\",\n    visibility: \"hidden\",\n    top: \"0px\",\n    left: \"0px\"\n  });\n  insertAfter(div, el);\n  const divVP = getViewportPosition(div);\n  const offset = {\n    x: 0 - divVP.x,\n    y: 0 - divVP.y\n  };\n  return {\n    x: viewportPosition.x + offset.x,\n    y: viewportPosition.x + offset.y\n  };\n}\nfunction findParent(el, callback) {\n  let opt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let cur = opt && opt.withSelf ? el : el.parentElement;\n\n  while (cur) {\n    const shouldBreak = opt.until && cur === opt.until;\n\n    if (shouldBreak && !opt.withUntil) {\n      return;\n    }\n\n    const r = callback(cur);\n\n    if (r === \"break\") {\n      return;\n    } else if (r) {\n      return cur;\n    } else if (shouldBreak) {\n      return;\n    } else {\n      cur = cur.parentElement;\n    }\n  }\n}\nfunction backupAttr(el, name) {\n  const key = \"original_\".concat(name);\n  el[key] = el.getAttribute(name);\n}\nfunction restoreAttr(el, name) {\n  const key = \"original_\".concat(name);\n  const value = el[key];\n\n  if (value == null) {\n    el.removeAttribute(name);\n  } else {\n    el.setAttribute(name, value);\n  }\n} // source: http://youmightnotneedjquery.com/\n\nfunction hasClass(el, className) {\n  if (el.classList) {\n    return el.classList.contains(className);\n  } else {\n    return new RegExp(\"(^| )\" + className + \"( |$)\", \"gi\").test(el.className);\n  }\n}\n/**\r\n * has all classNames\r\n * @param el\r\n * @param classNames\r\n */\n\nfunction hasClasses(el, classNames) {\n  for (const className of classNames) {\n    if (!hasClass(el, className)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\r\n * has any class in classNames\r\n * @param el\r\n * @param classNames\r\n * @returns\r\n */\n\nfunction hasClassIn(el, classNames) {\n  for (const className of classNames) {\n    if (hasClass(el, className)) {\n      return true;\n    }\n  }\n\n  return false;\n} // source: http://youmightnotneedjquery.com/\n\nfunction addClass(el, className) {\n  const t = toArrayIfNot(className);\n\n  for (const className of t) {\n    if (!hasClass(el, className)) {\n      if (el.classList) {\n        el.classList.add(className);\n      } else {\n        el.className += \" \" + className;\n      }\n    }\n  }\n} // source: http://youmightnotneedjquery.com/\n\nfunction removeClass(el, className) {\n  const t = toArrayIfNot(className);\n\n  for (const className of t) {\n    if (el.classList) {\n      el.classList.remove(className);\n    } else {\n      el.className = el.className.replace(new RegExp(\"(^|\\\\b)\" + className.split(\" \").join(\"|\") + \"(\\\\b|$)\", \"gi\"), \" \");\n    }\n  }\n}\nfunction getElSizeEvenInvisible(el) {\n  backupAttr(el, \"style\");\n  el.style.display = \"block\";\n  const t = getBoundingClientRect(el);\n  const size = {\n    width: t.width,\n    height: t.height\n  };\n  restoreAttr(el, \"style\");\n  return size;\n}\n/**\r\n * [isOffsetInEl]\r\n * @param {Number} x\r\n * @param {Number} y\r\n * @param {Object} el HTML Element\r\n */\n\nfunction isOffsetInEl(x, y, el) {\n  const offset = getOffset(el);\n  return offset.x <= x && offset.x + el.offsetWidth >= x && offset.y <= y && offset.y + el.offsetHeight >= y;\n}\nfunction setElChildByIndex(el, child, index) {\n  // @ts-ignore\n  child.childComponentIndex = index;\n  const len = el.childNodes.length;\n\n  if (len === 0) {\n    el.appendChild(child);\n  } else if (index === 0) {\n    el.insertBefore(child, el.childNodes[0]);\n  } else {\n    const {\n      index: nearestIndex,\n      value: nearest,\n      greater\n    } = binarySearch( // @ts-ignore\n    el.childNodes, el => {\n      return el[\"childComponentIndex\"] - index;\n    }, {\n      start: 0,\n      end: notGreaterThan(index, len - 1),\n      returnNearestIfNoHit: true\n    });\n\n    if (greater) {\n      // @ts-ignore\n      el.insertBefore(child, nearest);\n    } else {\n      const next = el.childNodes[nearestIndex + 1];\n\n      if (next) {\n        el.insertBefore(child, next);\n      } else {\n        el.appendChild(child);\n      }\n    }\n  }\n}\n/**\r\n * listen event on element\r\n * @param el\r\n * @param name\r\n * @param handler\r\n * @param options\r\n */\n\nfunction on(el, name, handler, options) {\n  if (el.addEventListener) {\n    // 所有主流浏览器，除了 IE 8 及更早 IE版本\n    el.addEventListener(name, handler, options); // @ts-ignore\n  } else if (el.attachEvent) {\n    // IE 8 及更早 IE 版本\n    // @ts-ignore\n    el.attachEvent(\"on\".concat(name), handler, options);\n  }\n}\n/**\r\n * cancel event lisitener on element\r\n * @param el\r\n * @param name\r\n * @param handler\r\n * @param options\r\n */\n\nfunction off(el, name, handler, options) {\n  if (el.removeEventListener) {\n    // 所有主流浏览器，除了 IE 8 及更早 IE版本\n    el.removeEventListener(name, handler, options); // @ts-ignore\n  } else if (el.detachEvent) {\n    // IE 8 及更早 IE 版本\n    // @ts-ignore\n    el.detachEvent(\"on\".concat(name), handler, options);\n  }\n}\n/**\r\n * listen event on element once. return destroy function\r\n * @param el\r\n * @param name\r\n * @param handler\r\n * @param options\r\n * @returns destroy\r\n */\n\nfunction once(el, name, handler, options) {\n  const onceHandler = function () {\n    for (var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {\n      args[_key8] = arguments[_key8];\n    }\n\n    // @ts-ignore\n    let r = handler.call(this, ...args); // prettier-ignore\n\n    destroy();\n    return r;\n  };\n\n  on(el, name, onceHandler, options);\n  let destroied = false;\n\n  const destroy = () => {\n    if (!destroied) {\n      off(el, name, onceHandler, options);\n    }\n\n    destroied = true;\n  };\n\n  return destroy;\n}\n/**\r\n * lisiten multi events, and can stop and resume them\r\n * @param info\r\n * @returns\r\n */\n\nfunction extendedListen(info) {\n  let destroyFuncs = [];\n\n  const listenAll = () => {\n    if (r.listening) {\n      return;\n    }\n\n    for (const item of info) {\n      on.apply(this, item);\n\n      const destroy = () => off.apply(this, item);\n\n      destroyFuncs.push(destroy);\n    }\n\n    r.listening = true;\n  };\n\n  const destroyAll = () => {\n    if (!r.listening) {\n      return;\n    }\n\n    for (const destroy of destroyFuncs) {\n      destroy();\n    }\n\n    destroyFuncs = [];\n    r.listening = false;\n  };\n\n  const r = {\n    listening: false,\n    stop: destroyAll,\n    resume: listenAll\n  };\n  return r;\n}\nfunction getImageSizeByUrl(url) {\n  const image = document.createElement(\"img\");\n  return new Promise(function (resolve, reject) {\n    on(image, \"load\", () => {\n      resolve({\n        width: image.width,\n        height: image.height\n      });\n    });\n    on(image, \"error\", e => {\n      reject(e);\n    });\n    image.src = url;\n  });\n}\nfunction elementsFromPoint(x, y) {\n  const args = [x, y];\n  const func = document.elementsFromPoint || // @ts-ignore\n  document.msElementsFromPoint || elementsFromPoint;\n  return func.apply(document, args);\n\n  function elementsFromPoint(x, y) {\n    const parents = [];\n    let parent = void 0;\n\n    do {\n      if (parent !== document.elementFromPoint(x, y)) {\n        parent = document.elementFromPoint(x, y);\n        parents.push(parent);\n        parent.style.pointerEvents = \"none\";\n        parent[\"_pointerEvents_backup\"] = parent.style.pointerEvents;\n      } else {\n        parent = false;\n      }\n    } while (parent);\n\n    parents.forEach(function (parent) {\n      return parent.style.pointerEvents = parent[\"_pointerEvents_backup\"];\n    });\n    return parents;\n  }\n}\nfunction getOuterAttachedHeight(el) {\n  let opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  opt = {\n    margin: true,\n    border: true,\n    ...opt\n  };\n  const stl = getComputedStyle(el);\n  let r = 0;\n  const arr = [];\n\n  if (opt.margin) {\n    arr.push(\"margin-top\", \"margin-bottom\");\n  }\n\n  if (opt.border) {\n    arr.push(\"border-top-width\", \"border-bottom-width\");\n  }\n\n  arr.forEach(key => {\n    r += parseFloat(stl[key]);\n  });\n  return r;\n}\nfunction getOuterAttachedWidth(el) {\n  let opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  opt = {\n    margin: true,\n    border: true,\n    ...opt\n  };\n  const stl = getComputedStyle(el);\n  let r = 0;\n  const arr = [];\n\n  if (opt.margin) {\n    arr.push(\"margin-left\", \"margin-right\");\n  }\n\n  if (opt.border) {\n    arr.push(\"border-left-width\", \"border-right-width\");\n  }\n\n  arr.forEach(key => {\n    r += parseFloat(stl[key]);\n  });\n  return r;\n}\n/**\r\n * like jquery $(el).css(), but only can read\r\n * @param el\r\n * @param name\r\n * @returns\r\n */\n\nfunction css(el, name) {\n  const stl = getComputedStyle(el);\n  return stl[name];\n}\nfunction cssNumber(el, name) {\n  return parseFloat(css(el, name));\n}\nfunction isScrollable(el, direction) {\n  const key = \"overflow\" + direction.toUpperCase();\n  const values = [\"auto\", \"scroll\", \"overlay\"];\n\n  if (el === document.scrollingElement) {\n    values.push(\"visible\");\n  }\n\n  return values.includes(css(el, key));\n}\n/**\r\n * scrollLeft, scrollRight, scrollTop, scrollBottom.\r\n * IMPORTANT! The min value of  scrollRight and scrollBottom may be a float less than 1, not zero.\r\n * 重要! scrollRight和scrollBottom的最小值可能是小于1的小数, 而不是0.\r\n * @param el\r\n * @param direction\r\n * @returns\r\n */\n\nfunction getScrollSpace(el, direction) {\n  let space;\n\n  if (direction === \"left\") {\n    space = el.scrollLeft;\n  } else if (direction === \"top\") {\n    space = el.scrollTop;\n  } else {\n    if (direction === \"right\") {\n      space = el.scrollWidth - el.clientWidth - el.scrollLeft;\n    } else {\n      // bottom\n      space = el.scrollHeight - el.clientHeight - el.scrollTop;\n    }\n  }\n\n  return space;\n}\n/* scroll to a positon with duration\r\nfrom https://gist.github.com/andjosh/6764939\r\ninterface options{\r\n  x: number // nullable. don't scroll horizontally when null\r\n  y: number // nullable. don't scroll vertically when null\r\n  duration: number // default 0\r\n  element: Node // default is the top scrollable element.\r\n  beforeEveryFrame: (count: number) => boolean|void // call before requestAnimationFrame execution. return false to stop\r\n}\r\nreturn stop\r\n*/\n\nfunction scrollTo(options) {\n  if (!options.element) {\n    options.element = document.scrollingElement || document.documentElement;\n  }\n\n  if (options.duration == null) {\n    options.duration = 0;\n  }\n\n  const {\n    x,\n    y,\n    duration,\n    element\n  } = options;\n  let requestAnimationFrameId;\n  let count = 0;\n\n  const startY = element.scrollTop,\n        changeY = y - startY,\n        startX = element.scrollLeft,\n        changeX = x - startX,\n        startDate = +new Date(),\n        animateScroll = function () {\n    if (options.beforeEveryFrame && options.beforeEveryFrame(count) === false) {\n      return;\n    }\n\n    const currentDate = new Date().getTime();\n    const changedTime = currentDate - startDate;\n\n    if (y != null) {\n      element.scrollTop = parseInt(calc(startY, changeY, changedTime, duration));\n    }\n\n    if (x != null) {\n      element.scrollLeft = parseInt(calc(startX, changeX, changedTime, duration));\n    }\n\n    if (changedTime < duration) {\n      requestAnimationFrameId = requestAnimationFrame(animateScroll);\n    } else {\n      if (y != null) {\n        element.scrollTop = y;\n      }\n\n      if (x != null) {\n        element.scrollLeft = x;\n      }\n    }\n\n    count++;\n  };\n\n  const stop = () => {\n    cancelAnimationFrame(requestAnimationFrameId);\n  };\n\n  animateScroll(); // return stop\n\n  return stop;\n\n  function calc(startValue, changeInValue, changedTime, duration) {\n    return startValue + changeInValue * (changedTime / duration);\n  }\n} // ### DOM structure\n\nfunction insertBefore(el, target) {\n  target.parentElement.insertBefore(el, target);\n}\nfunction insertAfter(el, target) {\n  target.parentElement.insertBefore(el, target.nextSibling);\n}\nfunction prependTo(el, target) {\n  target.insertBefore(el, target.firstChild);\n}\nfunction appendTo(el, target) {\n  target.appendChild(el);\n} // ## Date\n\nfunction cloneDate(dateObj) {\n  return new Date(dateObj.getTime());\n} // day and date is same\n\nfunction addDate(dateObj, n, type) {\n  if (![\"year\", \"month\", \"day\", \"date\"].includes(type)) {\n    type += \"s\";\n  }\n\n  let type2 = studlyCase(type);\n\n  if (type2 === \"Day\") {\n    type2 = \"Date\";\n  }\n\n  var setFuncName = \"set\" + type2;\n  var getFuncName = \"get\" + type2;\n  dateObj[setFuncName](dateObj[getFuncName]() + n);\n  return dateObj;\n}\nfunction getMonthStart(dateObj) {\n  const clonedObj = cloneDate(dateObj);\n  clonedObj.setDate(1);\n  return clonedObj;\n}\nfunction getMonthEnd(dateObj) {\n  const r = cloneDate(dateObj);\n  addDate(r, 1, \"month\");\n  r.setDate(0);\n  return r;\n}\n/**\r\n * startWeekDay: 0 is Sunday\r\n * @param year\r\n * @param month\r\n * @param startWeekDay\r\n * @returns [GetCalendarDay x 7][]\r\n */\n\nfunction getCalendar(year, month) {\n  let startWeekDay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  const results = [];\n  const date = new Date(year, month - 1);\n  year = date.getFullYear();\n  month = date.getMonth() + 1;\n  const monthStart = getMonthStart(date);\n  const monthStartDay = monthStart.getDay();\n  const calendarStart = addDate(cloneDate(monthStart), -(monthStartDay + startWeekDay), \"day\");\n\n  if (monthStartDay > startWeekDay) {\n    const startDate = calendarStart.getDate();\n    const year = calendarStart.getFullYear();\n    const month = calendarStart.getMonth() + 1;\n\n    for (let i = startWeekDay; i < monthStartDay; i++) {\n      const date = startDate + i;\n      results.push({\n        year,\n        month,\n        date: date,\n        text: date,\n        prevMonth: true\n      });\n    }\n  } //\n\n\n  const monthEnd = getMonthEnd(date);\n  const monthEndtDate = monthEnd.getDate();\n\n  for (let i = 1; i <= monthEndtDate; i++) {\n    const date = i;\n    results.push({\n      year: year,\n      month: month,\n      date,\n      text: date,\n      currentMonth: true\n    });\n  } //\n\n\n  const monthEndDay = monthEnd.getDay();\n  const endWeekDay = 6 - startWeekDay;\n\n  if (monthEndDay < endWeekDay) {\n    const nextMonth = addDate(cloneDate(date), 1, \"month\");\n    const year = nextMonth.getFullYear();\n    const month = nextMonth.getMonth() + 1;\n\n    for (let i = monthEndDay + 1, date = 1; i <= endWeekDay; i++, date++) {\n      results.push({\n        year: year,\n        month: month,\n        date: date,\n        text: date,\n        nextMonth: true\n      });\n    }\n  } //\n\n\n  return splitArray(results, 7);\n}\n/**\r\n * timezone must be UTC. eg: 2018-09-07T03:38:37.888Z\r\n * @param str\r\n * @returns\r\n */\n\nfunction isIsoFormat(str) {\n  return Boolean(str.length > 15 && str.length < 30 && str.match(/^\\d{4}-\\d{2}-\\d{2}T.*Z$/));\n}\n/**\r\n *\r\n * @param timestamp eg: 2018-09-07T03:38:37.888Z\r\n * @returns\r\n */\n\nfunction parseISO(timestamp) {\n  const [datePart, timePart] = timestamp.split(\"T\");\n  let y,\n      m,\n      d,\n      h = 0,\n      min = 0,\n      s = 0;\n  [y, m, d] = datePart.split(\"-\").map(v => parseInt(v));\n  m = m - 1;\n\n  if (timePart) {\n    const t = timePart.split(\":\").map(v => parseFloat(v));\n    h = t[0];\n\n    if (t[1] != null) {\n      min = t[1];\n    }\n\n    if (t[2] != null) {\n      s = t[2];\n    }\n  }\n\n  const dt = new Date();\n  dt.setUTCFullYear(y);\n  dt.setUTCMonth(m);\n  dt.setUTCDate(d);\n  dt.setUTCHours(h);\n  dt.setUTCMinutes(min);\n  dt.setUTCSeconds(s);\n  return dt;\n}\n/**\r\n * binarySearch, 二分查找\r\n * @param arr\r\n * @param callback return `mid - your_value` for ascending array\r\n * @param opt\r\n * @returns\r\n */\n\nfunction binarySearch(arr, callback) {\n  let opt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  opt = {\n    start: 0,\n    end: arr.length - 1,\n    maxTimes: 1000,\n    ...opt\n  };\n  let {\n    start,\n    end\n  } = opt;\n  const {\n    returnNearestIfNoHit,\n    maxTimes\n  } = opt;\n  let midNum;\n  let mid;\n\n  if (start == null) {\n    start = 0;\n    end = arr.length - 1;\n  }\n\n  let i = 0;\n  let r;\n\n  while (start >= 0 && start <= end) {\n    if (i >= maxTimes) {\n      throw Error(\"binarySearch: loop times is over \".concat(maxTimes, \", you can increase the limit.\"));\n    }\n\n    midNum = Math.floor((end - start) / 2 + start);\n    mid = arr[midNum];\n    const count = i + 1;\n    r = callback(mid, midNum, count);\n\n    if (r > 0) {\n      end = midNum - 1;\n    } else if (r < 0) {\n      start = midNum + 1;\n    } else {\n      return {\n        index: midNum,\n        value: mid,\n        count,\n        hit: true\n      };\n    }\n\n    i++;\n  }\n\n  return returnNearestIfNoHit ? {\n    index: midNum,\n    value: mid,\n    count: i + 1,\n    hit: false,\n    greater: r > 0\n  } : null;\n} //\n\nfunction windowLoaded() {\n  return new Promise(function (resolve, reject) {\n    if (document && document.readyState === \"complete\") {\n      resolve();\n    } else {\n      window.addEventListener(\"load\", function once() {\n        resolve();\n        window.removeEventListener(\"load\", once);\n      });\n    }\n  });\n}\nfunction waitTime(milliseconds, callback) {\n  return new Promise(function (resolve, reject) {\n    setTimeout(function () {\n      callback && callback();\n      resolve();\n    }, milliseconds);\n  });\n}\nfunction waitFor(condition) {\n  let time = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 100;\n  let maxTimes = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1000;\n  let interval;\n  const promise = new Promise(function (resolve, reject) {\n    let count = 0;\n\n    function judge() {\n      if (count <= maxTimes) {\n        if (condition()) {\n          stop();\n          resolve();\n        }\n      } else {\n        stop();\n        reject(new Error(\"waitFor: Limit is reached\"));\n      }\n\n      count++;\n    }\n\n    interval = setInterval(function () {\n      judge();\n    }, time);\n    judge();\n  });\n  return {\n    promise,\n    stop\n  };\n\n  function stop() {\n    clearInterval(interval);\n  }\n}\nasync function retry(action) {\n  let limitTimes = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 3;\n\n  for (let index = 1; index <= limitTimes; index++) {\n    try {\n      // @ts-ignore\n      return await action();\n    } catch (error) {\n      if (index === limitTimes) {\n        throw error;\n      }\n    }\n  }\n}\n/**\r\n * Copy to text to clipboard. Async not supported. Recommend clipboard-polyfill.\r\n * 复制文字到剪贴板. 仅限于简单使用, 不支持异步. 复杂环境推荐clipboard-polyfill\r\n * @param text\r\n * @returns\r\n */\n\nfunction copyTextToClipboard(text) {\n  try {\n    // use latest api\n    navigator.clipboard.writeText(text);\n    return;\n  } catch (e) {}\n\n  var textArea = document.createElement(\"textarea\"); //\n  // *** This styling is an extra step which is likely not required. ***\n  //\n  // Why is it here? To ensure:\n  // 1. the element is able to have focus and selection.\n  // 2. if element was to flash render it has minimal visual impact.\n  // 3. less flakyness with selection and copying which **might** occur if\n  //    the textarea element is not visible.\n  //\n  // The likelihood is the element won't even render, not even a flash,\n  // so some of these are just precautions. However in IE the element\n  // is visible whilst the popup box asking the user for permission for\n  // the web page to copy to the clipboard.\n  //\n  // Place in top-left corner of screen regardless of scroll position.\n\n  textArea.style.position = \"fixed\";\n  textArea.style.top = \"0\";\n  textArea.style.left = \"0\"; // Ensure it has a small width and height. Setting to 1px / 1em\n  // doesn't work as this gives a negative w/h on some browsers.\n\n  textArea.style.width = \"2em\";\n  textArea.style.height = \"2em\"; // We don't need padding, reducing the size if it does flash render.\n\n  textArea.style.padding = \"0\"; // Clean up any borders.\n\n  textArea.style.border = \"none\";\n  textArea.style.outline = \"none\";\n  textArea.style.boxShadow = \"none\"; // Avoid flash of white box if rendered for any reason.\n\n  textArea.style.background = \"transparent\";\n  textArea.value = text;\n  document.body.appendChild(textArea);\n  textArea.select();\n\n  try {\n    var successful = document.execCommand(\"copy\");\n    var msg = successful ? \"successful\" : \"unsuccessful\";\n    console.log(\"Copying text command was \" + msg);\n  } catch (err) {\n    console.log(\"Oops, unable to copy\");\n  }\n\n  document.body.removeChild(textArea);\n}\nfunction isWindowDefined() {\n  try {\n    return window && true;\n  } catch (error) {\n    return false;\n  }\n}\nfunction isNode() {\n  // @ts-ignore\n  return Boolean(typeof glb().module !== \"undefined\" && glb().module.exports);\n}\nfunction isIE() {\n  // @ts-ignore\n  return Boolean(window.ActiveXObject || \"ActiveXObject\" in window);\n}\n/*\r\nhttps://developer.mozilla.org/docs/Web/API/Window/open\r\nhttp://www.w3school.com.cn/htmldom/met_win_open.asp#windowfeatures\r\n*/\n\nfunction openWindow(url, name) {\n  let opt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  window.open(url, name, Object.keys(opt).map(k => \"\".concat(k, \"=\").concat(opt[k])).join(\",\"));\n}\nfunction openCenterWindow(url, name, width, height) {\n  let opt = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  const t = {\n    width,\n    height,\n    top: (window.screen.availHeight - 30 - height) / 2,\n    left: (window.screen.availWidth - 30 - width) / 2\n  };\n  Object.assign(t, opt);\n  openWindow(url, name, t);\n}\nfunction openPreviewWindow(previewUrl) {\n  let name = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"preview\";\n  let width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1000;\n  let height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 800;\n  return openCenterWindow(previewUrl, name, width, height, {\n    directories: \"no\",\n    titlebar: \"no\",\n    toolbar: \"no\",\n    location: \"no\",\n    status: \"no\",\n    menubar: \"no\"\n  });\n}\nclass URLHelper {\n  // protocol, hostname, port, pastname\n  constructor(baseUrl) {\n    _defineProperty(this, \"baseUrl\", \"\");\n\n    _defineProperty(this, \"search\", {});\n\n    let t = decodeURI(baseUrl).split(\"?\");\n    this.baseUrl = t[0];\n\n    if (t[1]) {\n      t[1].split(\"&\").forEach(v => {\n        let t2 = v.split(\"=\");\n        this.search[t2[0]] = t2[1] == null ? \"\" : decodeURIComponent(t2[1]);\n      });\n    }\n  }\n\n  getHref() {\n    const t = [this.baseUrl];\n    let searchStr = Object.keys(this.search).map(k => \"\".concat(k, \"=\").concat(encodeURIComponent(this.search[k]))).join(\"&\");\n\n    if (searchStr) {\n      t.push(searchStr);\n    }\n\n    return t.join(\"?\");\n  }\n\n}\n/* resolve arguments to help overload. 解析函数参数, 帮助重载\r\n```js\r\ntypes eg: ['Object', (i) => i > 3, ['Number', default], null ]\r\nnull represent all types of argument\r\nresolveArgsByType([1,'str'], ['Number', 'Boolean' ,'String']) -> [1, null, 'str']\r\nresolveArgsByType([1,'str'], ['Number', ['Boolean', true] ,'String']) -> [1, true, 'str']\r\n```\r\n*/\n\nfunction resolveArgsByType(args, types) {\n  let argIndex = 0;\n  return types.map(v => {\n    // make rule\n    let rule, dft;\n\n    if (isArray(v)) {\n      rule = v[0];\n      dft = v[1];\n    } else {\n      rule = v;\n      dft = undefined;\n    }\n\n    if (!isFunction(rule)) {\n      if (rule == null) {\n        rule = () => true;\n      } else {\n        const t = rule;\n\n        rule = x => Object.prototype.toString.call(x) === \"[object \".concat(t, \"]\");\n      }\n    }\n\n    const arg = args[argIndex];\n\n    if (rule(arg)) {\n      argIndex++;\n      return arg;\n    } else {\n      return dft;\n    }\n  });\n}\nfunction makeStorageHelper(storage) {\n  return {\n    storage: storage,\n\n    set(name, value, minutes) {\n      // set null can remove a item\n      if (value == null) {\n        this.storage.removeItem(name);\n      } else {\n        this.storage.setItem(name, JSON.stringify({\n          value,\n          expired_at: minutes ? new Date().getTime() + minutes * 60 * 1000 : null\n        }));\n      }\n    },\n\n    get(name) {\n      let t = this.storage.getItem(name);\n\n      if (t) {\n        t = JSON.parse(t);\n\n        if (!t.expired_at || t.expired_at > new Date().getTime()) {\n          return t.value;\n        } else {\n          this.storage.removeItem(name);\n        }\n      }\n\n      return null;\n    },\n\n    clear() {\n      this.storage.clear();\n    }\n\n  };\n}\nconst extendedLocalStorage = cacheFunction(function () {\n  return makeStorageHelper(localStorage);\n});\nconst extendedSessionStorage = cacheFunction(function () {\n  return makeStorageHelper(sessionStorage);\n});\n/**\r\n * Base event process. like event bus\r\n * 事件处理. 类似event bus\r\n */\n\nclass EventProcessor {\n  constructor() {\n    _defineProperty(this, \"eventStore\", []);\n  }\n\n  on(name, handler) {\n    this.eventStore.push({\n      name,\n      handler\n    });\n  }\n\n  once(name, handler) {\n    const off = () => {\n      this.off(name, wrappedHandler);\n    };\n\n    const wrappedHandler = function () {\n      handler(...arguments);\n      off();\n    };\n\n    this.on(name, wrappedHandler);\n    return off;\n  }\n\n  onceTimeout(name, handler, timeout) {\n    let off;\n    const promise = new Promise((resolve, reject) => {\n      const wrappedHandler = function () {\n        handler(...arguments);\n        resolve();\n      };\n\n      off = this.once(name, wrappedHandler);\n      waitTime(timeout).then(() => {\n        off();\n        reject();\n      });\n    });\n\n    const off2 = () => {\n      off && off();\n    };\n\n    return {\n      off: off2,\n      promise\n    };\n  }\n\n  off(name, handler) {\n    const indexes = []; // to remove indexes; reverse; 倒序的\n\n    const len = this.eventStore.length;\n\n    for (let i = 0; i < len; i++) {\n      const item = this.eventStore[i];\n\n      if (item.name === name && item.handler === handler) {\n        indexes.unshift(i);\n      }\n    }\n\n    for (const index of indexes) {\n      this.eventStore.splice(index, 1);\n    }\n  }\n\n  emit(name) {\n    // 重要: 先找到要执行的项放在新数组里, 因为执行项会改变事件项存储数组\n    const items = [];\n\n    for (const item of this.eventStore) {\n      if (item.name === name) {\n        items.push(item);\n      }\n    }\n\n    for (var _len9 = arguments.length, args = new Array(_len9 > 1 ? _len9 - 1 : 0), _key9 = 1; _key9 < _len9; _key9++) {\n      args[_key9 - 1] = arguments[_key9];\n    }\n\n    for (const item of items) {\n      item.handler(...args);\n    }\n  }\n\n}\n/**\r\n * Pass event cross window\r\n */\n\nclass CrossWindowEventProcessor extends EventProcessor {\n  // id\n  constructor(opt) {\n    super();\n\n    _defineProperty(this, \"storageName\", \"_crossWindow\");\n\n    _defineProperty(this, \"windows\", []);\n\n    _defineProperty(this, \"timeout\", 200);\n\n    _defineProperty(this, \"id\", void 0);\n\n    _defineProperty(this, \"ready\", void 0);\n\n    _defineProperty(this, \"BROADCAST\", \"__BROADCAST__\");\n\n    if (opt) {\n      Object.assign(this, opt);\n    }\n\n    on(window, \"storage\", ev => {\n      if (ev.key === this.storageName) {\n        const event = JSON.parse(ev.newValue);\n\n        if (!event.targets || event.targets.includes(this.id)) {\n          this.emitLocal(event.name, ...event.args);\n        }\n      }\n    }); // social parts 集体部分\n    // join\n\n    this.id = randString();\n    this.windows = [this.id];\n    this.ready = new Promise((resolve, reject) => {\n      this.onceTimeout(\"_windows_updated\", _ref => {\n        let {\n          windows\n        } = _ref;\n        this.windows = windows;\n      }, this.timeout).promise.then(() => {\n        resolve(); // responsed 被响应\n      }, () => {\n        // no response 无响应\n        resolve();\n      });\n      this.broadcast(\"_join\", this.id);\n    });\n    this.ready.then(() => {\n      // on join\n      this.on(\"_join\", id => {\n        this.windows.push(id);\n\n        if (this.isMain()) {\n          this.broadcast(\"_windows_updated\", {\n            windows: this.windows,\n            type: \"join\",\n            id\n          });\n        }\n      }); // on _windows_updated\n\n      this.on(\"_windows_updated\", _ref2 => {\n        let {\n          windows\n        } = _ref2;\n        this.windows = windows;\n      }); // on exit\n\n      this.on(\"_exit\", id => {\n        const oldMain = this.windows[0];\n        arrayRemove(this.windows, id);\n\n        if (this.isMain()) {\n          this.emit(\"_windows_updated\", {\n            windows: this.windows,\n            type: \"exit\",\n            id\n          });\n\n          if (oldMain != this.id) {\n            this.emit(\"_main_updated\", {\n              windows: this.windows,\n              old: oldMain,\n              new: this.id\n            });\n          }\n        }\n      });\n      on(window, \"beforeunload\", () => {\n        this.exitGroup();\n      });\n    });\n  }\n\n  isMain() {\n    return this.id === this.windows[0];\n  }\n\n  emitTo(name, targets) {\n    for (var _len10 = arguments.length, args = new Array(_len10 > 2 ? _len10 - 2 : 0), _key10 = 2; _key10 < _len10; _key10++) {\n      args[_key10 - 2] = arguments[_key10];\n    }\n\n    if (targets === this.BROADCAST) {\n      targets = null;\n    } else {\n      if (targets && !isArray(targets)) {\n        targets = [targets];\n      }\n\n      if (targets.includes(this.id)) {\n        super.emit(name, ...args); // emit to current window\n      }\n    }\n\n    glb().localStorage.setItem(this.storageName, JSON.stringify({\n      name,\n      targets,\n      args,\n      // use random make storage event triggered every time\n      // 加入随机保证触发storage事件\n      random: Math.random()\n    }));\n  }\n\n  emitLocal(name) {\n    for (var _len11 = arguments.length, args = new Array(_len11 > 1 ? _len11 - 1 : 0), _key11 = 1; _key11 < _len11; _key11++) {\n      args[_key11 - 1] = arguments[_key11];\n    }\n\n    this.emitTo(name, this.id, ...args);\n  }\n\n  broadcast(name) {\n    for (var _len12 = arguments.length, args = new Array(_len12 > 1 ? _len12 - 1 : 0), _key12 = 1; _key12 < _len12; _key12++) {\n      args[_key12 - 1] = arguments[_key12];\n    }\n\n    this.emitTo(name, this.BROADCAST, ...args);\n  }\n\n  emit(name) {\n    for (var _len13 = arguments.length, args = new Array(_len13 > 1 ? _len13 - 1 : 0), _key13 = 1; _key13 < _len13; _key13++) {\n      args[_key13 - 1] = arguments[_key13];\n    }\n\n    this.emitTo(name, this.windows, ...args);\n  }\n\n  exitGroup() {\n    this.broadcast(\"_exit\", this.id);\n  }\n\n}\n/**\r\n * on continuous input. return destroy\r\n * 监听连续输入事件. 返回取消监听函数. 例如监听用户输入aa\r\n * @param handler\r\n * @param opt\r\n * @returns\r\n */\n\nfunction onContinuousInput(handler) {\n  let opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  opt = {\n    timeout: 1000,\n    ...opt\n  };\n  let input = \"\";\n  let timeoutId;\n\n  const keydownHandler = e => {\n    if (e.key && e.key.length === 1) {\n      input = \"\".concat(input).concat(e.key);\n      handler(input);\n\n      if (timeoutId) {\n        clearTimeout(timeoutId);\n        timeoutId = null;\n      }\n\n      timeoutId = setTimeout(() => {\n        input = \"\";\n      }, opt.timeout);\n    }\n  };\n\n  on(document, \"keydown\", keydownHandler);\n  return () => {\n    off(document, \"keydown\", keydownHandler);\n  };\n} // refer [onContinuousInput](#onContinuousInput)\n\nconst onQuickKeydown = onContinuousInput;\nfunction getUserLanguage() {\n  return navigator.language || navigator[\"userLanguage\"];\n}\nclass Cache {\n  constructor() {\n    _defineProperty(this, \"store\", {});\n  }\n\n  has(name) {\n    return this.store.hasOwnProperty(name);\n  }\n\n  remember(name, getter) {\n    if (!this.has(name)) {\n      this.store[name] = {\n        value: getter()\n      };\n    }\n\n    return this.store[name].value;\n  }\n\n  forget(name) {\n    if (name) {\n      if (this.has(name)) {\n        delete this.store[name];\n      }\n    } else {\n      this.store = {};\n    }\n  }\n\n} // attach cached getters to an object; can attach to self\n\nfunction attachCache(obj, toCache) {\n  let cache = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Cache();\n\n  for (const key in toCache) {\n    const getter = toCache[key];\n    Object.defineProperty(obj, key, {\n      get() {\n        return cache.remember(key, () => getter.call(this));\n      }\n\n    });\n  }\n} // for animation\n\nfunction easeInOutQuad(startValue, changeInValue, changedTime, duration) {\n  let t = changedTime,\n      d = duration,\n      b = startValue,\n      c = changeInValue;\n  t /= d / 2;\n  if (t < 1) return c / 2 * t * t + b;\n  t--;\n  return -c / 2 * (t * (t - 2) - 1) + b;\n} // others\n\nfunction isMobile() {\n  var isMobile = false; //initiate as false\n  // device detection\n\n  if (/(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|ipad|iris|kindle|Android|Silk|lge |maemo|midp|mmp|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows (ce|phone)|xda|xiino/i.test(navigator.userAgent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\\-(n|u)|c55\\/|capi|ccwa|cdm\\-|cell|chtm|cldc|cmd\\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\\-s|devi|dica|dmob|do(c|p)o|ds(12|\\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\\-|_)|g1 u|g560|gene|gf\\-5|g\\-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd\\-(m|p|t)|hei\\-|hi(pt|ta)|hp( i|ip)|hs\\-c|ht(c(\\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\\-(20|go|ma)|i230|iac( |\\-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc\\-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|\\-[a-w])|libw|lynx|m1\\-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m\\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\\-2|po(ck|rt|se)|prox|psio|pt\\-g|qa\\-a|qc(07|12|21|32|60|\\-[2-7]|i\\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\\-|oo|p\\-)|sdk\\/|se(c(\\-|0|1)|47|mc|nd|ri)|sgh\\-|shar|sie(\\-|m)|sk\\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\\-|v\\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\\-|tdg\\-|tel(i|m)|tim\\-|t\\-mo|to(pl|sh)|ts(70|m\\-|m3|m5)|tx\\-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\\-|your|zeto|zte\\-/i.test(navigator.userAgent.substring(0, 4))) {\n    isMobile = true;\n  }\n\n  return isMobile;\n}\nclass Accumulate {\n  constructor(arr) {\n    _defineProperty(this, \"arr\", []);\n\n    _defineProperty(this, \"cache\", []);\n\n    this.arr = arr;\n  }\n\n  getValue(item) {\n    // @ts-ignore\n    return item;\n  }\n\n  sum(index) {\n    if (this.cache[index] == null) {\n      let prev = index > 0 ? this.sum(index - 1) : 0;\n      this.cache[index] = this.getValue(this.arr[index]) + prev;\n    }\n\n    return this.cache[index];\n  }\n\n}\n/**\r\n * from https://www.zhangxinxu.com/wordpress/2018/08/css-svg-background-image-base64-encode/\r\n * @param svgCode\r\n * @returns\r\n */\n\nfunction svgToDataURL(svgCode) {\n  return \"data:image/svg+xml,\" + svgCode.replace(/\"/g, \"'\").replace(/%/g, \"%25\").replace(/#/g, \"%23\").replace(/{/g, \"%7B\").replace(/}/g, \"%7D\").replace(/</g, \"%3C\").replace(/>/g, \"%3E\");\n}\nfunction genRandomLightColor() {\n  var letters = \"BCDEF\".split(\"\");\n  var color = \"#\";\n\n  for (var i = 0; i < 6; i++) {\n    color += letters[Math.floor(Math.random() * letters.length)];\n  }\n\n  return color;\n}\n/**\r\n * Like Map, support array as key. array order is used.\r\n */\n\nclass ArrayKeyMap {\n  constructor() {\n    _defineProperty(this, \"_map\", new Map());\n\n    _defineProperty(this, \"_values\", {});\n\n    _defineProperty(this, \"_objCount\", 0);\n  }\n\n  _keysToString(keys) {\n    const {\n      _map\n    } = this;\n    let t = [];\n\n    for (const key of keys) {\n      if (!_map.has(key)) {\n        return null;\n      }\n\n      t.push(_map.get(key)[0]);\n    }\n\n    return t.toString();\n  }\n\n  has(keys) {\n    if (this._keysToString(keys) == null) {\n      return false;\n    }\n\n    return true;\n  }\n  /**\r\n   * throw error if not found\r\n   * @param keys\r\n   * @returns\r\n   */\n\n\n  get(keys) {\n    const {\n      _values\n    } = this;\n\n    const key2 = this._keysToString(keys);\n\n    if (key2 == null) {\n      throw \"Value not found by specified keys\";\n    }\n\n    return _values[key2][1];\n  }\n\n  set(keys, value) {\n    const {\n      _map,\n      _values\n    } = this;\n    let t = [];\n\n    for (const key of keys) {\n      let str;\n      let count = 1;\n\n      if (_map.has(key)) {\n        [str, count] = _map.get(key);\n        count++;\n      } else {\n        this._objCount++;\n        str = this._objCount.toString();\n      }\n\n      _map.set(key, [str, count]);\n\n      t.push(str);\n    }\n\n    _values[t.toString()] = [keys.slice(), value];\n  }\n\n  delete(keys) {\n    const {\n      _values,\n      _map\n    } = this;\n\n    const key2 = this._keysToString(keys);\n\n    if (key2 == null) {\n      throw \"Value not found by specified keys\";\n    }\n\n    delete _values[key2];\n\n    for (const key of keys) {\n      let [str, count] = _map.get(key);\n\n      count--;\n\n      if (count === 0) {\n        _map.delete(key);\n      } else {\n        _map.set(key, [str, count]);\n      }\n    }\n  }\n\n  clear() {\n    this._map.clear();\n\n    this._values = {};\n  }\n\n  *entries() {\n    const {\n      _values\n    } = this;\n\n    for (const key in _values) {\n      const [keys, value] = _values[key];\n      yield [keys, value];\n    }\n  }\n\n  count() {\n    return [...this.entries()].length;\n  }\n\n}\n\nexport { Accumulate, ArrayKeyMap, Cache, CrossWindowEventProcessor, EventProcessor, TreeData, URLHelper, addClass, addDate, appendTo, applyFinally, arrayAt, arrayBetween, arrayDiff, arrayDistinct, arrayFilter, arrayFirst, arrayFlat, arrayLast, arrayRemove, arrayRemoveBySortedIndexes, arrayWithout, arrayWithoutEnd, assignIfDiff, assignIfKeyNull, assignIfNoKey, attachCache, backupAttr, between, binarySearch, bindContext, cacheFunction, camelCase, camelToWords, cloneDate, cloneObject, cloneTreeData, continuous, copyTextToClipboard, createElementFromHTML, css, cssNumber, debounceImmediate, debounceTrailing, dotGet, dotSet, easeInOutQuad, elementsFromPoint, empty, executePromiseGetters, executeWithCount, extendedListen, extendedLocalStorage, extendedSessionStorage, findAll, findInfoInTreeData, findParent, findTreeData, genRandomLightColor, getArrayItemSiblingsByOffsets, getBoundingClientRect, getCalendar, getElSizeEvenInvisible, getImageSizeByUrl, getMonthEnd, getMonthStart, getOffset, getOffsetParent, getOuterAttachedHeight, getOuterAttachedWidth, getPosition, getPositionFromOffset, getScroll, getScrollSpace, getUrlParam, getUserLanguage, getViewportPosition, glb, groupArray, hasClass, hasClassIn, hasClasses, indexesOf, insertAfter, insertBefore, isArray, isBool, isDescendantOf, isDocumentExisted, isFunction, isIE, isIsoFormat, isMobile, isNode, isNumber, isNumeric, isObject, isOffsetInEl, isPromise, isScrollable, isString, isWindowDefined, iterateAll, joinFunctionsByNext, joinFunctionsByResult, joinRows, kebabCase, makeStorageHelper, mapObjectTree, mapObjects, notGreaterThan, notLessThan, objectAssignIfDiff, objectAssignIfKeyNull, objectAssignIfNoKey, objectDefineProxyProperty, objectExcept, objectMap, objectOnly, off, on, onContinuousInput, onQuickKeydown, once, openCenterWindow, openPreviewWindow, openWindow, parseISO, pathJoin, pointIn, prependTo, promiseContinuous, promisePin, promiseTimeout, randChoice, randInt, randString, removeClass, removeEl, resolveArgsByType, resolveValueOrGettter, restoreAttr, retry, reverseString, scrollTo, setElChildByIndex, snakeCase, splitArray, strPad, studlyCase, svgToDataURL, titleCase, toArrayIfNot, unset, viewportPositionToFixed, waitFor, waitTime, walkTreeData, watchChange, windowLoaded, withoutUndefined };\n","/*!\n * drag-event-service v2.0.0\n * Author: phphe <phphe@outlook.com> (https://github.com/phphe)\n * Homepage: null\n * Released under the MIT License.\n */\nimport * as hp from 'helper-js';\n\n// support desktop and mobile\nconst events = {\n  start: [\"mousedown\", \"touchstart\"],\n  move: [\"mousemove\", \"touchmove\"],\n  end: [\"mouseup\", \"touchend\"]\n};\nconst DragEventService = {\n  isTouch(e) {\n    return e.type && e.type.startsWith(\"touch\");\n  },\n\n  _getStore(el) {\n    // @ts-ignore\n    if (!el._wrapperStore) {\n      // @ts-ignore\n      el._wrapperStore = [];\n    } // @ts-ignore\n\n\n    return el._wrapperStore;\n  },\n\n  on(el, name, handler, options) {\n    const {\n      args,\n      mouseArgs,\n      touchArgs\n    } = resolveOptions(options);\n\n    const store = this._getStore(el);\n\n    const ts = this;\n\n    const wrapper = function (e) {\n      let mouse;\n      const isTouch = ts.isTouch(e);\n\n      if (isTouch) {\n        // touch\n        mouse = {\n          x: e.changedTouches[0].pageX,\n          y: e.changedTouches[0].pageY,\n          pageX: e.changedTouches[0].pageX,\n          pageY: e.changedTouches[0].pageY,\n          clientX: e.changedTouches[0].clientX,\n          clientY: e.changedTouches[0].clientY,\n          screenX: e.changedTouches[0].screenX,\n          screenY: e.changedTouches[0].screenY\n        };\n      } else {\n        // mouse\n        mouse = {\n          x: e.pageX,\n          y: e.pageY,\n          pageX: e.pageX,\n          pageY: e.pageY,\n          clientX: e.clientX,\n          clientY: e.clientY,\n          screenX: e.screenX,\n          screenY: e.screenY\n        };\n\n        if (name === \"start\" && e.which !== 1) {\n          // not left button mousedown\n          return;\n        }\n      }\n\n      return handler.call(this, e, mouse);\n    };\n\n    store.push({\n      handler,\n      wrapper\n    }); // follow format will cause big bundle size\n    // 以下写法将会使打包工具认为hp是上下文, 导致打包整个hp\n    // hp.on(el, events[name][0], wrapper, ...args)\n\n    hp.on.call(null, el, events[name][0], wrapper, ...[...args, ...mouseArgs]);\n    hp.on.call(null, el, events[name][1], wrapper, ...[...args, ...touchArgs]);\n  },\n\n  off(el, name, handler, options) {\n    const {\n      args,\n      mouseArgs,\n      touchArgs\n    } = resolveOptions(options);\n\n    const store = this._getStore(el);\n\n    for (let i = store.length - 1; i >= 0; i--) {\n      const {\n        handler: handler2,\n        wrapper\n      } = store[i];\n\n      if (handler === handler2) {\n        hp.off.call(null, el, events[name][0], wrapper, ...[...args, ...mouseArgs]);\n        hp.off.call(null, el, events[name][1], wrapper, ...[...args, ...mouseArgs]);\n        store.splice(i, 1);\n      }\n    }\n  }\n\n};\n\nfunction resolveOptions(options) {\n  if (!options) {\n    options = {};\n  }\n\n  const args = options.args || [];\n  const mouseArgs = options.mouseArgs || [];\n  const touchArgs = options.touchArgs || [];\n  return {\n    args,\n    mouseArgs,\n    touchArgs\n  };\n}\n\nexport { DragEventService as default };\n","import * as hp from \"helper-js\";\nimport { Nullable } from \"helper-js\";\nimport DragEventService from \"drag-event-service\";\n\nexport const instances = new Map<Element, ExtendedDND>();\nexport const context = {\n  triggerElement: null as Nullable<HTMLElement>,\n  dragElement: null as Nullable<HTMLElement>,\n  internal: false, // if the dragstart event is internal\n  dropEffect: \"none\" as DataTransfer[\"dropEffect\"],\n  preventDefault: false,\n};\nconst ctx = context;\n\nfunction syncDropEffect(e: DragEvent) {\n  if (e.dataTransfer) {\n    e.dataTransfer.dropEffect = ctx.dropEffect;\n  }\n}\n\n//\nexport function extendedDND(root: Element, options: Options = {}) {\n  if (instances.has(root)) {\n    throw \"Already registered on specified element\";\n  }\n  // opt is same with thisInstance\n  const opt = { ...options }; // clone options object\n  const ins = opt as ExtendedDND;\n  hp.objectAssignIfNoKey(opt, defaultOptions);\n  DragEventService.on(root, \"start\", beforeDragStart, {\n    touchArgs: [{ passive: true }],\n  });\n  DragEventService.on(root, \"end\", onClickEnd);\n  // methods\n  function beforeDragStart(e: MouseEvent | TouchEvent) {\n    const node = e.target as Node;\n    // only process element node\n    if (node.nodeType === Node.ELEMENT_NODE) {\n      ctx.triggerElement = node as HTMLElement;\n    }\n    const el = node as HTMLElement;\n    // if in ingoreHTMLTags\n    if (opt.ingoreHTMLTags && el.tagName) {\n      if (opt.ingoreHTMLTags.find((tag) => tag.toUpperCase() === el.tagName)) {\n        return;\n      }\n    }\n    const dragElement = opt.beforeDragStart?.(e);\n    if (dragElement) {\n      dragElement.setAttribute(\"draggable\", \"true\");\n      ctx.dragElement = dragElement;\n    }\n  }\n\n  // triggered when quick click\n  function onClickEnd(e: MouseEvent | TouchEvent) {\n    if (ctx.dragElement) {\n      ctx.dragElement.removeAttribute(\"draggable\");\n    }\n  }\n\n  function onDragStart(e: DragEvent) {\n    ctx.internal = true;\n    opt.onDragStart?.(e);\n    syncDropEffect(e);\n  }\n\n  function onDrag(e: DragEvent) {\n    opt.onDrag?.(e);\n    syncDropEffect(e);\n  }\n\n  function onDragEnd(e: DragEvent) {\n    opt.onDragEnd?.(e);\n    ctx.internal = false;\n    if (ctx.dragElement) {\n      ctx.dragElement.removeAttribute(\"draggable\");\n    }\n    ctx.triggerElement = null;\n    ctx.dragElement = null;\n    ctx.dropEffect = \"none\";\n  }\n\n  // follow is called on target instance\n  const destroyDropZoneListeners = extendedDropZone(root, {\n    onDragLeave(e) {\n      opt.onDragLeave?.(e);\n      syncDropEffect(e);\n    },\n    onDragEnter(e) {\n      ins.ifPreventDefault(e) && e.preventDefault();\n      opt.onDragEnter?.(e);\n      syncDropEffect(e);\n    },\n    onDragOver(e) {\n      ins.ifPreventDefault(e) && e.preventDefault();\n      opt.onDragOver?.(e);\n      syncDropEffect(e);\n    },\n    onDrop(e) {\n      ins.ifPreventDefault(e) && e.preventDefault();\n      opt.onDrop?.(e);\n    },\n    onEnter(e) {\n      opt.onEnter?.(e);\n    },\n    onLeave(e) {\n      opt.onLeave?.(e);\n    },\n  });\n\n  hp.on(root, \"dragstart\", onDragStart);\n  hp.on(root, \"drag\", onDrag);\n  hp.on(root, \"dragend\", onDragEnd);\n  // define the destroy function\n  // 定义销毁/退出的方法\n  const destroy = () => {\n    DragEventService.off(root, \"start\", beforeDragStart, {\n      touchArgs: [{ passive: true }],\n    });\n    hp.off(root, \"dragstart\", onDragStart);\n    hp.off(root, \"drag\", onDrag);\n    hp.off(root, \"dragend\", onDragEnd);\n    destroyDropZoneListeners();\n    instances.delete(root);\n  };\n\n  Object.assign(opt, {\n    root,\n    destroy,\n  });\n  instances.set(root, ins);\n  return ins;\n}\n\nexport const defaultOptions = {\n  ingoreHTMLTags: [\"INPUT\", \"TEXTAREA\", \"SELECT\", \"OPTGROUP\", \"OPTION\"], // uppercase\n  ifPreventDefault(event: DragEvent): boolean {\n    if (context.dragElement) {\n      return true;\n    }\n    return ctx.preventDefault;\n  },\n  beforeDragStart(event: MouseEvent | TouchEvent): void | HTMLElement {},\n  onDragStart(event: DragEvent) {},\n  onDrag(event: DragEvent) {},\n  onDragEnter(event: DragEvent) {},\n  onDragLeave(event: DragEvent) {},\n  onDragOver(event: DragEvent) {},\n  onDragEnd(event: DragEvent) {},\n  onDrop(event: DragEvent) {},\n};\n\nexport type Point = {\n  x: number;\n  y: number;\n};\nexport type Options = Partial<typeof defaultOptions> & {\n  /**\n   * custom event, like mouseenter. event belongs to dragenter or dragover\n   */\n  onEnter?: (event: DragEvent) => void;\n  /**\n   * custom event, like mouseleave. event belongs to dragenter or dragover\n   */\n  onLeave?: (event: DragEvent) => void;\n};\n\n// ExtendedDND is the return of extendedDND\nexport type ExtendedDND = Required<Options> & {\n  root: Element;\n  /**\n   * For user to pass custom data between multiple instances\n   * 用于用户在多个实例间传递自定义数据\n   */\n  data?: unknown;\n  destroy: () => void;\n};\n\n/*\n## extendedDropZone\n为元素绑定DND相关事件。\n其中onEnter和onLeave不是原生事件。\nonEnter原理：\n使用变量表示是否进入，每次触发onDragEnter和onDragOver都会使该变量为真。\nonLeave原理：\n当进入子元素时，会依次触发onDragEnter和onDragLeave事件。onDragEnter时短暂记住事件target，onDragLeave检查是否刚刚触发onDragLeave事件，且事件target是子元素，否则触发onLeave。\n*/\nlet justEnteredTarget: Element | null = null;\nconst setJustEnteredTarget = (el: Element) => {\n  justEnteredTarget = el;\n  setTimeout(() => {\n    justEnteredTarget = null;\n  }, 20);\n};\nexport function extendedDropZone(\n  el: Element,\n  opt: {\n    onEnter?: (event: DragEvent) => void;\n    onLeave?: (event: DragEvent) => void;\n    onDragEnter?: (event: DragEvent) => void;\n    onDragOver?: (event: DragEvent) => void;\n    onDragLeave?: (event: DragEvent) => void;\n    onDrop?: (event: DragEvent) => void;\n    /**\n     * for extendedDND's onEnter and onLeave; 用以实现 extendedDND 的 onEnter 和 onLeave\n     */\n    onEndBeforeLeave?: (event: MouseEvent | TouchEvent | KeyboardEvent) => void;\n  } = {}\n) {\n  const dropZone = el; // just rename\n  let entered = false;\n  const onEnter = (e: DragEvent) => {\n    entered = true;\n    opt.onEnter?.(e);\n    endListeners.resume();\n  };\n  const onDragEnter = (e: DragEvent) => {\n    setJustEnteredTarget(e.target as Element);\n    opt.onDragEnter?.(e);\n    if (!entered) {\n      onEnter(e);\n    }\n  };\n  const onDragOver = (e: DragEvent) => {\n    if (!entered) {\n      onEnter(e);\n    }\n    opt.onDragOver?.(e);\n  };\n  const onDragLeave = (e: DragEvent) => {\n    opt.onDragLeave?.(e);\n    const doLeave = (event = e) => {\n      entered = false;\n      opt.onLeave?.(event);\n      endListeners.stop();\n    };\n    const justEnter = justEnteredTarget;\n    justEnteredTarget = null;\n    if (justEnter && hp.isDescendantOf(justEnter, dropZone)) {\n      // enter child, does not leave\n    } else {\n      doLeave();\n    }\n  };\n\n  const onDrop = (e: DragEvent) => {\n    opt.onDrop?.(e);\n  };\n\n  const onEndBeforeLeave = (e: any) => {\n    if (e instanceof KeyboardEvent) {\n      if (e.key !== \"Escape\") {\n        return;\n      }\n    }\n    entered = false;\n    endListeners.stop();\n    opt.onEndBeforeLeave?.(e);\n  };\n  const endListeners = hp.extendedListen([\n    [el, \"drop\", onEndBeforeLeave],\n    [window, \"mouseup\", onEndBeforeLeave],\n    [window, \"touchend\", onEndBeforeLeave],\n    [window, \"keydown\", onEndBeforeLeave],\n  ]);\n  endListeners.stop();\n\n  const resume = () => {\n    hp.on(el, \"dragenter\", onDragEnter);\n    hp.on(el, \"dragover\", onDragOver);\n    hp.on(el, \"dragleave\", onDragLeave);\n    hp.on(el, \"drop\", onDrop);\n  };\n  const destroy = () => {\n    hp.off(el, \"dragenter\", onDragEnter);\n    hp.off(el, \"dragover\", onDragOver);\n    hp.off(el, \"dragleave\", onDragLeave);\n    hp.off(el, \"drop\", onDrop);\n    endListeners.stop();\n  };\n\n  resume();\n\n  return destroy;\n}\n"],"names":["objectAssignIfNoKey","obj1","obj2","Object","keys","forEach","key","obj","val","hasOwnProperty","assignIfNoKey","isDescendantOf","el","parent","parentNode","on","name","handler","options","addEventListener","attachEvent","concat","off","removeEventListener","detachEvent","extendedListen","info","destroyFuncs","r","listening","stop","destroy","resume","item","apply","this","push","events","start","move","end","DragEventService","isTouch","e","type","startsWith","_getStore","_wrapperStore","args","mouseArgs","touchArgs","resolveOptions","store","ts","wrapper","mouse","x","changedTouches","pageX","y","pageY","clientX","clientY","screenX","screenY","which","call","hp","i","length","handler2","splice","instances","Map","context","triggerElement","dragElement","internal","dropEffect","preventDefault","ctx","syncDropEffect","dataTransfer","defaultOptions","ingoreHTMLTags","ifPreventDefault","event","beforeDragStart","onDragStart","onDrag","onDragEnter","onDragLeave","onDragOver","onDragEnd","onDrop","justEnteredTarget","setJustEnteredTarget","setTimeout","extendedDropZone","opt","dropZone","entered","onEnter","_opt$onEnter2","endListeners","_opt$onDragEnter2","target","_opt$onDragOver2","_opt$onDragLeave2","justEnter","_opt$onLeave2","onLeave","doLeave","_opt$onDrop2","onEndBeforeLeave","_opt$onEndBeforeLeave","KeyboardEvent","window","root","has","ins","_opt$beforeDragStart","node","nodeType","Node","ELEMENT_NODE","tagName","find","tag","toUpperCase","setAttribute","onClickEnd","removeAttribute","_opt$onDragStart","_opt$onDrag","_opt$onDragEnd","passive","destroyDropZoneListeners","_opt$onDragLeave","_opt$onDragEnter","_opt$onDragOver","_opt$onDrop","_opt$onEnter","_opt$onLeave","delete","assign","set"],"mappings":"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"}