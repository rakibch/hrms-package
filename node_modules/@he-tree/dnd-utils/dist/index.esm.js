/*!
 * @he-tree/dnd-utils v0.1.0-alpha.4
 * Author: phphe <phphe@outlook.com> (https://github.com/phphe)
 * Homepage: null
 * Released under the MIT License.
 */
import * as hp from 'helper-js';
import DragEventService from 'drag-event-service';

const instances = new Map();
const context = {
  triggerElement: null,
  dragElement: null,
  internal: false,
  dropEffect: "none",
  preventDefault: false
};
const ctx = context;

function syncDropEffect(e) {
  if (e.dataTransfer) {
    e.dataTransfer.dropEffect = ctx.dropEffect;
  }
} //


function extendedDND(root) {
  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (instances.has(root)) {
    throw "Already registered on specified element";
  } // opt is same with thisInstance


  const opt = { ...options
  }; // clone options object

  const ins = opt;
  hp.objectAssignIfNoKey(opt, defaultOptions);
  DragEventService.on(root, "start", beforeDragStart, {
    touchArgs: [{
      passive: true
    }]
  });
  DragEventService.on(root, "end", onClickEnd); // methods

  function beforeDragStart(e) {
    var _opt$beforeDragStart;

    const node = e.target; // only process element node

    if (node.nodeType === Node.ELEMENT_NODE) {
      ctx.triggerElement = node;
    }

    const el = node; // if in ingoreHTMLTags

    if (opt.ingoreHTMLTags && el.tagName) {
      if (opt.ingoreHTMLTags.find(tag => tag.toUpperCase() === el.tagName)) {
        return;
      }
    }

    const dragElement = (_opt$beforeDragStart = opt.beforeDragStart) === null || _opt$beforeDragStart === void 0 ? void 0 : _opt$beforeDragStart.call(opt, e);

    if (dragElement) {
      dragElement.setAttribute("draggable", "true");
      ctx.dragElement = dragElement;
    }
  } // triggered when quick click


  function onClickEnd(e) {
    if (ctx.dragElement) {
      ctx.dragElement.removeAttribute("draggable");
    }
  }

  function onDragStart(e) {
    var _opt$onDragStart;

    ctx.internal = true;
    (_opt$onDragStart = opt.onDragStart) === null || _opt$onDragStart === void 0 ? void 0 : _opt$onDragStart.call(opt, e);
    syncDropEffect(e);
  }

  function onDrag(e) {
    var _opt$onDrag;

    (_opt$onDrag = opt.onDrag) === null || _opt$onDrag === void 0 ? void 0 : _opt$onDrag.call(opt, e);
    syncDropEffect(e);
  }

  function onDragEnd(e) {
    var _opt$onDragEnd;

    (_opt$onDragEnd = opt.onDragEnd) === null || _opt$onDragEnd === void 0 ? void 0 : _opt$onDragEnd.call(opt, e);
    ctx.internal = false;

    if (ctx.dragElement) {
      ctx.dragElement.removeAttribute("draggable");
    }

    ctx.triggerElement = null;
    ctx.dragElement = null;
    ctx.dropEffect = "none";
  } // follow is called on target instance


  const destroyDropZoneListeners = extendedDropZone(root, {
    onDragLeave(e) {
      var _opt$onDragLeave;

      (_opt$onDragLeave = opt.onDragLeave) === null || _opt$onDragLeave === void 0 ? void 0 : _opt$onDragLeave.call(opt, e);
      syncDropEffect(e);
    },

    onDragEnter(e) {
      var _opt$onDragEnter;

      ins.ifPreventDefault(e) && e.preventDefault();
      (_opt$onDragEnter = opt.onDragEnter) === null || _opt$onDragEnter === void 0 ? void 0 : _opt$onDragEnter.call(opt, e);
      syncDropEffect(e);
    },

    onDragOver(e) {
      var _opt$onDragOver;

      ins.ifPreventDefault(e) && e.preventDefault();
      (_opt$onDragOver = opt.onDragOver) === null || _opt$onDragOver === void 0 ? void 0 : _opt$onDragOver.call(opt, e);
      syncDropEffect(e);
    },

    onDrop(e) {
      var _opt$onDrop;

      ins.ifPreventDefault(e) && e.preventDefault();
      (_opt$onDrop = opt.onDrop) === null || _opt$onDrop === void 0 ? void 0 : _opt$onDrop.call(opt, e);
    },

    onEnter(e) {
      var _opt$onEnter;

      (_opt$onEnter = opt.onEnter) === null || _opt$onEnter === void 0 ? void 0 : _opt$onEnter.call(opt, e);
    },

    onLeave(e) {
      var _opt$onLeave;

      (_opt$onLeave = opt.onLeave) === null || _opt$onLeave === void 0 ? void 0 : _opt$onLeave.call(opt, e);
    }

  });
  hp.on(root, "dragstart", onDragStart);
  hp.on(root, "drag", onDrag);
  hp.on(root, "dragend", onDragEnd); // define the destroy function
  // 定义销毁/退出的方法

  const destroy = () => {
    DragEventService.off(root, "start", beforeDragStart, {
      touchArgs: [{
        passive: true
      }]
    });
    hp.off(root, "dragstart", onDragStart);
    hp.off(root, "drag", onDrag);
    hp.off(root, "dragend", onDragEnd);
    destroyDropZoneListeners();
    instances.delete(root);
  };

  Object.assign(opt, {
    root,
    destroy
  });
  instances.set(root, ins);
  return ins;
}
const defaultOptions = {
  ingoreHTMLTags: ["INPUT", "TEXTAREA", "SELECT", "OPTGROUP", "OPTION"],

  ifPreventDefault(event) {
    if (context.dragElement) {
      return true;
    }

    return ctx.preventDefault;
  },

  beforeDragStart(event) {},

  onDragStart(event) {},

  onDrag(event) {},

  onDragEnter(event) {},

  onDragLeave(event) {},

  onDragOver(event) {},

  onDragEnd(event) {},

  onDrop(event) {}

};
/*
## extendedDropZone
为元素绑定DND相关事件。
其中onEnter和onLeave不是原生事件。
onEnter原理：
使用变量表示是否进入，每次触发onDragEnter和onDragOver都会使该变量为真。
onLeave原理：
当进入子元素时，会依次触发onDragEnter和onDragLeave事件。onDragEnter时短暂记住事件target，onDragLeave检查是否刚刚触发onDragLeave事件，且事件target是子元素，否则触发onLeave。
*/

let justEnteredTarget = null;

const setJustEnteredTarget = el => {
  justEnteredTarget = el;
  setTimeout(() => {
    justEnteredTarget = null;
  }, 20);
};

function extendedDropZone(el) {
  let opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const dropZone = el; // just rename

  let entered = false;

  const onEnter = e => {
    var _opt$onEnter2;

    entered = true;
    (_opt$onEnter2 = opt.onEnter) === null || _opt$onEnter2 === void 0 ? void 0 : _opt$onEnter2.call(opt, e);
    endListeners.resume();
  };

  const onDragEnter = e => {
    var _opt$onDragEnter2;

    setJustEnteredTarget(e.target);
    (_opt$onDragEnter2 = opt.onDragEnter) === null || _opt$onDragEnter2 === void 0 ? void 0 : _opt$onDragEnter2.call(opt, e);

    if (!entered) {
      onEnter(e);
    }
  };

  const onDragOver = e => {
    var _opt$onDragOver2;

    if (!entered) {
      onEnter(e);
    }

    (_opt$onDragOver2 = opt.onDragOver) === null || _opt$onDragOver2 === void 0 ? void 0 : _opt$onDragOver2.call(opt, e);
  };

  const onDragLeave = e => {
    var _opt$onDragLeave2;

    (_opt$onDragLeave2 = opt.onDragLeave) === null || _opt$onDragLeave2 === void 0 ? void 0 : _opt$onDragLeave2.call(opt, e);

    const doLeave = function () {
      var _opt$onLeave2;

      let event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : e;
      entered = false;
      (_opt$onLeave2 = opt.onLeave) === null || _opt$onLeave2 === void 0 ? void 0 : _opt$onLeave2.call(opt, event);
      endListeners.stop();
    };

    const justEnter = justEnteredTarget;
    justEnteredTarget = null;

    if (justEnter && hp.isDescendantOf(justEnter, dropZone)) ; else {
      doLeave();
    }
  };

  const onDrop = e => {
    var _opt$onDrop2;

    (_opt$onDrop2 = opt.onDrop) === null || _opt$onDrop2 === void 0 ? void 0 : _opt$onDrop2.call(opt, e);
  };

  const onEndBeforeLeave = e => {
    var _opt$onEndBeforeLeave;

    if (e instanceof KeyboardEvent) {
      if (e.key !== "Escape") {
        return;
      }
    }

    entered = false;
    endListeners.stop();
    (_opt$onEndBeforeLeave = opt.onEndBeforeLeave) === null || _opt$onEndBeforeLeave === void 0 ? void 0 : _opt$onEndBeforeLeave.call(opt, e);
  };

  const endListeners = hp.extendedListen([[el, "drop", onEndBeforeLeave], [window, "mouseup", onEndBeforeLeave], [window, "touchend", onEndBeforeLeave], [window, "keydown", onEndBeforeLeave]]);
  endListeners.stop();

  const resume = () => {
    hp.on(el, "dragenter", onDragEnter);
    hp.on(el, "dragover", onDragOver);
    hp.on(el, "dragleave", onDragLeave);
    hp.on(el, "drop", onDrop);
  };

  const destroy = () => {
    hp.off(el, "dragenter", onDragEnter);
    hp.off(el, "dragover", onDragOver);
    hp.off(el, "dragleave", onDragLeave);
    hp.off(el, "drop", onDrop);
    endListeners.stop();
  };

  resume();
  return destroy;
}

export { context, defaultOptions, extendedDND, extendedDropZone, instances };
