/*!
 * @he-tree/tree-utils v0.1.0-alpha.5
 * Author: phphe <phphe@outlook.com> (https://github.com/phphe)
 * Homepage: null
 * Released under the MIT License.
 */
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var hp = require('helper-js');

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var hp__namespace = /*#__PURE__*/_interopNamespace(hp);

const CHILDREN = "children"; // inner childrenKey

/**
 * help to handle tree data. 帮助处理树形数据.
 */

function makeTreeProcessor(data) {
  let opt = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  const opt2 = opt;
  const utilsBase = { ...defaultOptions,
    ...opt2,
    data,
    stats: null,
    statsFlat: null,
    _statsMap: null,
    initialized: false,

    init() {
      const {
        data,
        childrenKey
      } = this;
      const td = new hp__namespace.TreeData([]);
      this._statsMap = new Map();
      hp__namespace.walkTreeData(data, (nodeData, index, parent, path) => {
        const stat = this.statHandler({ ...statDefault(),
          data: nodeData,
          open: Boolean(this.defaultOpen),
          parent: td.getParent(path),
          children: [],
          level: path.length
        });

        this._statsMap.set(nodeData, stat);

        td.set(path, stat);
      }, {
        childrenKey
      });
      const statsFlat = [];
      td.walk(stat => {
        statsFlat.push(stat);
      });
      this.stats = this.statsHandler(td.rootChildren);
      this.statsFlat = this.statsFlatHandler(statsFlat);
      this.initialized = true;
    },

    getStat(nodeData) {
      let r = this._statsMap.get(nodeData);

      if (!r) {
        throw new StatNotFoundError("Stat not found");
      }

      return r;
    },

    has(nodeData) {
      if (nodeData["isStat"]) {
        // @ts-ignore
        return this.statsFlat.indexOf(nodeData) > -1;
      } else {
        try {
          // @ts-ignore
          let r = this.getStat(nodeData);
          return Boolean(r);
        } catch (error) {
          if (error instanceof StatNotFoundError) {
            return false;
          }

          throw error;
        }
      }
    },

    _getPathByStat(stat) {
      if (stat == null) {
        return [];
      }

      const siblings = this.getSiblings(stat);
      const index = siblings.indexOf(stat);
      return [...(stat.parent ? this._getPathByStat(stat.parent) : []), index];
    },

    /**
     * call it after a stat's `checked` changed
     * @param stat
     * @returns return false mean ignored
     */
    afterOneCheckChanged(stat) {
      const {
        checked
      } = stat;

      if (stat._ignoreCheckedOnce) {
        delete stat._ignoreCheckedOnce;
        return false;
      } // change parent


      const checkParent = stat => {
        const {
          parent
        } = stat;

        if (parent) {
          let hasChecked;
          let hasUnchecked;
          let hasHalfChecked;

          for (const child of parent.children) {
            if (child.checked) {
              hasChecked = true;
            } else if (child.checked === 0) {
              hasHalfChecked = true;
            } else {
              hasUnchecked = true;
            }
          }

          const parentChecked = hasHalfChecked ? 0 : !hasUnchecked ? true : hasChecked ? 0 : false;

          if (parent.checked !== parentChecked) {
            this._ignoreCheckedOnce(parent);

            parent.checked = parentChecked;
          }

          checkParent(parent);
        }
      };

      checkParent(stat); // change children

      hp__namespace.walkTreeData(stat.children, child => {
        if (child.checked !== checked) {
          this._ignoreCheckedOnce(child);

          child.checked = checked;
        }
      }, {
        childrenKey: CHILDREN
      });
      return true;
    },

    _ignoreCheckedOnce(stat) {
      stat._ignoreCheckedOnce = true; // cancel ignore immediately if not triggered

      setTimeout(() => {
        if (stat._ignoreCheckedOnce) {
          stat._ignoreCheckedOnce = false;
        }
      }, 100);
    },

    isVisible(statOrNodeData) {
      // @ts-ignore
      const stat = statOrNodeData["isStat"] ? statOrNodeData : this.getStat(statOrNodeData); // prettier-ignore

      const walk = stat => {
        return !stat || !stat.hidden && stat.open && walk(stat.parent);
      };

      return Boolean(!stat.hidden && walk(stat.parent));
    },

    /**
     * call it to update all stats' `checked`
     */
    updateCheck() {
      hp__namespace.walkTreeData(this.stats, stat => {
        if (stat.children && stat.children.length > 0) {
          const checked = stat.children.every(v => v.checked);

          if (stat.checked !== checked) {
            this._ignoreCheckedOnce(stat);

            stat.checked = checked;
          }
        }
      }, {
        childFirst: true,
        childrenKey: CHILDREN
      });
    },

    getChecked() {
      let withDemi = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      return this.statsFlat.filter(v => {
        return v.checked || withDemi && v.checked === 0;
      });
    },

    getUnchecked() {
      let withDemi = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;
      return this.statsFlat.filter(v => {
        return withDemi ? !v.checked : v.checked === false;
      });
    },

    /**
     * open all nodes
     */
    openAll() {
      for (const stat of this.statsFlat) {
        stat.open = true;
      }
    },

    /**
     * close all nodes
     */
    closeAll() {
      for (const stat of this.statsFlat) {
        stat.open = false;
      }
    },

    openNodeAndParents(nodeOrStat) {
      // @ts-ignore
      const stat = nodeOrStat["isStat"] ? nodeOrStat : this.getStat(nodeOrStat); // prettier-ignore

      for (const parentStat of this.iterateParent(stat, {
        withSelf: true
      })) {
        parentStat.open = true;
      }
    },

    // actions
    _calcFlatIndex(parent, index) {
      let flatIndex = parent ? this.statsFlat.indexOf(parent) + 1 : 0;
      const siblings = parent ? parent.children : this.stats;

      for (let i = 0; i < index; i++) {
        flatIndex += this._count(siblings[i]);
      }

      return flatIndex;
    },

    add(nodeData, parent, index) {
      if (this.has(nodeData)) {
        throw "Can't add because data exists in tree";
      }

      const siblings = parent ? parent.children : this.stats;

      if (index == null) {
        index = siblings.length;
      }

      const stat = this.statHandler({ ...statDefault(),
        open: Boolean(this.defaultOpen),
        data: nodeData,
        parent: parent || null,
        children: [],
        level: parent ? parent.level + 1 : 1
      });

      this._setPosition(stat, parent || null, index);

      const children = nodeData[this.childrenKey];

      if (children) {
        const childrenSnap = children.slice();

        for (const child of childrenSnap) {
          this.add(child, stat);
        }
      }
    },

    remove(stat) {
      const siblings = this.getSiblings(stat);

      if (siblings.includes(stat)) {
        hp__namespace.arrayRemove(siblings, stat);

        const stats = this._flat(stat);

        this.statsFlat.splice(this.statsFlat.indexOf(stat), stats.length);

        for (const stat of stats) {
          this._statsMap.delete(stat.data);
        }

        this.afterRemoveStat(stat);
        return true;
      }

      return false;
    },

    getSiblings(stat) {
      const {
        parent
      } = stat;
      return parent ? parent.children : this.stats;
    },

    /**
     * The node should not exsit.
     * @param node
     * @param parent
     * @param index
     */
    _setPosition(stat, parent, index) {
      const siblings = parent ? parent.children : this.stats;
      siblings.splice(index, 0, stat);
      stat.parent = parent;
      stat.level = parent ? parent.level + 1 : 1;

      const flatIndex = this._calcFlatIndex(parent, index);

      const stats = this._flat(stat);

      this.statsFlat.splice(flatIndex, 0, ...stats);

      for (const stat of stats) {
        if (!this._statsMap.has(stat.data)) {
          this._statsMap.set(stat.data, stat);
        }
      }

      hp__namespace.walkTreeData(stat, (node, index, parent) => {
        if (parent) {
          node.level = parent.level + 1;
        }
      }, {
        childrenKey: CHILDREN
      });
      this.afterSetStat(stat, parent, index);
    },

    *iterateParent(stat, opt) {
      let t = opt !== null && opt !== void 0 && opt.withSelf ? stat : stat.parent;

      while (t) {
        yield t;
        t = t.parent;
      }
    },

    move(stat, parent, index) {
      if (this.has(stat)) {
        if (stat.parent === parent && this.getSiblings(stat).indexOf(stat) === index) {
          return false;
        } // check if is self


        if (stat === parent) {
          // 不允许移动目标为自己
          throw new Error("Can't move node to it self");
        } // check if is descendant


        if (parent && stat.level < parent.level) {
          let t;

          for (const item of this.iterateParent(parent)) {
            if (item.level === stat.level) {
              t = item;
              break;
            }
          }

          if (stat === t) {
            // 不允许移动节点到其后代节点下
            throw new Error("Can't move node to its descendant");
          }
        }

        this.remove(stat);
      }

      this._setPosition(stat, parent, index);

      return true;
    },

    /**
     * convert stat and its children to one-dimensional array
     * 转换节点和其后代节点为一维数组
     * @param stat
     * @returns
     */
    _flat(stat) {
      const r = [];
      hp__namespace.walkTreeData(stat, child => {
        r.push(child);
      }, {
        childrenKey: CHILDREN
      });
      return r;
    },

    /**
     * get count of stat and its all children
     * 统计节点和其后代节点数量
     * @param stat
     */
    _count(stat) {
      return this._flat(stat).length;
    },

    getData(filter, root) {
      const {
        childrenKey
      } = this;
      const td = new hp__namespace.TreeData([]);
      td.childrenKey = childrenKey;
      hp__namespace.walkTreeData(root || this.stats, (stat, index, parent, path) => {
        let newData = { ...stat.data,
          [childrenKey]: []
        };

        if (filter) {
          // @ts-ignore
          newData = filter(newData);
        }

        td.set(path, newData);
      }, {
        childrenKey: CHILDREN
      });
      return td.data;
    }

  };
  const utils = utilsBase;

  if (!utilsBase.noInitialization) {
    utils.init();
  }

  return utils;
}
const defaultOptions = {
  childrenKey: "children",
  defaultOpen: false,

  statsHandler(stats) {
    return stats;
  },

  statsFlatHandler(statsFlat) {
    return statsFlat;
  },

  afterSetStat(stat, parent, index) {},

  afterRemoveStat(stat) {},

  statHandler(stat) {
    return stat;
  }

};
function statDefault() {
  return {
    isStat: true,
    hidden: false,
    checked: false,
    style: null,
    class: null,
    draggable: null,
    droppable: null
  };
}

class StatNotFoundError extends Error {
  constructor(message) {
    super(message);
    this.name = "StatNotFoundError";
  }

}

exports.CHILDREN = CHILDREN;
exports.defaultOptions = defaultOptions;
exports.makeTreeProcessor = makeTreeProcessor;
exports.statDefault = statDefault;
