/*!
 * @he-tree/tree-utils v0.1.0-alpha.5
 * Author: phphe <phphe@outlook.com> (https://github.com/phphe)
 * Homepage: null
 * Released under the MIT License.
 */
var treeUtils=function(t){"use strict";function e(t,e,n){return e in t?Object.defineProperty(t,e,{value:n,enumerable:!0,configurable:!0,writable:!0}):t[e]=n,t}
/*!
   * helper-js v3.1.2
   * Author: phphe <phphe@outlook.com> (https://github.com/phphe)
   * Homepage: null
   * Released under the MIT License.
   */function n(t){return"[object Array]"===Object.prototype.toString.call(t)}function s(t,e){let n,s=0;for(;(n=t.indexOf(e))>-1;)t.splice(n,1),s++;return s}function i(t,e){return Object.keys(e).forEach((n=>{!function(t,e,n){t.hasOwnProperty(e)||(t[e]=n)}(t,n,e[n])})),t}function r(t,e){let s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};s=i({...s},{childrenKey:"children"});const{childrenKey:r}=s,l=n(t)?t:[t];class a{}const c=(t,n,i)=>{s.reverse&&(t=t.slice()).reverse();const l=t.length;for(let h=0;h<l;h++){const o=t[h],d=s.reverse?l-h-1:h,u=i?[...i,d]:[];s.childFirst&&null!=o[r]&&c(o[r],o,u);const f=e(o,d,n,u);if(!1===f)throw new a;if("skip children"!==f){if("skip siblings"===f)break;s.childFirst||null!=o[r]&&c(o[r],o,u)}}};try{c(l,null,n(t)?[]:null)}catch(t){if(!(t instanceof a))throw t}}class l{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];e(this,"data",void 0),e(this,"childrenKey","children"),this.data=t}get rootChildren(){const{childrenKey:t}=this,{data:e}=this;return n(e)?e:e[t]}*iteratePath(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{childrenKey:n,rootChildren:s}=this;if(e.reverse){const n=[...this.iteratePath(t,{...e,reverse:!1})];n.reverse();for(const{path:t,node:e}of n){const n=t;yield{path:n,node:e}}}else{let e=[],i=s;for(const s of t){const t=[...e,s],r=i[s];yield{path:t,node:r},e=t,i=r[n]}}}getFamily(t){const e=[];for(const{node:n}of this.iteratePath(t))e.push(n);return e}get(t){return(e=this.getFamily(t))[e.length-1];var e}getParentAndIndex(t){const e=t.slice(),n=e.pop();return{parent:this.get(e),index:n,parentPath:e}}getParent(t){return this.getParentAndIndex(t).parent}set(t,e){if(null==t||0===t.length)this.data=e;else{const{childrenKey:n}=this;let{rootChildren:s}=this;const{parent:i,index:r}=this.getParentAndIndex(t);let l;1===t.length?(s||(this.data?this.data[n]=[]:this.data=[]),l=s):(i[n]||(i[n]=[]),l=i[n]),l[r]=e}}delete(t){const{childrenKey:e,rootChildren:n}=this,{parent:s,index:i}=this.getParentAndIndex(t),r=1===t.length?n:s[e],l=r[i];return r.splice(i,1),l}walk(t,e){const{childrenKey:n,data:s}=this;return r(s,t,n,e)}clone(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return function(t,e){const n={childrenKey:"children"};e&&Object.assign(n,e);const{childrenKey:s,nodeHandler:i}=n,a=new l;a.childrenKey=s,r(t,((t,e,n,r)=>{let l=Object.assign({},t);l[s]&&(l[s]=[]),i&&(l=i(l,{oldNode:t,index:e,parent:n,path:r})),a.set(r,l)}),{childrenKey:s}),a.data}(this.data),function(t){const e={};return Object.keys(t).forEach((n=>{void 0!==t[n]&&(e[n]=t[n])})),e}({childrenKey:this.childrenKey,nodeHandler:t.nodeHandler||void 0})}}const a="children";const c={childrenKey:"children",defaultOpen:!1,statsHandler:t=>t,statsFlatHandler:t=>t,afterSetStat(t,e,n){},afterRemoveStat(t){},statHandler:t=>t};function h(){return{isStat:!0,hidden:!1,checked:!1,style:null,class:null,draggable:null,droppable:null}}class o extends Error{constructor(t){super(t),this.name="StatNotFoundError"}}return t.CHILDREN=a,t.defaultOptions=c,t.makeTreeProcessor=function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=e,i={...c,...n,data:t,stats:null,statsFlat:null,_statsMap:null,initialized:!1,init(){const{data:t,childrenKey:e}=this,n=new l([]);this._statsMap=new Map,r(t,((t,e,s,i)=>{const r=this.statHandler({isStat:!0,hidden:!1,checked:!1,style:null,class:null,draggable:null,droppable:null,data:t,open:Boolean(this.defaultOpen),parent:n.getParent(i),children:[],level:i.length});this._statsMap.set(t,r),n.set(i,r)}),{childrenKey:e});const s=[];n.walk((t=>{s.push(t)})),this.stats=this.statsHandler(n.rootChildren),this.statsFlat=this.statsFlatHandler(s),this.initialized=!0},getStat(t){let e=this._statsMap.get(t);if(!e)throw new o("Stat not found");return e},has(t){if(t.isStat)return this.statsFlat.indexOf(t)>-1;try{let e=this.getStat(t);return Boolean(e)}catch(t){if(t instanceof o)return!1;throw t}},_getPathByStat(t){if(null==t)return[];const e=this.getSiblings(t).indexOf(t);return[...t.parent?this._getPathByStat(t.parent):[],e]},afterOneCheckChanged(t){const{checked:e}=t;if(t._ignoreCheckedOnce)return delete t._ignoreCheckedOnce,!1;const n=t=>{const{parent:e}=t;if(e){let t,s,i;for(const n of e.children)n.checked?t=!0:0===n.checked?i=!0:s=!0;const r=i?0:!s||!!t&&0;e.checked!==r&&(this._ignoreCheckedOnce(e),e.checked=r),n(e)}};return n(t),r(t.children,(t=>{t.checked!==e&&(this._ignoreCheckedOnce(t),t.checked=e)}),{childrenKey:a}),!0},_ignoreCheckedOnce(t){t._ignoreCheckedOnce=!0,setTimeout((()=>{t._ignoreCheckedOnce&&(t._ignoreCheckedOnce=!1)}),100)},isVisible(t){const e=t.isStat?t:this.getStat(t),n=t=>!t||!t.hidden&&t.open&&n(t.parent);return Boolean(!e.hidden&&n(e.parent))},updateCheck(){r(this.stats,(t=>{if(t.children&&t.children.length>0){const e=t.children.every((t=>t.checked));t.checked!==e&&(this._ignoreCheckedOnce(t),t.checked=e)}}),{childFirst:!0,childrenKey:a})},getChecked(){let t=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return this.statsFlat.filter((e=>e.checked||t&&0===e.checked))},getUnchecked(){let t=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];return this.statsFlat.filter((e=>t?!e.checked:!1===e.checked))},openAll(){for(const t of this.statsFlat)t.open=!0},closeAll(){for(const t of this.statsFlat)t.open=!1},openNodeAndParents(t){const e=t.isStat?t:this.getStat(t);for(const t of this.iterateParent(e,{withSelf:!0}))t.open=!0},_calcFlatIndex(t,e){let n=t?this.statsFlat.indexOf(t)+1:0;const s=t?t.children:this.stats;for(let t=0;t<e;t++)n+=this._count(s[t]);return n},add(t,e,n){if(this.has(t))throw"Can't add because data exists in tree";const s=e?e.children:this.stats;null==n&&(n=s.length);const i=this.statHandler({isStat:!0,hidden:!1,checked:!1,style:null,class:null,draggable:null,droppable:null,open:Boolean(this.defaultOpen),data:t,parent:e||null,children:[],level:e?e.level+1:1});this._setPosition(i,e||null,n);const r=t[this.childrenKey];if(r){const t=r.slice();for(const e of t)this.add(e,i)}},remove(t){const e=this.getSiblings(t);if(e.includes(t)){s(e,t);const n=this._flat(t);this.statsFlat.splice(this.statsFlat.indexOf(t),n.length);for(const t of n)this._statsMap.delete(t.data);return this.afterRemoveStat(t),!0}return!1},getSiblings(t){const{parent:e}=t;return e?e.children:this.stats},_setPosition(t,e,n){(e?e.children:this.stats).splice(n,0,t),t.parent=e,t.level=e?e.level+1:1;const s=this._calcFlatIndex(e,n),i=this._flat(t);this.statsFlat.splice(s,0,...i);for(const t of i)this._statsMap.has(t.data)||this._statsMap.set(t.data,t);r(t,((t,e,n)=>{n&&(t.level=n.level+1)}),{childrenKey:a}),this.afterSetStat(t,e,n)},*iterateParent(t,e){let n=null!=e&&e.withSelf?t:t.parent;for(;n;)yield n,n=n.parent},move(t,e,n){if(this.has(t)){if(t.parent===e&&this.getSiblings(t).indexOf(t)===n)return!1;if(t===e)throw new Error("Can't move node to it self");if(e&&t.level<e.level){let n;for(const s of this.iterateParent(e))if(s.level===t.level){n=s;break}if(t===n)throw new Error("Can't move node to its descendant")}this.remove(t)}return this._setPosition(t,e,n),!0},_flat(t){const e=[];return r(t,(t=>{e.push(t)}),{childrenKey:a}),e},_count(t){return this._flat(t).length},getData(t,e){const{childrenKey:n}=this,s=new l([]);return s.childrenKey=n,r(e||this.stats,((e,i,r,l)=>{let a={...e.data,[n]:[]};t&&(a=t(a)),s.set(l,a)}),{childrenKey:a}),s.data}},h=i;return i.noInitialization||h.init(),h},t.statDefault=h,Object.defineProperty(t,"__esModule",{value:!0}),t}({});
//# sourceMappingURL=index.iife.js.map
